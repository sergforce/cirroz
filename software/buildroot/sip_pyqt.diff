diff --git a/package/Config.in b/package/Config.in
index a94cb62..9c9ee19 100644
--- a/package/Config.in
+++ b/package/Config.in
@@ -157,6 +157,11 @@ source "package/qextserialport/Config.in"
 source "package/qjson/Config.in"
 source "package/qtuio/Config.in"
 source "package/qwt/Config.in"
+
+comment "PyQT libraries"
+source "package/sip/Config.in"
+source "package/pyqt/Config.in"
+
 endif
 
 source "package/qt5/Config.in"
diff --git a/package/pyqt/Config.in b/package/pyqt/Config.in
new file mode 100644
index 0000000..bdae8be
--- /dev/null
+++ b/package/pyqt/Config.in
@@ -0,0 +1,6 @@
+config BR2_PACKAGE_PYQT
+	bool "pyqt"
+	depends on BR2_PACKAGE_QT
+	depends on BR2_PACKAGE_SIP
+	help
+	    PyQT
\ No newline at end of file
diff --git a/package/pyqt/configure-qws.py b/package/pyqt/configure-qws.py
new file mode 100644
index 0000000..7687cb0
--- /dev/null
+++ b/package/pyqt/configure-qws.py
@@ -0,0 +1,2526 @@
+# This script generates the PyQt configuration and generates the Makefiles.
+#
+# Copyright (c) 2012 Riverbank Computing Limited <info@riverbankcomputing.com>
+# Copyright (c) 2012 David Boddie <david@boddie.org.uk>
+# 
+# This file is part of PyQt.
+# 
+# This file may be used under the terms of the GNU General Public
+# License versions 2.0 or 3.0 as published by the Free Software
+# Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
+# included in the packaging of this file.  Alternatively you may (at
+# your option) use any later version of the GNU General Public
+# License if such license has been publicly approved by Riverbank
+# Computing Limited (or its successors, if any) and the KDE Free Qt
+# Foundation. In addition, as a special exception, Riverbank gives you
+# certain additional rights. These rights are described in the Riverbank
+# GPL Exception version 1.1, which can be found in the file
+# GPL_EXCEPTION.txt in this package.
+# 
+# If you are unsure which license is appropriate for your use, please
+# contact the sales department at sales@riverbankcomputing.com.
+# 
+# This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+# WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+
+
+import sys
+import os
+import glob
+import optparse
+import shutil
+import imp
+
+
+import sipconfig
+cross_sipconfig = sipconfig
+
+## sipconfig = imp.load_source('sipconfig', '/sd/serg/CIRROS/buildroot-2013.02/output/build/sip-4.14.5/sipconfig.py')
+## cross_sipconfig = sipconfig
+
+
+# Initialise the globals.
+pyqt_version = 0x040906
+pyqt_version_str = "4.9.6 (QWS)"
+
+sip_min_version = 0x040d03
+
+qt_version = 0
+qt_edition = ""
+qt_licensee = None
+qt_dir = None
+qt_incdir = None
+qt_libdir = None
+qt_bindir = None
+qt_datadir = None
+qt_pluginsdir = None
+qt_xfeatures = None
+qt_shared = ""
+qt_framework = 0
+
+# This default value will be used by the code that bootstraps the Qt
+# configuration.
+qt_macx_spec = 'macx-g++'
+
+qt_sip_flags = []
+
+pyqt_modules = []
+pyqt_modroot = None
+src_dir = os.path.dirname(os.path.abspath(__file__))
+
+# Get the SIP configuration.
+sipcfg = sipconfig.Configuration()
+
+pydbusmoddir = None
+dbusincdirs = []
+dbuslibdirs = []
+dbuslibs = []
+
+
+# Under Windows qmake and the Qt DLLs must be on the system PATH otherwise the
+# dynamic linker won't be able to resolve the symbols.  On other systems we
+# assume we can just run qmake by using its full pathname.
+if sys.platform == 'win32':
+    MSG_CHECK_QMAKE = "Make sure you have a working Qt v4 qmake on your PATH."
+else:
+    MSG_CHECK_QMAKE = "Make sure you have a working Qt v4 qmake on your PATH or use the -q argument to explicitly specify a working Qt v4 qmake."
+
+
+def find_default_qmake():
+    """Find a default qmake, ie. the first on the path.
+    """
+    try:
+        path = os.environ["PATH"]
+    except KeyError:
+        path = ""
+
+    if sys.platform == 'win32':
+        base_qmake = "qmake.exe"
+    else:
+        base_qmake = "qmake"
+
+    for d in path.split(os.pathsep):
+        qmake = os.path.join(d, base_qmake)
+  
+        if os.access(qmake, os.X_OK):
+            return qmake
+
+    return ""
+
+
+def create_optparser():
+    """Create the parser for the command line.
+    """
+    qmake = find_default_qmake()
+
+    def store_abspath(option, opt_str, value, parser):
+        setattr(parser.values, option.dest, os.path.abspath(value))
+
+    def store_abspath_dir(option, opt_str, value, parser):
+        if not os.path.isdir(value):
+            raise optparse.OptionValueError("'%s' is not a directory" % value)
+        setattr(parser.values, option.dest, os.path.abspath(value))
+        
+    def store_abspath_file(option, opt_str, value, parser):
+        if not os.path.isfile(value):
+            raise optparse.OptionValueError("'%s' is not a file" % value)
+        setattr(parser.values, option.dest, os.path.abspath(value))
+
+    p = optparse.OptionParser(usage="python %prog [opts] [macro=value] "
+            "[macro+=value]", version=pyqt_version_str)
+
+    # Note: we don't use %default to be compatible with Python 2.3.
+    p.add_option("-k", "--static", action="store_true", default=False,
+            dest="static", help="build modules as static libraries")
+    p.add_option("--no-docstrings", action="store_true", default=False,
+            dest="no_docstrings", help="disable the generation of docstrings")
+    p.add_option("-r", "--trace", action="store_true", default=False,
+            dest="tracing", help="build modules with tracing enabled")
+    p.add_option("-u", "--debug", action="store_true", default=False,
+            help="build modules with debugging symbols")
+    p.add_option("-w", "--verbose", action="count", default=0, dest="verbose",
+            help="verbose output during configuration")
+
+    p.add_option("-c", "--concatenate", action="store_true", default=False,
+            dest="concat", help="concatenate each module's C++ source files")
+    p.add_option("-j", "--concatenate-split", type="int", default=1,
+            metavar="N", dest="split",
+            help="split the concatenated C++ source files into N pieces "
+            "[default: 1]")
+    p.add_option("-g", "--consolidate", action="store_true", default=False,
+            dest="bigqt", help="create a single module which links against "
+            "all the Qt libraries")
+
+    # These are internal options used to build the mega Windows GPL package.
+    p.add_option("--mwg-odbc", action="store_true", default=False,
+            dest="mwg_odbc", help=optparse.SUPPRESS_HELP)
+    p.add_option("--mwg-openssl", action="callback", default=None,
+            dest="mwg_ssl_dir", metavar="DIR", callback=store_abspath_dir,
+            type="string", help=optparse.SUPPRESS_HELP)
+    p.add_option("--mwg-qsci", action="callback", default=None,
+            dest="mwg_qsci_dir", metavar="DIR", callback=store_abspath_dir,
+            type="string", help=optparse.SUPPRESS_HELP)
+    p.add_option("--mwg-qwt", action="callback", default=None,
+            dest="mwg_qwt_dir", metavar="DIR", callback=store_abspath_dir,
+            type="string", help=optparse.SUPPRESS_HELP)
+
+    # Configuration.
+    g = optparse.OptionGroup(p, title="Configuration")
+    g.add_option("--confirm-license", action="store_true", default=False,
+            dest="license_confirmed", help="confirm acceptance of the license")
+    g.add_option("-e", "--enable", action="append", default=[],
+            metavar="MODULE", dest="enabled", help="enable checks for the "
+            "specified MODULE [default: checks for all modules will be "
+            "enabled]")
+    g.add_option("--no-designer-plugin", action="store_false", default=True,
+            dest="designer_plugin", help="disable the building of the "
+            "Python plugin for Qt Designer [default: enabled]")
+    g.add_option("-t", "--plugin", action="append", default=[],
+            metavar="PLUGIN", dest="staticplugins", help="add PLUGIN to the "
+            "list be linked (if Qt is built as static libraries)")
+    g.add_option("--assume-shared", action="store_true", default=False,
+            dest="assume_shared", help="assume that the Qt libraries have "
+            "been built as shared libraries [default: check]")
+    g.add_option("-T", "--no-timestamp", action="store_true", default=False,
+            dest="no_timestamp", help="suppress timestamps in the header "
+            "comments of generated code [default: include timestamps]")
+
+    if sys.platform != 'win32':
+        if sys.platform.startswith('linux') or sys.platform == 'darwin':
+            pip_default = True
+            pip_default_str = "enabled"
+        else:
+            pip_default = False
+            pip_default_str = "disabled"
+
+        g.add_option("--protected-is-public", action="store_true",
+                default=pip_default, dest="prot_is_public",
+                help="enable building with 'protected' redefined as 'public' "
+                        "[default: %s]" % pip_default_str)
+        g.add_option("--protected-not-public", action="store_false",
+                dest="prot_is_public",
+                help="disable building with 'protected' redefined as 'public'")
+        g.add_option("-q", "--qmake", action="callback", metavar="FILE",
+                default=qmake, dest="qmake", callback=store_abspath_file,
+                type="string",
+                help="the pathname of qmake [default: %s]" % (qmake or "none"))
+
+    g.add_option("-s", "--dbus", action="callback", metavar="DIR",
+            dest="pydbusincdir", callback=store_abspath_dir, type="string",
+            help="the directory containing the dbus/dbus-python.h header file "
+            "[default: supplied by pkg-config]")
+    p.add_option_group(g)
+
+    if sys.platform == 'darwin':
+        g = optparse.OptionGroup(p, title="MacOS X Configuration")
+        g.add_option("--use-arch", action="store", metavar="ARCH",
+                dest="use_arch", choices=["i386", "x86_64", "ppc"],
+                help="the architecture to use when running pyuic4 "
+                        "[default: system default]")
+        p.add_option_group(g)
+
+    # Installation.
+    g = optparse.OptionGroup(p, title="Installation")
+    g.add_option("-b", "--bindir", action="callback",
+            default=sipcfg.default_bin_dir, type="string", metavar="DIR",
+            dest="pyqtbindir", callback=store_abspath, help="where pyuic4, "
+            "pyrcc4 and pylupdate4 will be installed [default: %s]" %
+            sipcfg.default_bin_dir)
+    g.add_option("-d", "--destdir", action="callback",
+            default=sipcfg.default_mod_dir, type="string", metavar="DIR",
+            dest="pyqtmoddir", callback=store_abspath, help="where the PyQt4 "
+            "Python package will be installed [default: %s]" %
+            sipcfg.default_mod_dir)
+    g.add_option("-p", "--plugin-destdir", action="callback", type="string",
+            metavar="DIR", dest="plugindir", callback=store_abspath,
+            help="where any plugins will be installed [default: "
+            "QTDIR/plugins]")
+    g.add_option("--no-sip-files", action="store_false", default=True,
+            dest="install_sipfiles", help="disable the installation of the "
+            ".sip files [default: enabled]")
+    g.add_option("-v", "--sipdir", action="callback",
+            default=os.path.join(sipcfg.default_sip_dir, "PyQt4"),
+            metavar="DIR", dest="pyqtsipdir", callback=store_abspath,
+            type="string", help="where the PyQt4 .sip files will be installed "
+            "[default: %s]" % sipcfg.default_sip_dir)
+    p.add_option_group(g)
+
+    # Vendor ID.
+    g = optparse.OptionGroup(p, title="VendorID support")
+    g.add_option("-i", "--vendorid", action="store_true", default=False,
+            dest="vendorcheck", help="enable checking of signed interpreters "
+            "using the VendorID package [default: disabled]")
+    g.add_option("-l", "--vendorid-incdir", action="callback",
+            default=sipcfg.py_inc_dir, type="string", metavar="DIR",
+            dest="vendincdir", callback=store_abspath_dir, help="the "
+            "directory containing the VendorID header file [default: %s]" %
+            sipcfg.py_inc_dir)
+    g.add_option("-m", "--vendorid-libdir", action="callback",
+            default=sipcfg.py_lib_dir, type="string", metavar="DIR",
+            dest="vendlibdir", callback=store_abspath_dir, help="the "
+            "directory containing the VendorID library [default: %s]" %
+            sipcfg.py_lib_dir)
+    p.add_option_group(g)
+
+    # QScintilla.
+    g = optparse.OptionGroup(p, title="QScintilla support")
+    g.add_option("-a", "--qsci-api", action="store_true", default=None,
+            dest="api", help="always install the PyQt API file for QScintilla "
+            "[default: install only if QScintilla installed]")
+    g.add_option("--no-qsci-api", action="store_false", default=None,
+            dest="api", help="do not install the PyQt API file for QScintilla "
+            "[default: install only if QScintilla installed]")
+    g.add_option("-n", "--qsci-api-destdir", action="callback", dest="qscidir",
+            metavar="DIR", callback=store_abspath, type="string", help="where "
+            "the PyQt API file for QScintilla will be installed [default: "
+            "QTDIR/qsci]")
+    p.add_option_group(g)
+
+    return p
+
+
+class pyrccMakefile(sipconfig.ProgramMakefile):
+    """This class implements the Makefile for pyrcc.  This is specialised so
+    that pyrcc is automatically run against the examples.
+    """
+
+    def __init__(self, cfg = sipcfg):
+        self.cfg = cfg
+        sipconfig.ProgramMakefile.__init__(self, configuration=cfg,
+                build_file=os.path.join(src_dir, "pyrcc", "pyrcc.sbf"),
+                dir="pyrcc", install_dir=opts.pyqtbindir, console=1,
+                qt=["QtCore", "QtXml"], debug=opts.debug, warnings=1,
+                universal=cfg.universal, arch=cfg.arch,
+                deployment_target=cfg.deployment_target)
+
+    def generate_target_default(self, mfile):
+        """Generate the default target."""
+        sipconfig.ProgramMakefile.generate_target_default(self, mfile)
+
+        # The correct call to pyrcc depends on the Python version.
+        if sys.hexversion >= 0x03000000:
+            flag = "-py3"
+        else:
+            flag = "-py2"
+
+        exe = "$(TARGET)"
+        if sys.platform != 'win32':
+            exe = "./" + exe
+
+        # Find all the .qrc files in the examples.
+        #for root, _, files in os.walk("examples"):
+        #    rel_root = os.path.join("..", root)
+        #
+        #    for fn in files:
+        #        if fn.endswith(".qrc"):
+        #            mfile.write("\t%s %s-o %s %s\n" % (exe, flag, os.path.join(rel_root, fn[:-4] + "_rc.py"), os.path.join(rel_root, fn)))
+
+
+class ConfigurePyQt4:
+    """This class defines the methods to configure PyQt4.
+    """
+    def __init__(self, generator):
+        self.generator = generator
+
+    def qt_version_tags(self):
+        """Get the versions tags for the configuration.
+
+        Returns a dictionary of versions and corresponding tags.
+        """
+        return {
+            0x040101: None,
+            0x040102: "Qt_4_1_1",
+            0x040103: "Qt_4_1_2",
+            0x040200: "Qt_4_1_3",
+            0x040202: "Qt_4_2_0",
+            0x040300: "Qt_4_2_2",
+            0x040303: "Qt_4_3_0",
+            0x040400: "Qt_4_3_3",
+            0x040401: "Qt_4_4_0",
+            0x040500: "Qt_4_4_1",
+            0x040501: "Qt_4_5_0",
+            0x040600: "Qt_4_5_1",
+            0x040601: "Qt_4_6_0",
+            0x040602: "Qt_4_6_1",
+            0x040603: "Qt_4_6_2",
+            0x040700: "Qt_4_6_3",
+            0x040701: "Qt_4_7_0",
+            0x040702: "Qt_4_7_1",
+            0x040800: "Qt_4_7_2",
+            0x050000: "Qt_4_8_0",
+            0x060000: "Qt_5_0_0"
+        }
+
+    def check_modules(self):
+        if opts.mwg_odbc:
+            sql_libs = ["odbc32"]
+        else:
+            sql_libs = None
+
+        if opts.mwg_ssl_dir:
+            ass_lib_dirs = [os.path.join(opts.mwg_ssl_dir, "lib")]
+            ass_libs = ["ssleay32", "libeay32"]
+        else:
+            ass_lib_dirs = None
+            ass_libs = None
+
+        # Note that the order in which we check is important for the
+        # consolidated module - a module's dependencies must be checked first.
+        pyqt_modules.append("QtCore")
+
+        check_module("QtGui", "qwidget.h", "new QWidget()")
+        if qt_version < 0x050000: check_module("QtHelp", "qhelpengine.h", "new QHelpEngine(\"foo\")")
+        if qt_version < 0x050000: check_module("QtMultimedia", "QAudioDeviceInfo",
+                "new QAudioDeviceInfo()")
+        if qt_version < 0x050000: check_module("QtNetwork", "qhostaddress.h", "new QHostAddress()")
+        if qt_version < 0x050000: check_module("QtDBus", "qdbusconnection.h",
+                "QDBusConnection::systemBus()")
+        if qt_version < 0x050000: check_module("QtDeclarative", "qdeclarativeview.h",
+                "new QDeclarativeView()")
+        if qt_version < 0x050000: check_module("QtOpenGL", "qgl.h", "new QGLWidget()")
+        if qt_version < 0x050000: check_module("QtScript", "qscriptengine.h", "new QScriptEngine()")
+        if qt_version < 0x050000: check_module("QtScriptTools", "qscriptenginedebugger.h",
+                "new QScriptEngineDebugger()")
+        if qt_version < 0x050000: check_module("QtSql", "qsqldatabase.h", "new QSqlDatabase()",
+                extra_libs=sql_libs)
+        if qt_version < 0x050000: check_module("QtSvg", "qsvgwidget.h", "new QSvgWidget()")
+        if qt_version < 0x050000: check_module("QtTest", "QtTest", "QTest::qSleep(0)")
+        if qt_version < 0x050000: check_module("QtWebKit", "qwebpage.h", "new QWebPage()")
+        if qt_version < 0x050000: check_module("QtXml", "qdom.h", "new QDomDocument()")
+        if qt_version < 0x050000: check_module("QtXmlPatterns", "qxmlname.h", "new QXmlName()")
+        if qt_version < 0x050000: check_module("phonon", "phonon/videowidget.h",
+                "new Phonon::VideoWidget()")
+        if qt_version < 0x050000: check_module("QtAssistant", "qassistantclient.h",
+                "new QAssistantClient(\"foo\")", extra_lib_dirs=ass_lib_dirs,
+                extra_libs=ass_libs)
+
+        #if not qt_shared:
+        #    sipconfig.inform("QtDesigner module disabled with static Qt libraries.")
+        #elif sipcfg.universal:
+        #    sipconfig.inform("QtDesigner module disabled with universal binaries.")
+        #else:
+        #    if qt_version < 0x050000: check_module("QtDesigner", "QExtensionFactory",
+        #            "new QExtensionFactory()")
+
+        #if qt_version < 0x050000: check_module("QAxContainer", "qaxobject.h", "new QAxObject()",
+        #        extra_libs=["QAxContainer"])
+
+        #if os.path.isdir(os.path.join(src_dir, "dbus")):
+        #    check_dbus()
+
+    def code(self):
+        # Note that the order of the dependent modules is important.
+
+        cons_xtra_incdirs = []
+        cons_xtra_libdirs = []
+        cons_xtra_libs = []
+
+        sp_libs, sp_libdirs = self._static_plugins("QtCore")
+        sp_incdirs = []
+
+        qpy_inc_dir, qpy_lib_dir, qpy_lib = self._qpy_directories("QtCore", "qpycore")
+        sp_incdirs.append(qpy_inc_dir)
+        sp_libdirs.append(qpy_lib_dir)
+        sp_libs.append(qpy_lib)
+
+        if opts.vendorcheck:
+            sp_incdirs.append(opts.vendincdir)
+            sp_libdirs.append(opts.vendlibdir)
+            sp_libs.append("vendorid")
+
+        if opts.bigqt:
+            cons_xtra_incdirs.extend(sp_incdirs)
+            cons_xtra_libdirs.extend(sp_libdirs)
+            cons_xtra_libs.extend(sp_libs)
+
+            generate_code("QtCore")
+        else:
+            generate_code("QtCore", extra_include_dirs=sp_incdirs,
+                        extra_lib_dirs=sp_libdirs, extra_libs=sp_libs)
+
+        if "QtDeclarative" in pyqt_modules:
+            qpy_inc_dir, qpy_lib_dir, qpy_lib = self._qpy_directories("QtDeclarative", "qpydeclarative")
+
+            if opts.bigqt:
+                cons_xtra_incdirs.append(qpy_inc_dir)
+                cons_xtra_libdirs.append(qpy_lib_dir)
+                cons_xtra_libs.append(qpy_lib)
+
+                generate_code("QtDeclarative")
+            else:
+                generate_code("QtDeclarative", extra_include_dirs=[qpy_inc_dir],
+                        extra_lib_dirs=[qpy_lib_dir], extra_libs=[qpy_lib])
+
+        if "QtGui" in pyqt_modules:
+            sp_libs, sp_libdirs = self._static_plugins("QtGui")
+            sp_incdirs = []
+
+            qpy_inc_dir, qpy_lib_dir, qpy_lib = self._qpy_directories("QtGui", "qpygui")
+            sp_incdirs.append(qpy_inc_dir)
+            sp_libdirs.append(qpy_lib_dir)
+            sp_libs.append(qpy_lib)
+
+            if opts.bigqt:
+                cons_xtra_incdirs.extend(sp_incdirs)
+                cons_xtra_libdirs.extend(sp_libdirs)
+                cons_xtra_libs.extend(sp_libs)
+
+                generate_code("QtGui")
+            else:
+                generate_code("QtGui", extra_include_dirs=sp_incdirs,
+                        extra_lib_dirs=sp_libdirs, extra_libs=sp_libs)
+
+        if "QtHelp" in pyqt_modules:
+            generate_code("QtHelp")
+
+        if "QtMultimedia" in pyqt_modules:
+            generate_code("QtMultimedia")
+
+        if "QtNetwork" in pyqt_modules:
+            generate_code("QtNetwork")
+
+        if "QtDBus" in pyqt_modules:
+            qpy_inc_dir, qpy_lib_dir, qpy_lib = self._qpy_directories("QtDBus", "qpydbus")
+
+            if opts.bigqt:
+                cons_xtra_incdirs.append(qpy_inc_dir)
+                cons_xtra_libdirs.append(qpy_lib_dir)
+                cons_xtra_libs.append(qpy_lib)
+
+                generate_code("QtDBus")
+            else:
+                generate_code("QtDBus", extra_include_dirs=[qpy_inc_dir],
+                        extra_lib_dirs=[qpy_lib_dir], extra_libs=[qpy_lib])
+
+        if "QtOpenGL" in pyqt_modules:
+            generate_OpenGL_extras()
+
+            qpy_inc_dir, qpy_lib_dir, qpy_lib = self._qpy_directories("QtOpenGL", "qpyopengl")
+
+            if opts.bigqt:
+                cons_xtra_incdirs.append(qpy_inc_dir)
+                cons_xtra_libdirs.append(qpy_lib_dir)
+                cons_xtra_libs.append(qpy_lib)
+
+                generate_code("QtOpenGL")
+            else:
+                generate_code("QtOpenGL", extra_include_dirs=[qpy_inc_dir],
+                        extra_lib_dirs=[qpy_lib_dir], extra_libs=[qpy_lib])
+
+        if "QtScript" in pyqt_modules:
+            generate_code("QtScript")
+
+        if "QtScriptTools" in pyqt_modules:
+            generate_code("QtScriptTools")
+
+        if "QtSql" in pyqt_modules:
+            sp_libs, sp_libdirs = self._static_plugins("QtSql")
+
+            if opts.bigqt:
+                cons_xtra_libdirs.extend(sp_libdirs)
+                cons_xtra_libs.extend(sp_libs)
+
+                generate_code("QtSql")
+            else:
+                generate_code("QtSql", extra_lib_dirs=sp_libdirs,
+                        extra_libs=sp_libs)
+
+        if "QtSvg" in pyqt_modules:
+            generate_code("QtSvg")
+
+        if "QtTest" in pyqt_modules:
+            generate_code("QtTest")
+
+        if "QtWebKit" in pyqt_modules:
+            generate_code("QtWebKit")
+
+        if "QtXml" in pyqt_modules:
+            generate_code("QtXml")
+
+        if "QtXmlPatterns" in pyqt_modules:
+            generate_code("QtXmlPatterns")
+
+        if "phonon" in pyqt_modules:
+            generate_code("phonon")
+
+        if "QtAssistant" in pyqt_modules:
+            generate_code("QtAssistant")
+
+        if "QtDesigner" in pyqt_modules:
+            qpy_inc_dir, qpy_lib_dir, qpy_lib = self._qpy_directories("QtDesigner", "qpydesigner")
+
+            if opts.bigqt:
+                cons_xtra_incdirs.append(qpy_inc_dir)
+                cons_xtra_libdirs.append(qpy_lib_dir)
+                cons_xtra_libs.append(qpy_lib)
+
+                generate_code("QtDesigner")
+            else:
+                generate_code("QtDesigner", extra_include_dirs=[qpy_inc_dir],
+                        extra_lib_dirs=[qpy_lib_dir], extra_libs=[qpy_lib])
+
+        if "QAxContainer" in pyqt_modules:
+            generate_code("QAxContainer")
+
+        # Generate the composite module.
+        qtmod_sipdir = os.path.join("sip", "Qt")
+        mk_clean_dir(qtmod_sipdir)
+
+        qtmod_sipfile = os.path.join(qtmod_sipdir, "Qtmod.sip")
+        f = open(qtmod_sipfile, "w")
+
+        f.write("""%CompositeModule PyQt4.Qt
+
+""")
+
+        for m in pyqt_modules:
+            f.write("%%Include %s/%smod.sip\n" % (m, m))
+
+        f.close()
+
+        generate_code("Qt")
+
+        # Generate the consolidated module if required.
+        if opts.bigqt:
+            xtra_sip_flags = []
+
+            _qtmod_sipdir = os.path.join("sip", "_qt")
+            mk_clean_dir(_qtmod_sipdir)
+
+            _qtmod_sipfile = os.path.join(_qtmod_sipdir, "_qtmod.sip")
+            f = open(_qtmod_sipfile, "w")
+
+            f.write("""%ConsolidatedModule PyQt4._qt
+
+""")
+
+            for m in pyqt_modules:
+                f.write("%%Include %s/%smod.sip\n" % (m, m))
+
+            if opts.mwg_qsci_dir:
+                f.write("%Include Qsci/Qscimod.sip\n")
+                cons_xtra_libs.append("qscintilla2")
+
+                # Copy in the QScintilla .sip files and fix the main one.
+                src_dir = os.path.join(opts.mwg_qsci_dir, "Python", "sip")
+                dst_dir = os.path.join("sip", "Qsci")
+
+                try:
+                    shutil.rmtree(dst_dir);
+                except:
+                    pass
+
+                shutil.copytree(src_dir, dst_dir)
+                os.rename(os.path.join(dst_dir, "qscimod4.sip"), os.path.join(dst_dir, "Qscimod.sip"))
+
+                generate_code("Qsci")
+
+            if opts.mwg_qwt_dir:
+                f.write("%Include Qwt5/Qwt5mod.sip\n")
+                cons_xtra_incdirs.append(os.path.join(opts.mwg_qwt_dir, "support"))
+                cons_xtra_libs.append("qwt")
+
+                # Copy in the PyQwt .sip files and fix the main one.
+                src_dir = os.path.join(opts.mwg_qwt_dir, "sip", "qwt5qt4")
+                dst_dir = os.path.join("sip", "Qwt5")
+
+                try:
+                    shutil.rmtree(dst_dir);
+                except:
+                    pass
+
+                shutil.copytree(src_dir, dst_dir)
+                os.rename(os.path.join(dst_dir, "QwtModule.sip"), os.path.join(dst_dir, "Qwt5mod.sip"))
+
+                xtra_sip_flags = ["-t", "Qwt_5_0_1",
+                                  "-x", "CXX_DYNAMIC_CAST",
+                                  "-x", "HAS_QWT4",
+                                  "-x", "HAS_NUMARRAY",
+                                  "-x", "HAS_NUMERIC",
+                                  "-x", "HAS_NUMPY"]
+
+                generate_code("Qwt5", extra_sip_flags=xtra_sip_flags)
+
+            f.close()
+
+            if opts.mwg_odbc:
+                cons_xtra_libs.append("odbc32")
+
+            if opts.mwg_ssl_dir:
+                cons_xtra_libdirs.append(os.path.join(opts.mwg_ssl_dir, "lib"))
+                cons_xtra_libs.extend(["ssleay32", "libeay32"])
+
+            generate_code("_qt", extra_include_dirs=cons_xtra_incdirs,
+                    extra_lib_dirs=cons_xtra_libdirs,
+                    extra_libs=cons_xtra_libs, extra_sip_flags=xtra_sip_flags)
+
+        # Tell the user about any plugins not found.
+        if opts.staticplugins:
+            sipconfig.inform("Unable to find the following static plugins: %s" % ", ".join(opts.staticplugins))
+
+        # Generate the QScintilla API file.
+        sipconfig.inform("Creating QScintilla API file...")
+        f = open("PyQt4.api", "w")
+
+        for m in pyqt_modules:
+            api = open(m + ".api")
+
+            for l in api:
+                f.write("PyQt4." + l)
+
+            api.close()
+            os.remove(m + ".api")
+
+        f.close()
+
+    def _qpy_directories(self, mname, lib_name):
+        """Return a 3-tuple of the directories containing the header files, the
+        directory containing the library, and the name of the support library
+        for the given module.
+
+        mname is the name of the module.
+        lib_name is the normal name of the support library.
+        """
+        qpy_dir = os.path.join("qpy", mname)
+
+        if sys.platform == 'win32':
+            if opts.debug:
+                qpy_lib_dir = os.path.join(qpy_dir, "debug")
+                lib_name = 'd' + lib_name
+            else:
+                qpy_lib_dir = os.path.join(qpy_dir, "release")
+        else:
+            qpy_lib_dir = qpy_dir
+
+            if sys.platform == 'darwin' and opts.debug:
+                lib_name += '_debug'
+
+        return os.path.join(src_dir, qpy_dir), os.path.abspath(qpy_lib_dir), lib_name
+
+    def _static_plugins(self, mname):
+        """Return a tuple of the libraries (in platform neutral format) and the
+        directories they are contained in for all the requested static plugins
+        for the given module.  Generate the additional .sip file needed to
+        ensure the plugins get linked.
+
+        mname is the name of the module.
+        """
+        plugin_dirs = {
+            "QtCore":   ("codecs", ),
+            # Note that we put iconengines after imageformats so that qsvg is
+            # found in the latter rather than the former.  The name clash is
+            # probably a Qt bug.
+            "QtGui":    ("inputmethods", "imageformats", "iconengines"),
+            "QtSql":    ("sqldrivers", )
+        }
+
+        libs = []
+        libdirs = []
+
+        for plug in opts.staticplugins:
+            # Convert the plugin name to a platform specific filename.
+            if self.generator in ("MSVC", "MSVC.NET", "BMAKE"):
+                pfname = plug + ".lib"
+            else:
+                pfname = "lib" + plug + ".a"
+
+            for pdir in plugin_dirs[mname]:
+                ppath = os.path.join(qt_pluginsdir, pdir)
+
+                # See if the plugin exists.
+                if os.access(os.path.join(ppath, pfname), os.F_OK):
+                    sipconfig.inform("Adding the %s static plugin to the %s module..." % (plug, mname))
+
+                    libs.append(plug)
+
+                    if ppath not in libdirs:
+                        libdirs.append(ppath)
+
+                    break
+
+        # Remove those plugins we have handled.
+        opts.staticplugins = [p for p in opts.staticplugins if p not in libs]
+
+        # If we have any plugins for this module then generate a .sip file that
+        # will include the code needed to ensure the plugin gets linked.
+        if libs:
+            sp_sipfile = os.path.join("sip", mname, "staticplugins.sip")
+
+            f = open(sp_sipfile, "w")
+
+            f.write("""%ModuleCode
+
+#include <QtPlugin>
+
+""")
+
+            for l in libs:
+                f.write("Q_IMPORT_PLUGIN(%s)\n" % l)
+
+            f.write("""
+%End
+""")
+
+            f.close()
+
+        return libs, libdirs
+
+    def module_installs(self):
+        return [os.path.join(src_dir, "__init__.py"), "pyqtconfig.py"]
+
+    def qpy_libs(self):
+        # See which QPy support libraries to build.
+        qpylibs = {}
+
+        if "QtCore" in pyqt_modules:
+            qpylibs["QtCore"] = "qpycore.pro"
+
+        if "QtGui" in pyqt_modules:
+            qpylibs["QtGui"] = "qpygui.pro"
+
+        if "QtDBus" in pyqt_modules:
+            qpylibs["QtDBus"] = "qpydbus.pro"
+
+        if "QtDeclarative" in pyqt_modules:
+            qpylibs["QtDeclarative"] = "qpydeclarative.pro"
+
+        if "QtDesigner" in pyqt_modules:
+            qpylibs["QtDesigner"] = "qpydesigner.pro"
+
+        if "QtOpenGL" in pyqt_modules:
+            qpylibs["QtOpenGL"] = "qpyopengl.pro"
+
+        # Run qmake to generate the Makefiles.
+        qmake_args = fix_qmake_args()
+        cwd = os.getcwd()
+
+        cfg = cross_sipcfg or sipcfg
+        for qpy, pro in qpylibs.items():
+            sipconfig.inform("Creating QPy support library for %s Makefile..." % qpy)
+
+            qpydir = os.path.join("qpy", qpy)
+            mk_clean_dir(qpydir, clean=0)
+            os.chdir(qpydir)
+
+            wrapped_pro = "w_" + pro
+
+            f = open(wrapped_pro, 'w+')
+
+            if cfg.arch:
+                f.write(arch_config(cfg))
+
+            if cfg.universal:
+                f.write("QMAKE_MAC_SDK = %s\n" % cfg.universal)
+
+            if cfg.deployment_target:
+                f.write("QMAKE_MACOSX_DEPLOYMENT_TARGET = %s\n" % cfg.deployment_target)
+
+            inc_path = [cfg.py_inc_dir]
+            if qpy in ("QtCore", "QtDBus", "QtDeclarative", "QtOpenGL"):
+                if cfg.sip_inc_dir != cfg.py_inc_dir:
+                    inc_path.insert(0, cfg.sip_inc_dir)
+
+                if opts.bigqt:
+                    api_dir = "../../_qt"
+                else:
+                    api_dir = "../../" + qpy
+
+                inc_path.append(api_dir)
+
+            if opts.debug:
+                pro_config = 'debug'
+            else:
+                pro_config = 'release'
+
+            if src_dir != os.path.curdir:
+                src_qpydir = os.path.join(src_dir, "qpy", qpy)
+                pro = os.path.join(src_qpydir, pro)
+                vpath = "VPATH = " + src_qpydir
+                inc_path.append(src_qpydir)
+            else:
+                vpath = ""
+
+            f.write(
+"""# Tell the original .pro file about additional directories.
+INCLUDEPATH = %s
+CONFIG += %s
+%s
+include(%s)
+""" % (" ".join(['"' + i + '"' for i in inc_path]), pro_config, vpath, pro))
+
+            f.close()
+
+            run_command("%s %s %s" % (opts.qmake, qmake_args, wrapped_pro))
+            os.chdir(cwd)
+
+        sipconfig.inform("Creating QPy support libraries Makefile...")
+
+        sipconfig.ParentMakefile(
+            configuration=cfg,
+            dir="qpy",
+            subdirs=list(qpylibs.keys())
+        ).generate()
+
+        return ["qpy"]
+
+    def tools(self):
+        tool = []
+
+        cfg = cross_sipcfg or sipcfg
+        if pydbusmoddir:
+            sipconfig.inform("Creating dbus support module Makefile...")
+
+            makefile = sipconfig.ModuleMakefile(
+                configuration=sipcfg,
+                build_file=os.path.join(src_dir, "dbus", "dbus.sbf"),
+                dir="dbus",
+                install_dir=pydbusmoddir,
+                qt=["QtCore"],
+                debug=opts.debug,
+                universal=cfg.universal,
+                arch=cfg.arch,
+                deployment_target=cfg.deployment_target
+            )
+
+            add_makefile_extras(makefile, dbusincdirs, dbuslibdirs, dbuslibs)
+
+            makefile.generate()
+            tool.append("dbus")
+
+        # Only include ElementTree for older versions of Python.
+        #if sipcfg.py_version < 0x020500:
+        #    sipconfig.inform("Creating elementtree Makefile...")
+
+        #    makefile = sipconfig.PythonModuleMakefile(
+        #        configuration=sipcfg,
+        #        dstdir=os.path.join(pyqt_modroot, "elementtree"),
+        #        dir="elementtree"
+        #    )
+
+        #    makefile.generate()
+        #    tool.append("elementtree")
+
+        # Create the pyuic4 wrapper.  Use the GUI version on MacOS (so that
+        # previews work properly and normal console use will work anyway), but
+        # not on Windows (so that normal console use will work).
+        #sipconfig.inform("Creating pyuic4 wrapper...")
+
+        #if sys.platform == 'darwin':
+        #    gui = True
+        #    use_arch = opts.use_arch
+        #else:
+        #    gui = False
+        #    use_arch = ''
+
+        # The pyuic directory may not exist if we are building away from the
+        # source directory.
+        try:
+            os.mkdir("pyuic")
+        except OSError:
+            pass
+
+        uicdir=os.path.join(pyqt_modroot, "uic")
+        wrapper = cross_sipconfig.create_wrapper(os.path.join(uicdir, "pyuic.py"), os.path.join("pyuic", "pyuic4"), (sys.platform == "darwin"))
+
+        sipconfig.inform("Creating pyuic4 Makefile...")
+
+        makefile = cross_sipconfig.PythonModuleMakefile(
+            configuration=cfg,
+            dstdir=uicdir,
+            srcdir=os.path.join(src_dir, "pyuic", "uic"),
+            dir="pyuic",
+            installs=[[os.path.basename(wrapper), opts.pyqtbindir]]
+        )
+
+        makefile.generate()
+        tool.append("pyuic")
+
+        if "QtXml" in pyqt_modules and \
+            "PyQt_Translation" not in qt_xfeatures and \
+            "PyQt_MessageBox" not in qt_xfeatures:
+
+            sipconfig.inform("Creating pylupdate4 Makefile...")
+
+            ### Note that the dependency on QtNetwork is only there on Embedded Linux.
+            makefile = cross_sipconfig.ProgramMakefile(
+                configuration=cfg,
+                build_file=os.path.join(src_dir, "pylupdate", "pylupdate.sbf"),
+                dir="pylupdate",
+                install_dir=opts.pyqtbindir,
+                console=1,
+                qt=["QtCore", "QtNetwork", "QtGui", "QtXml"],
+                debug=opts.debug,
+                warnings=1,
+                universal=cfg.universal,
+                arch=cfg.arch,
+                deployment_target=cfg.deployment_target
+            )
+
+            makefile.extra_include_dirs.append(os.path.join(src_dir, "pylupdate"))
+            makefile.generate()
+            tool.append("pylupdate")
+
+            sipconfig.inform("Creating pyrcc4 Makefile...")
+
+            makefile = pyrccMakefile(cfg)
+            makefile.generate()
+            tool.append("pyrcc")
+        else:
+            sipconfig.inform("pylupdate4 and pyrcc4 will not be built because the Qt XML module is missing.")
+
+        if opts.designer_plugin and "QtDesigner" in pyqt_modules:
+            py_major = cfg.py_version >> 16
+            py_minor = (cfg.py_version >> 8) & 0x0ff
+
+            abi = getattr(sys, 'abiflags', '')
+
+            if sys.platform == 'win32':
+                # Use abiflags in case it is supported in a future version.
+                lib_dir_flag = quote("-L%s" % cfg.py_lib_dir)
+                link = "%s -lpython%d%d%s" % (lib_dir_flag, py_major, py_minor, abi)
+                pysh_lib = "python%d%d%s.dll" % (py_major, py_minor, abi)
+            else:
+                # Use distutils to get the additional configuration.
+                from distutils.sysconfig import get_config_vars
+                ducfg = get_config_vars()
+
+                config_args = ducfg.get("CONFIG_ARGS", "")
+
+                if sys.platform == "darwin":
+                    dynamic_pylib = "--enable-framework" in config_args
+
+                    # It's probably a Python bug that the library name doesn't
+                    # include the ABI information.
+                    abi = ""
+                else:
+                    dynamic_pylib = "--enable-shared" in config_args
+
+                if dynamic_pylib:
+                    if glob.glob("%s/lib/libpython%d.%d*" % (ducfg["exec_prefix"], py_major, py_minor)):
+                        lib_dir_flag = quote("-L%s/lib" % ducfg["exec_prefix"])
+                    elif glob.glob("%s/libpython%d.%d*" % (ducfg["LIBDIR"], py_major, py_minor)):
+                        lib_dir_flag = quote("-L%s" % ducfg["LIBDIR"])
+                    else:
+                        sipconfig.inform("Qt Designer plugin disabled because Python library couldn't be found")
+                        lib_dir_flag = ''
+                        opts.designer_plugin = False
+
+                    link = "%s -lpython%d.%d%s" % (lib_dir_flag, py_major, py_minor, abi)
+                else:
+                    sipconfig.inform("Qt Designer plugin disabled because Python library is static")
+                    opts.designer_plugin = False
+
+                pysh_lib = ducfg.get("LDLIBRARY", "")
+
+            if opts.designer_plugin:
+                sipconfig.inform("Creating Qt Designer plugin Makefile...")
+
+                # Run qmake to generate the Makefile.
+                qmake_args = fix_qmake_args()
+                cwd = os.getcwd()
+
+                mk_clean_dir("designer", clean=0)
+                os.chdir("designer")
+
+                # Create the qmake project file.
+                fin = open(os.path.join(src_dir, "designer", "python.pro-in"))
+                prj = fin.read()
+                fin.close()
+
+                prj = prj.replace("@PYINCDIR@", quote(cfg.py_inc_dir))
+                prj = prj.replace("@PYINCDIR@", " ".join((quote(cfg.py_conf_inc_dir), quote(cfg.py_inc_dir))))
+                prj = prj.replace("@PYLINK@", link)
+                prj = prj.replace("@PYSHLIB@", pysh_lib)
+                prj = prj.replace("@QTPLUGINDIR@", quote(opts.plugindir + "/designer"))
+
+                fout = open("python.pro", "w+")
+
+                if sipcfg.arch:
+                    fout.write(arch_config(cfg))
+
+                if sipcfg.universal:
+                    fout.write("QMAKE_MAC_SDK = %s\n" % cfg.universal)
+
+                if sipcfg.deployment_target:
+                    fout.write("QMAKE_MACOSX_DEPLOYMENT_TARGET = %s\n" % cfg.deployment_target)
+
+                if src_dir != os.path.curdir:
+                    fout.write("VPATH = %s\n" % os.path.join(src_dir, "designer"))
+
+                fout.write(prj)
+                fout.close()
+
+                run_command("%s %s" % (opts.qmake, qmake_args))
+                os.chdir(cwd)
+
+                tool.append("designer")
+
+        return tool
+
+
+def arch_config(cfg):
+    """Return the qmake CONFIG line for a MacOS binary."""
+
+    qmake_archs = []
+    for a in sipcfg.arch.split():
+        if a == 'i386':
+            qmake_archs.append('x86')
+        elif a == 'x86_64':
+            qmake_archs.append('x86_64')
+        elif a == 'ppc':
+            qmake_archs.append('ppc')
+
+    return 'CONFIG += %s\n' % ' '.join(qmake_archs)
+
+
+def quote(path):
+    """Return a path with quotes added if it contains spaces."""
+    if " " in path:
+        path = '"%s"' % path
+
+    return path
+
+
+def inform_user():
+    """Tell the user the option values that are going to be used.
+    """
+    if qt_edition:
+        edstr = qt_edition + " edition "
+    else:
+        edstr = ""
+
+    if qt_shared:
+        lib_type = "shared"
+    else:
+        lib_type = "static"
+
+    sipconfig.inform("Qt v%s %sis being used." % (sipconfig.version_to_string(qt_version), edstr))
+
+    if qt_licensee:
+        sipconfig.inform("Qt is licensed to %s." % qt_licensee)
+
+    if sys.platform == "darwin" and qt_framework:
+        sipconfig.inform("Qt is built as a framework.")
+
+    cfg = cross_sipcfg or sipcfg
+    sipconfig.inform("SIP %s is being used." % cfg.sip_version_str)
+    sipconfig.inform("The Qt header files are in %s." % qt_incdir)
+    sipconfig.inform("The %s Qt libraries are in %s." % (lib_type, qt_libdir))
+    sipconfig.inform("The Qt binaries are in %s." % qt_bindir)
+    sipconfig.inform("The Qt mkspecs directory is in %s." % qt_datadir)
+    sipconfig.inform("These PyQt modules will be built: %s." % ", ".join(pyqt_modules))
+    sipconfig.inform("The PyQt Python package will be installed in %s." % opts.pyqtmoddir)
+
+    if opts.no_docstrings:
+        sipconfig.inform("PyQt is being built without generated docstrings.")
+    else:
+        sipconfig.inform("PyQt is being built with generated docstrings.")
+
+    if opts.prot_is_public:
+        sipconfig.inform("PyQt is being built with 'protected' redefined as 'public'.")
+
+    if opts.designer_plugin:
+        sipconfig.inform("The Designer plugin will be installed in %s." % os.path.join(opts.plugindir, "designer"))
+
+    if opts.api:
+        sipconfig.inform("The QScintilla API file will be installed in %s." % os.path.join(opts.qscidir, "api", "python"))
+
+    if pydbusmoddir:
+        sipconfig.inform("The dbus support module will be installed in %s." % pydbusmoddir)
+
+    sipconfig.inform("The PyQt .sip files will be installed in %s." % opts.pyqtsipdir)
+
+    sipconfig.inform("pyuic4, pyrcc4 and pylupdate4 will be installed in %s." % opts.pyqtbindir)
+
+    if opts.vendorcheck:
+        sipconfig.inform("PyQt will only be usable with signed interpreters.")
+
+
+def create_config(module, template, macros):
+    """Create the PyQt configuration module so that it can be imported by build
+    scripts.
+
+    module is the module file name.
+    template is the template file name.
+    macros is the dictionary of platform specific build macros.
+    """
+    sipconfig.inform("Creating %s..." % module)
+
+    content = {
+        "pyqt_config_args":   sys.argv[1:],
+        "pyqt_version":       pyqt_version,
+        "pyqt_version_str":   pyqt_version_str,
+        "pyqt_bin_dir":       opts.pyqtbindir,
+        "pyqt_mod_dir":       pyqt_modroot,
+        "pyqt_sip_dir":       opts.pyqtsipdir,
+        "pyqt_modules":       pyqt_modules,
+        "pyqt_sip_flags":     qt_sip_flags,
+        "qt_version":         qt_version,
+        "qt_edition":         qt_edition,
+        "qt_winconfig":       qt_shared,
+        "qt_framework":       qt_framework,
+        "qt_threaded":        1,
+        "qt_dir":             qt_dir,
+        "qt_data_dir":        qt_datadir,
+        "qt_inc_dir":         qt_incdir,
+        "qt_lib_dir":         qt_libdir
+    }
+
+    cross_sipconfig.create_config_module(module, template, content, macros)
+
+
+def run_command(cmd, envvars=None):
+    """Run a command and display the output if verbose mode is enabled.
+
+    cmd is the command to run.
+    """
+    if opts.verbose:
+        sys.stdout.write(cmd + "\n")
+
+    fout = get_command_stdout(cmd, and_stderr=True, envvars=envvars)
+
+    # Read stdout and stderr until there is no more output.
+    lout = fout.readline()
+    while lout:
+        if opts.verbose:
+            if sys.hexversion >= 0x03000000:
+                sys.stdout.write(str(lout, encoding=sys.stdout.encoding))
+            else:
+                sys.stdout.write(lout)
+
+        lout = fout.readline()
+
+    fout.close()
+
+    try:
+        os.wait()
+    except:
+        pass
+
+
+def remove_file(fname):
+    """Remove a file which may or may not exist.
+
+    fname is the name of the file.
+    """
+    try:
+        os.remove(fname)
+    except OSError:
+        pass
+
+
+def generate_OpenGL_extras():
+    """Generate the extras needed by the QtOpenGL module (i.e. the .sip file
+    defining the correct typedefs for the OpenGL data types.
+    """
+    sipconfig.inform("Determining the OpenGL data types...")
+
+    src = "opengl_extras.cpp"
+
+    f = open(src, "w")
+
+    f.write(
+"""#include <QFile>
+#include <QTextStream>
+#include <qgl.h>
+
+int main(int, char **)
+{
+    QFile outf("./sip/QtOpenGL/opengl_types.sip");
+
+    if (!outf.open(QIODevice::WriteOnly|QIODevice::Truncate|QIODevice::Text))
+        return 1;
+
+    QTextStream out(&outf);
+
+    if (sizeof (long) == sizeof (GLint))
+        out << "typedef long GLint;\\n";
+    else
+        out << "typedef int GLint;\\n";
+
+    if (sizeof (unsigned long) == sizeof (GLuint))
+        out << "typedef unsigned long GLuint;\\n";
+    else
+        out << "typedef unsigned GLuint;\\n";
+
+    if (sizeof (unsigned long) == sizeof (GLenum))
+        out << "typedef unsigned long GLenum;\\n";
+    else
+        out << "typedef unsigned GLenum;\\n";
+
+    if (sizeof (unsigned long) == sizeof (GLbitfield))
+        out << "typedef unsigned long GLbitfield;\\n";
+    else
+        out << "typedef unsigned GLbitfield;\\n";
+
+    out << "typedef float GLfloat;\\n";
+
+    return 0;
+}
+""")
+
+    f.close()
+
+    cmd = compile_qt_program(src, "QtOpenGL")
+
+    if cmd is None:
+        sipconfig.error("Unable to determine the OpenGL data types.")
+
+    # SIP's build system (specifically ProgramMakefile.build_command()) assumes
+    # that an executable can be created by running a single command.  In the
+    # case of MSVC this is incorrect.  As a quick hack we do the extra step
+    # here if it looks like it is needed.
+    if os.access("opengl_extras.manifest", os.F_OK):
+        run_command("mt -nologo -manifest opengl_extras.manifest -outputresource:opengl_extras.exe;1")
+
+    run_command(cmd)
+
+
+def compile_qt_program(name, mname, extra_include_dirs=None, extra_lib_dirs=None, extra_libs=None, library=False):
+    """Compile a simple Qt application.
+
+    name is the name of the single source file.
+    mname is the name of the Qt module.
+    extra_include_dirs is an optional list of extra include directories.
+    extra_lib_dirs is an optional list of extra library directories.
+    extra_libs is an optional list of extra libraries.
+
+    Returns the name of the executable suitable for running or None if it
+    wasn't created.
+    """
+    opengl = (mname == "QtOpenGL")
+
+    qt = [mname]
+    if mname in ("QtOpenGL", "QtWebKit"):
+        qt.append("QtCore")
+
+    cfg = cross_sipcfg or sipcfg
+    makefile = cross_sipconfig.ProgramMakefile(cfg, console=1, qt=qt, warnings=0,
+            opengl=opengl, debug=opts.debug, arch=cfg.arch,
+            deployment_target=cfg.deployment_target)
+
+    add_makefile_extras(makefile, extra_include_dirs, extra_lib_dirs, extra_libs)
+    
+    if library:
+        makefile.extra_lflags.append(sipconfig._default_macros["LFLAGS_SHLIB"])
+
+    exe, build = makefile.build_command(name)
+
+    if cfg.deployment_target:
+        envvars = {'MACOSX_DEPLOYMENT_TARGET': '%s' % cfg.deployment_target}
+    else:
+        envvars = None
+
+    # Make sure the executable file doesn't exist.
+    remove_file(exe)
+    run_command(build, envvars=envvars)
+
+    if not os.access(exe, os.X_OK):
+        return None
+
+    if sys.platform != 'win32':
+        exe = "./" + exe
+
+    return exe
+
+
+def add_makefile_extras(makefile, extra_include_dirs, extra_lib_dirs, extra_libs):
+    """Add any extra include or library directories or libraries to a makefile.
+
+    makefile is the makefile.
+    extra_include_dirs is the list of extra include directories.
+    extra_lib_dirs is the list of extra library directories.
+    extra_libs is the list of extra libraries.
+    """
+    if extra_include_dirs:
+        makefile.extra_include_dirs.extend(extra_include_dirs)
+
+    if extra_lib_dirs:
+        makefile.extra_lib_dirs.extend(extra_lib_dirs)
+
+    if extra_libs:
+        makefile.extra_libs.extend(extra_libs)
+
+
+def check_vendorid():
+    """See if the VendorID library and include file can be found.
+    """
+    if opts.vendorcheck:
+        if os.access(os.path.join(opts.vendincdir, "vendorid.h"), os.F_OK):
+            if glob.glob(os.path.join(opts.vendlibdir, "*vendorid*")):
+                sipconfig.inform("The VendorID package was found.")
+            else:
+                opts.vendorcheck = 0
+                sipconfig.inform("The VendorID library could not be found in "
+                                 "%s and so signed interpreter checking will "
+                                 "be disabled. If the VendorID library is "
+                                 "installed then use the -m argument to "
+                                 "explicitly specify the correct "
+                                 "directory." % opts.vendlibdir)
+        else:
+            opts.vendorcheck = 0
+            sipconfig.inform("vendorid.h could not be found in %s and so "
+                             "signed interpreter checking will be disabled. "
+                             "If the VendorID package is installed then use "
+                             "the -l argument to explicitly specify the "
+                             "correct directory." % opts.vendincdir)
+
+
+def get_command_stdout(cmd, and_stderr=False, envvars=None):
+    """Return stdout (and optionally stderr) from the given command.
+    """
+    if envvars is not None:
+        env = os.environ.copy()
+        env.update(envvars)
+    else:
+        env = None
+
+    try:
+        import subprocess
+    except ImportError:
+        if and_stderr:
+            _, sout = os.popen4(cmd)
+        else:
+            _, sout, _ = os.popen3(cmd)
+
+        return sout
+
+    if and_stderr:
+        stderr = subprocess.STDOUT
+    else:
+        stderr = subprocess.PIPE
+
+    p = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE,
+            stdout=subprocess.PIPE, stderr=stderr, env=env)
+
+    return p.stdout
+
+
+def check_dbus():
+    """See if the DBus support module should be built.
+    """
+    sipconfig.inform("Checking to see if the dbus support module should be built...")
+
+    sout = get_command_stdout("pkg-config --cflags-only-I --libs dbus-1")
+    iflags = sout.read().strip()
+
+    if not iflags:
+        sipconfig.inform("DBus v1 does not seem to be installed.")
+        return
+
+    if sys.hexversion >= 0x03000000:
+        iflags = iflags.decode()
+
+    for f in iflags.split():
+        if f.startswith("-I"):
+            dbusincdirs.append(f[2:])
+        elif f.startswith("-L"):
+            dbuslibdirs.append(f[2:])
+        elif f.startswith("-l"):
+            dbuslibs.append(f[2:])
+
+    try:
+        import dbus.mainloop
+    except:
+        sipconfig.inform("The Python dbus module doesn't seem to be installed.")
+        return
+
+    global pydbusmoddir
+    pydbusmoddir = dbus.mainloop.__path__[0]
+
+    # Try and find dbus-python.h.  We don't use pkg-config because it is broken
+    # for dbus-python (at least for versions up to and including v0.81.0).
+    # Instead we look where DBus itself is installed - which in most cases will
+    # be where dbus-python is also installed.
+    if opts.pydbusincdir:
+        dlist = [opts.pydbusincdir]
+    else:
+        dlist = dbusincdirs
+
+    for d in dlist:
+        if os.access(os.path.join(d, "dbus", "dbus-python.h"), os.F_OK):
+            if d not in dbusincdirs:
+                dbusincdirs.append(d)
+
+            break
+    else:
+        sipconfig.inform("dbus/dbus-python.h could not be found and so the "
+                         "DBus support module will be disabled. If "
+                         "dbus-python v0.80 or later is installed then use "
+                         "the -s argument to explicitly specify the directory "
+                         "containing dbus/dbus-python.h.")
+        pydbusmoddir = None
+
+
+def check_module(mname, incfile, test, extra_include_dirs=None, extra_lib_dirs=None, extra_libs=None):
+    """See if a module can be built and, if so, add it to the global list of
+    modules.
+
+    mname is the name of the module.
+    incfile is the name of the include file needed for the test.
+    test is a C++ statement being used for the test.
+    extra_include_dirs is an optional list of extra include directories.
+    extra_lib_dirs is an optional list of extra library directories.
+    extra_libs is an optional list of extra libraries.
+    """
+    # Check that the module is enabled if we are not automatically enabling all
+    # modules.
+    if len(opts.enabled) > 0 and mname not in opts.enabled:
+        return
+
+    # Check the module's main .sip file exists.
+    if os.access(os.path.join(src_dir, "sip", mname, mname + "mod.sip"), os.F_OK):
+        sipconfig.inform("Checking to see if the %s module should be built..." % mname)
+
+        if check_api(incfile, test, mname, extra_include_dirs=extra_include_dirs, extra_lib_dirs=extra_lib_dirs, extra_libs=extra_libs):
+            pyqt_modules.append(mname)
+
+
+def check_api(incfile, test, mname, extra_include_dirs=None, extra_lib_dirs=None, extra_libs=None):
+    """Return non-zero if a class is available.
+
+    incfile is the name of the include file needed for the test.
+    test is a C++ statement being used for the test.
+    mname is the name of the module.
+    extra_include_dirs is an optional list of extra include directories.
+    extra_lib_dirs is an optional list of extra library directories.
+    extra_libs is an optional list of extra libraries.
+    """
+    # We use a module specific name to avoid a potential problem on Windows
+    # where the operating system doesn't delete previous tests quickly enough.
+    cfgtest = "cfgtest_%s.cpp" % mname
+
+    f = open(cfgtest, "w")
+
+    f.write("""#include <%s>
+
+int main(int, char **)
+{
+    %s;
+}
+""" % (incfile, test))
+
+    f.close()
+
+    return compile_qt_program(cfgtest, mname,
+            extra_include_dirs=extra_include_dirs,
+            extra_lib_dirs=extra_lib_dirs, extra_libs=extra_libs,
+            library=True)
+
+
+def set_sip_flags(pyqt):
+    """Set the SIP platform, version and feature flags.
+
+    pyqt is the configuration instance.
+    """
+    cfg = cross_sipcfg or sipcfg
+    # If we don't check for signed interpreters, we exclude the 'VendorID'
+    # feature
+    if not opts.vendorcheck:
+        qt_sip_flags.append("-x")
+        qt_sip_flags.append("VendorID")
+
+    # Handle the platform tag.
+    if sys.platform == 'win32':
+        plattag = "WS_WIN"
+    elif sys.platform == "darwin":
+        if "__USE_WS_X11__" in cfg.build_macros()["DEFINES"]:
+            plattag = "WS_X11"
+        else:
+            plattag = "WS_MACX"
+    elif cross_sipcfg:
+        plattag = "WS_QWS"
+    else:
+        plattag = "WS_QWS" #X11"
+
+    qt_sip_flags.append("-t")
+    qt_sip_flags.append(plattag)
+
+    # Handle the Qt version tag.
+    verstag = cross_sipconfig.version_to_sip_tag(qt_version, pyqt.qt_version_tags(), "Qt")
+
+    # Handle any feature flags.
+    for xf in qt_xfeatures:
+        qt_sip_flags.append("-x")
+        qt_sip_flags.append(xf)
+
+    if verstag:
+        qt_sip_flags.append("-t")
+        qt_sip_flags.append(verstag)
+
+    # Handle the version specific Python features.
+    if cfg.py_version < 0x020400:
+        qt_sip_flags.append("-x")
+        qt_sip_flags.append("Py_DateTime")
+
+    if cfg.py_version < 0x030000:
+        qt_sip_flags.append("-x")
+        qt_sip_flags.append("Py_v3")
+
+    # There is an issue creating QObjects while the GIL is held causing
+    # deadlocks in multi-threaded applications.  We don't fully understand this
+    # yet so we make sure we avoid the problem by always releasing the GIL.
+    qt_sip_flags.append("-g")
+
+
+def needed_qt_libs(mname, qt_libs):
+    """Add any additional Qt libraries needed by a module to an existing list.
+
+    mname is the name of the module.
+    qt_libs is the current list of libraries.
+    """
+
+    # The dependencies between the different Qt libraries.  The order within
+    # each list is important.  Note that this affects the include directories
+    # as well as the libraries.
+    ### Note that the dependency on QtNetwork is only there on Embedded Linux.
+    LIB_DEPS = {
+        "QtCore": [],
+        "QtDBus": ["QtCore"],
+        "QtDeclarative": ["QtNetwork", "QtGui"],
+        "QtGui": ["QtCore", "QtNetwork"],
+        "QtHelp": ["QtGui"],
+        "QtMultimedia": ["QtGui"],
+        "QtNetwork": ["QtCore"],
+        "QtOpenGL": ["QtGui"],
+        "QtScript": ["QtCore"],
+        "QtScriptTools": ["QtScript", "QtGui", "QtCore"],
+        "QtSql": ["QtGui"],
+        "QtSvg": ["QtGui"],
+        "QtTest": ["QtGui"],
+        "QtWebKit": ["QtNetwork", "QtGui"],
+        "QtXml": ["QtCore"],
+        "QtXmlPatterns": ["QtNetwork", "QtCore"],
+        "phonon": ["QtGui"],
+        "QtAssistant": ["QtNetwork", "QtGui"],
+        "QtDesigner": ["QtGui"],
+        "QAxContainer": ["QtGui"]
+    }
+
+    # Handle the dependencies first.
+    for d in LIB_DEPS[mname]:
+        needed_qt_libs(d, qt_libs)
+
+    if mname not in qt_libs:
+        qt_libs.insert(0, mname)
+
+
+def mk_clean_dir(name, clean=1):
+    """Create a clean (ie. empty) directory.
+
+    name is the name of the directory.
+    """
+    if clean:
+        try:
+            shutil.rmtree(name)
+        except:
+            pass
+
+    try:
+        os.makedirs(name)
+    except:
+        if clean:
+            sipconfig.error("Unable to create the %s directory." % name)
+
+
+def generate_code(mname, extra_include_dirs=None, extra_lib_dirs=None, extra_libs=None, extra_sip_flags=None):
+    """Generate the code for a module.
+
+    mname is the name of the module to generate the code for.
+    extra_include_dirs is an optional list of additional directories to add to
+    the list of include directories.
+    extra_lib_dirs is an optional list of additional directories to add to the
+    list of library directories.
+    extra_libs is an optional list of additional libraries to add to the list
+    of libraries.
+    extra_sip_flags is an optional list of additional flags to pass to SIP.
+    """
+    sipconfig.inform("Generating the C++ source for the %s module..." % mname)
+
+    mk_clean_dir(mname)
+
+    # Work out what Qt libraries need to be linked against and how SIP is
+    # supposed to handle the consolidated module and its components.
+    cons_args = []
+
+    if opts.bigqt:
+        if mname == "_qt":
+            qt_libs = []
+
+            for m in pyqt_modules:
+                needed_qt_libs(m, qt_libs)
+        else:
+            if mname != "Qt":
+                cons_args.append("-p")
+                cons_args.append("PyQt4._qt")
+
+            qt_libs = 0
+    else:
+        if mname == "Qt":
+            qt_libs = 0
+        else:
+            qt_libs = []
+            needed_qt_libs(mname, qt_libs)
+
+    # Build the SIP command line.
+    argv = ['"' + sipcfg.sip_bin + '"', '-w']
+
+    if opts.no_timestamp:
+        argv.append("-T")
+
+    if not opts.no_docstrings:
+        argv.append("-o");
+
+    if opts.prot_is_public:
+        argv.append("-P");
+
+    argv.extend(qt_sip_flags)
+    argv.extend(cons_args)
+
+    if extra_sip_flags:
+        argv.extend(extra_sip_flags)
+
+    if opts.concat:
+        argv.append("-j")
+        argv.append(str(opts.split))
+
+    if opts.tracing:
+        argv.append("-r")
+
+    if mname not in ("Qt", "_qt", "Qsci"):
+        argv.append("-a")
+        argv.append(mname + ".api")
+
+    # Pass the absolute pathname so that #line files are absolute.
+    argv.append("-c")
+    argv.append(os.path.abspath(mname))
+
+    buildfile = os.path.join(mname, mname + ".sbf")
+    argv.append("-b")
+    argv.append(buildfile)
+
+    argv.append("-I")
+    argv.append(os.path.join(src_dir, "sip"))
+
+    # Add the name of the .sip file keeping in mind SIP assumes POSIX style
+    # path separators.  The Qt module's .sip file is generated by this script
+    # and so will be in a different place if this is an out-of-tree build.
+    if mname == "Qt":
+        argv.append("sip/Qt/Qtmod.sip")
+    else:
+        drive, path = os.path.splitdrive(src_dir)
+        parts = path.split(os.pathsep)
+        parts.extend(["sip", mname, mname + "mod.sip"])
+        argv.append(drive + "/".join(parts))
+
+    cmd = " ".join(argv)
+
+    if opts.verbose:
+        sys.stdout.write(cmd + "\n")
+
+    os.system(cmd)
+
+    # Check the result.
+    if not os.access(buildfile, os.F_OK):
+        sipconfig.error("Unable to create the C++ code.")
+
+    # Generate the Makefile.
+    sipconfig.inform("Creating the Makefile for the %s module..." % mname)
+
+    installs = []
+
+    if opts.install_sipfiles:
+        sipfiles = []
+
+        sipdir = os.path.join("sip", mname)
+        if mname != "Qt":
+            sipdir = os.path.join(src_dir, sipdir)
+            rel_sipdir = sipdir
+        else:
+            rel_sipdir = os.path.join("..", sipdir)
+
+        for s in glob.glob(os.path.join(sipdir, "*.sip")):
+            sipfiles.append(os.path.join(rel_sipdir, os.path.basename(s)))
+
+        installs.append([sipfiles, os.path.join(opts.pyqtsipdir, mname)])
+
+    opengl = (mname == "QtOpenGL")
+    cfg = cross_sipcfg or sipcfg
+
+    makefile = cross_sipconfig.SIPModuleMakefile(
+        configuration=cfg,
+        build_file=mname + ".sbf",
+        dir=mname,
+        install_dir=pyqt_modroot,
+        installs=installs,
+        qt=qt_libs,
+        opengl=opengl,
+        warnings=1,
+        static=opts.static,
+        debug=opts.debug,
+        universal=cfg.universal,
+        arch=cfg.arch,
+        prot_is_public=opts.prot_is_public,
+        deployment_target=cfg.deployment_target
+    )
+
+    add_makefile_extras(makefile, extra_include_dirs, extra_lib_dirs, extra_libs)
+
+    makefile.generate()
+
+
+def fix_license(name):
+    """ Fix the license file, if there is one, so that it conforms to the SIP
+    v5 syntax.
+    """
+
+    try:
+        f = open(name, "r")
+    except IOError:
+        sipconfig.error("Failed to open license file %s." % name)
+
+    f5 = open(name + "5", "w")
+
+    for line in f:
+        if line.startswith("%License"):
+            anno_start = line.find("/")
+            anno_end = line.rfind("/")
+
+            if anno_start < 0 or anno_end < 0 or anno_start == anno_end:
+                sipconfig.error("%s has missing annotations." % name)
+
+            annos = line[anno_start + 1:anno_end].split(", ")
+            annos5 = [anno[0].lower() + anno[1:] for anno in annos]
+
+            f5.write("%License(")
+            f5.write(", ".join(annos5))
+            f5.write(")\n")
+        else:
+            f5.write(line)
+
+    f5.close()
+    f.close()
+
+
+def check_license():
+    """Handle the validation of the PyQt license.
+    """
+    try:
+        import license
+        ltype = license.LicenseType
+        lname = license.LicenseName
+
+        try:
+            lfile = license.LicenseFile
+        except AttributeError:
+            lfile = None
+    except ImportError:
+        ltype = None
+
+    if ltype is None:
+        ltype = "GPL"
+        lname = "GNU General Public License"
+        lfile = "pyqt-gpl.sip"
+
+    sipconfig.inform("This is the %s version of PyQt %s (licensed under the %s) for Python %s on %s." % (ltype, pyqt_version_str, lname, sys.version.split()[0], sys.platform))
+
+    # Common checks.
+    if qt_licensee and ltype == "GPL":
+        sipconfig.error("This version of PyQt and the commercial version of Qt have incompatible licenses.")
+
+    # Confirm the license if not already done.
+    if not opts.license_confirmed:
+        if ltype == "GPL":
+            loptions = """
+Type '2' to view the GPL v2 license.
+Type '3' to view the GPL v3 license.
+"""
+        else:
+            loptions = """
+Type 'L' to view the license.
+"""
+
+        sys.stdout.write(loptions)
+        sys.stdout.write("""Type 'yes' to accept the terms of the license.
+Type 'no' to decline the terms of the license.
+
+""")
+
+        while 1:
+            sys.stdout.write("Do you accept the terms of the license? ")
+            sys.stdout.flush()
+
+            try:
+                resp = sys.stdin.readline()
+            except KeyboardInterrupt:
+                raise SystemExit
+            except:
+                resp = ""
+
+            resp = resp.strip().lower()
+
+            if resp == "yes":
+                break
+
+            if resp == "no":
+                sys.exit(0)
+
+            if ltype == "GPL":
+                if resp == "2":
+                    os.system("more LICENSE.GPL2")
+                elif resp == "3":
+                    os.system("more LICENSE.GPL3")
+            else:
+                if resp == "l":
+                    os.system("more LICENSE")
+
+    # Check that the license file exists and fix its syntax.
+    lfile_path = os.path.join(src_dir, "sip", lfile)
+
+    if os.access(lfile_path, os.F_OK):
+        sipconfig.inform("Found the license file %s." % lfile)
+        fix_license(lfile_path)
+    else:
+        sipconfig.error("Please copy the license file %s to the sip directory." % lfile)
+
+
+def get_build_macros(overrides):
+    """Return the dictionary of platform specific build macros from the Qt
+    installation.  Return None if any of the overrides was invalid.
+
+    overrides is a list of macros overrides from the user.
+    """
+    global qt_macx_spec
+
+    # Get the name of the qmake configuration file to take the macros from.
+    if "QMAKESPEC" in list(os.environ.keys()):
+        fname = os.environ["QMAKESPEC"]
+
+        if not os.path.dirname(fname):
+            qt_macx_spec = fname
+            fname = os.path.join(qt_datadir, "mkspecs", fname)
+    elif sys.platform == "darwin":
+        # The Qt Mac binary installer defaults to xcode which we don't want.
+        # Use Qt5's macx-clang if it is available, otherwise fall back to
+        # macx-g++.
+        fname = os.path.join(qt_datadir, "mkspecs", "macx-clang")
+        if os.path.isdir(fname):
+            qt_macx_spec = "macx-clang"
+        else:
+            fname = os.path.join(qt_datadir, "mkspecs", "macx-g++")
+            qt_macx_spec = "macx-g++"
+    else:
+        fname = os.path.join(qt_datadir, "mkspecs", "default")
+
+    fname = os.path.join(fname, "qmake.conf")
+
+    if not os.access(fname, os.F_OK):
+        sipconfig.error("Unable to find the qmake configuration file %s. Use the QMAKESPEC environment variable to specify the correct platform." % fname)
+
+    # Add the Qt specific macros to the default.
+    cfg = cross_sipcfg or sipcfg
+    names = list(cfg.build_macros().keys())
+    names.append("INCDIR_QT")
+    names.append("LIBDIR_QT")
+    names.append("MOC")
+
+    properties = {
+        "QT_INSTALL_BINS":      qt_bindir,
+        "QT_INSTALL_HEADERS":   qt_incdir,
+        "QT_INSTALL_LIBS":      qt_libdir
+    }
+
+    macros = cross_sipconfig.parse_build_macros(fname, names, overrides, properties)
+
+    if macros is None:
+        return None
+
+    # Make sure we have an entry for MOC (which Qt v5 doesn't provide).
+    if macros.get("MOC", "") == "":
+        default_moc = os.path.join(qt_bindir, "moc")
+        if sys.platform == 'win32':
+            default_moc += ".exe"
+
+        macros["MOC"] = default_moc
+
+    return macros
+
+
+def check_qt_installation(macros):
+    """Check the Qt installation and get the version number and edition and
+    return the configuration instance.
+
+    macros is the dictionary of build macros.
+    """
+    # Check the Qt version number.
+    if qt_version < 0x040100:
+        sipconfig.error("PyQt v4 requires Qt v4.1.0 or later.")
+
+    # Starting with v4.7, Qt (when built with MinGW) assumes that stack frames
+    # are 16 byte aligned because it uses SSE.  However the Python Windows
+    # installers are built with 4 byte aligned stack frames.  We therefore need
+    # to tweak the g++ flags to deal with it.
+    if sipcfg.platform == 'win32-g++' and qt_version >= 0x040700:
+        macros['CFLAGS'] += ' -mstackrealign'
+        macros['CXXFLAGS'] += ' -mstackrealign'
+
+    # Work out how Qt was built on MacOS.
+    if sys.platform == "darwin":
+        if os.access(os.path.join(qt_libdir, "QtCore.framework"), os.F_OK):
+            global qt_framework
+            qt_framework = 1
+
+    # Get the Makefile generator.
+    generator = macros["MAKEFILE_GENERATOR"]
+
+    if cross_sipconfig:
+        macros["CXXFLAGS"] += ' -fPIC -fpermissive '
+        macros["LFLAGS_PLUGIN"] += " -Wl,-rpath="+qt_libdir+" "
+
+    # We haven't yet factored out sipconfig's knowledge of how to build Qt
+    # binaries and it is expecting to find these in the configuration when it
+    # generates the Makefiles.
+    cfg = cross_sipcfg or sipcfg
+    cfg.qt_version = qt_version
+    cfg.qt_edition = qt_edition
+    cfg.qt_winconfig = qt_shared
+    cfg.qt_framework = qt_framework
+    cfg.qt_threaded = 1
+    cfg.qt_dir = qt_dir
+    cfg.qt_lib_dir = qt_libdir
+
+    return ConfigurePyQt4(generator)
+
+
+def fix_qmake_args(args=""):
+    """Make any platform specific adjustments to the arguments passed to qmake.
+    """
+    if sys.platform == "darwin":
+        # The Qt binary installer has macx-xcode as the default.
+        args = "-spec %s %s" % (qt_macx_spec, args)
+
+    return args
+
+
+def get_qt_configuration():
+    """Set the qt_dir, qt_incdir, qt_libdir, qt_bindir, qt_datadir,
+    qt_pluginsdir and qt_xfeatures globals for the Qt installation.
+    """
+    sipconfig.inform("Determining the layout of your Qt installation...")
+
+    # The file names we will use to get the directory information.
+    app = "qtdirs"
+    pro_file = app + ".pro"
+    make_file = app + ".mk"
+    make_target = ""
+    cpp_file = app + ".cpp"
+    out_file = app + ".out"
+    qmake_args = fix_qmake_args("-o " + make_file)
+
+    if sys.platform == 'win32':
+        if opts.debug:
+            exe_file = os.path.join("debug", app + ".exe")
+            make_target = " debug"
+        else:
+            exe_file = os.path.join("release", app + ".exe")
+            make_target = " release"
+    elif sys.platform == "darwin":
+        exe_file = os.path.join(app + ".app", "Contents", "MacOS", app)
+    else:
+        exe_file = os.path.join(".", app)
+
+    # Generate the qmake project file.
+    f = open(pro_file, "w")
+
+    cfg = cross_sipcfg or sipcfg
+    if cfg.arch:
+        f.write(arch_config(cfg))
+
+    f.write(
+"""QT = core
+# This is for certain broken Linux distros and is needed to make sure that
+# QT_SHARED is properly defined.
+CONFIG += link_prl
+TARGET = %s
+SOURCES = %s
+""" % (app, cpp_file))
+
+    f.close()
+
+    # Generate the source code.
+    f = open(cpp_file, "w")
+
+    ### This code is never run when we make libraries for QWS, so we don't
+    ### have to keep the list of checks for Qt features up to date.
+
+    f.write(
+"""#include <QCoreApplication>
+#include <QFile>
+#include <QLibraryInfo>
+#include <QTextStream>
+
+// This seems to be missing from the Qt v5 alpha.
+#if !defined(QT_EDITION_OPENSOURCE)
+#define QT_EDITION_OPENSOURCE   8
+#endif
+
+int main(int argc, char **argv)
+{
+    QCoreApplication app(argc, argv);
+    QFile outf("%s");
+
+    if (!outf.open(QIODevice::WriteOnly|QIODevice::Truncate|QIODevice::Text))
+        return 1;
+
+    QTextStream out(&outf);
+
+    out << QLibraryInfo::location(QLibraryInfo::PrefixPath) << '\\n';
+    out << QLibraryInfo::location(QLibraryInfo::HeadersPath) << '\\n';
+    out << QLibraryInfo::location(QLibraryInfo::LibrariesPath) << '\\n';
+    out << QLibraryInfo::location(QLibraryInfo::BinariesPath) << '\\n';
+    out << QLibraryInfo::location(QLibraryInfo::DataPath) << '\\n';
+    out << QLibraryInfo::location(QLibraryInfo::PluginsPath) << '\\n';
+
+    out << QT_VERSION << '\\n';
+    out << QT_EDITION << '\\n';
+
+    out << QLibraryInfo::licensee() << '\\n';
+
+#if defined(QT_SHARED) || defined(QT_DLL)
+    out << "shared\\n";
+#else
+    out << "\\n";
+#endif
+
+    // Determine which features should be disabled.
+
+#if defined(QT_NO_RAW_FONT)
+    out << "PyQt_RawFont\\n";
+#endif
+
+#if defined(QT_NO_ACCESSIBILITY)
+    out << "PyQt_Accessibility\\n";
+#endif
+
+#if defined(QT_NO_SESSIONMANAGER)
+    out << "PyQt_SessionManager\\n";
+#endif
+
+#if defined(QT_NO_STATUSTIP)
+    out << "PyQt_StatusTip\\n";
+#endif
+
+#if defined(QT_NO_TOOLTIP)
+    out << "PyQt_ToolTip\\n";
+#endif
+
+#if defined(QT_NO_WHATSTHIS)
+    out << "PyQt_WhatsThis\\n";
+#endif
+
+#if defined(QT_NO_OPENSSL)
+    out << "PyQt_OpenSSL\\n";
+#endif
+
+#if defined(QT_NO_PICTURE)
+    out << "PyQt_Picture\\n";
+#endif
+
+#if defined(QT_NO_PRINTDIALOG)
+    out << "PyQt_PrintDialog\\n";
+#endif
+
+#if defined(QT_NO_PRINTPREVIEWDIALOG)
+    out << "PyQt_PrintPreviewDialog\\n";
+#endif
+
+#if defined(QT_NO_PRINTPREVIEWWIDGET)
+    out << "PyQt_PrintPreviewWidget\\n";
+#endif
+
+#if defined(QT_NO_PRINTER)
+    out << "PyQt_Printer\\n";
+#endif
+
+#if defined(QT_NO_PROGRESSDIALOG)
+    out << "PyQt_ProgressDialog\\n";
+#endif
+
+#if defined(QT_NO_PROXYMODEL)
+    out << "PyQt_ProxyModel\\n";
+#endif
+
+#if defined(QT_NO_RUBBERBAND)
+    out << "PyQt_RubberBand\\n";
+#endif
+
+#if defined(QT_NO_PROCESS)
+    out << "PyQt_Process\\n";
+#endif
+
+#if defined(QT_NO_QWS_ALPHA_CURSOR)
+    out << "PyQt_QWS_Alpha_Cursor\\n";
+#endif
+
+#if defined(QT_NO_QWS_CURSOR)
+    out << "PyQt_QWS_Cursor\\n";
+#endif
+
+#if defined(QT_NO_QWS_DECORATION_WINDOWS)
+    out << "PyQt_QWS_Decoration_Windows\\n";
+#endif
+
+#if defined(QT_NO_QWS_MOUSE)
+    out << "PyQt_QWS_Mouse\\n";
+#endif
+
+#if defined(QT_NO_QWS_MOUSE_AUTO)
+    out << "PyQt_QWS_Mouse_Auto\\n";
+#endif
+
+#if defined(QT_NO_QWS_MOUSE_MANUAL)
+    out << "PyQt_QWS_Mouse_Manual\\n";
+#endif
+
+#if defined(QT_NO_RUBBERBAND)
+    out << "PyQt_RubberBand\\n";
+#endif
+
+#if defined(QT_NO_SCROLLBAR)
+    out << "PyQt_ScrollBar\\n";
+#endif
+
+#if defined(QT_NO_SESSIONMANAGER)
+    out << "PyQt_SessionManager\\n";
+#endif
+
+#if defined(QT_NO_SIZEGRIP)
+    out << "PyQt_SizeGrip\\n";
+#endif
+
+#if defined(QT_NO_SOCKS5)
+    out << "PyQt_Socks5\\n";
+#endif
+
+#if defined(QT_NO_SORTFILTERPROXYMODEL)
+    out << "PyQt_SortFilterProxyModel\\n";
+#endif
+
+#if defined(QT_NO_SPLASHSCREEN)
+    out << "PyQt_SplashScreen\\n";
+#endif
+
+#if defined(QT_NO_SPLITTER)
+    out << "PyQt_Splitter\\n";
+#endif
+
+#if defined(QT_NO_STANDARDITEMMODEL)
+    out << "PyQt_StandardItemModel\\n";
+#endif
+
+#if defined(QT_NO_STATUSBAR)
+    out << "PyQt_StatusBar\\n";
+#endif
+
+#if defined(QT_NO_STATUSTIP)
+    out << "PyQt_StatusTip\\n";
+#endif
+
+#if defined(QT_NO_STRINGLISTMODEL)
+    out << "PyQt_StringListModel\\n";
+#endif
+
+#if defined(QT_NO_STYLE_CDE)
+    out << "PyQt_Style_CDE\\n";
+#endif
+
+#if defined(QT_NO_STYLE_MOTIF)
+    out << "PyQt_Style_Motif\\n";
+#endif
+
+#if defined(QT_NO_STYLE_PLASTIQUE)
+    out << "PyQt_Style_Plastique\\n";
+#endif
+
+#if defined(QT_NO_STYLE_WINDOWSXP)
+    out << "PyQt_Style_WindowsXP\\n";
+#endif
+
+#if defined(QT_NO_SYNTAXHIGHLIGHTER)
+    out << "PyQt_SyntaxHighlighter\\n";
+#endif
+
+#if defined(QT_NO_SYSTEMTRAYICON)
+    out << "PyQt_SystemTrayIcon\\n";
+#endif
+
+#if defined(QT_NO_PRINTDIALOG)
+    out << "PyQt_PrintDialog\\n";
+#endif
+
+#if defined(QT_NO_PRINTER)
+    out << "PyQt_Printer\\n";
+#endif
+
+#if defined(QT_NO_PRINTPREVIEWDIALOG)
+    out << "PyQt_PrintPreviewDialog\\n";
+#endif
+
+#if defined(QT_NO_PRINTPREVIEWWIDGET)
+    out << "PyQt_PrintPreviewWidget\\n";
+#endif
+
+#if !defined(QT3_SUPPORT) || QT_VERSION >= 0x040200
+    out << "PyQt_NoPrintRangeBug\\n";
+#endif
+
+#if defined(QT_OPENGL_ES)
+    out << "PyQt_NoOpenGLES\\n";
+#endif
+
+#if defined(QT_NO_FPU) || defined(QT_ARCH_ARM) || defined(QT_ARCH_WINDOWSCE)
+        out << "PyQt_qreal_double\\n";
+#endif
+
+    return 0;
+}
+""" % out_file)
+
+    f.close()
+
+    # Create the makefile, first making sure it doesn't already exist.
+    #remove_file(make_file)
+    #run_command("%s %s %s" % (opts.qmake, qmake_args, pro_file))
+
+    #if not os.access(make_file, os.F_OK):
+    #    sipconfig.error("%s failed to create a makefile. %s" % (opts.qmake, MSG_CHECK_QMAKE))
+
+    # Try and work out the name of make.
+    #if sipcfg.platform.startswith("win32-msvc"):
+    #    make = "nmake"
+    #elif sipcfg.platform == "win32-borland":
+    #    make = "bmake"
+    #elif sipcfg.platform == "win32-g++":
+    #    make = "mingw32-make"
+    #else:
+    #    make = "make"
+
+    # Create the executable, first making sure it doesn't exist.
+    #remove_file(exe_file)
+    #run_command("%s -f %s%s" % (make, make_file, make_target))
+
+    #if not os.access(exe_file, os.X_OK):
+    #    sipconfig.error("Failed to determine the layout of your Qt installation. Try again using the --verbose flag to see more detail about the problem.")
+
+    # Create the output file, first making sure it doesn't exist.
+    #remove_file(out_file)
+    #run_command(exe_file)
+
+    if not os.access(out_file, os.F_OK):
+        sipconfig.error("%s failed to create %s. Make sure your Qt v4 installation is correct." % (exe_file, out_file))
+
+    # Read the directories.
+    f = open(out_file, "r")
+    lines = f.read().strip().split("\n")
+    f.close()
+
+    global qt_dir, qt_incdir, qt_libdir, qt_bindir, qt_datadir, qt_pluginsdir
+    global qt_version, qt_edition, qt_licensee, qt_shared, qt_xfeatures
+
+    qt_dir = lines[0]
+    qt_incdir = lines[1]
+    qt_libdir = lines[2]
+    qt_bindir = lines[3]
+    qt_datadir = lines[4]
+    qt_pluginsdir = lines[5]
+    qt_version = lines[6]
+    qt_edition = lines[7]
+    qt_licensee = lines[8]
+    qt_shared = lines[9]
+    qt_xfeatures = lines[10:]
+
+    if opts.assume_shared:
+        qt_shared = "shared"
+
+    # 'Nokia' is the value that is used by Maemo's version of Qt.
+    if qt_licensee in ('Open Source', 'Nokia'):
+        qt_licensee = None
+
+    try:
+        qt_version = int(qt_version)
+    except ValueError:
+        sipconfig.error("QT_VERSION should be a number but \"%s\" was found." % qt_version)
+
+    try:
+        qt_edition = int(qt_edition)
+    except ValueError:
+        sipconfig.error("QT_EDITION should be a number but \"%s\" was found." % qt_edition)
+
+    # Now convert the edition to a descriptive string.  The order of testing is
+    # important.
+    if qt_edition & 0x200:
+        # It has ActiveQt.
+        qt_edition = "Desktop"
+
+        # ActiveQt became part of the open source version in v4.5.2.
+        if qt_version >= 0x040502 and qt_licensee is None:
+            qt_edition = "free"
+    elif qt_edition & 0x008:
+        # It has OpenGL.
+        qt_edition = "free"
+    elif qt_edition & 0x002:
+        # It has GUI.
+        qt_edition = "Desktop Light"
+    else:
+        qt_edition = "Console"
+
+    if qt_shared:
+        if opts.staticplugins:
+            sipconfig.inform("Static plugins are disabled because Qt has been built as shared libraries.")
+            opts.staticplugins = []
+    else:
+        if opts.static or opts.bigqt:
+            pass
+        else:
+            sipconfig.error("Qt has been built as static libraries so either the -g or -k argument should be used.")
+
+
+def main():
+    """Create the configuration module module.
+    """
+    # Check SIP is new enough.
+    if sipcfg.sip_version < sip_min_version:
+        sipconfig.error("This version of PyQt requires SIP v%s or later" % sipconfig.version_to_string(sip_min_version))
+
+    global opts
+
+    cross_path = os.getenv("CROSS_SIPCONFIG")
+    global cross_sipcfg, cross_sipconfig
+    if cross_path:
+        import imp
+        c_file, c_filename, c_details = imp.find_module("sipconfig", [cross_path])
+        cross_sipconfig = imp.load_module("cross_sipconfig", c_file, c_filename, c_details)
+        cross_sipcfg = cross_sipconfig.Configuration()
+    else:
+        cross_sipcfg = None
+    
+    # Parse the command line.
+    p = create_optparser()
+    opts, args = p.parse_args()
+
+    # Provide defaults for platform-specific options.
+    if sys.platform == 'win32':
+        opts.qmake = find_default_qmake()
+        opts.prot_is_public = False
+
+    if not opts.qmake:
+        sipconfig.error(MSG_CHECK_QMAKE)
+
+    # Where the modules will be placed.
+    global pyqt_modroot
+    pyqt_modroot = os.path.join(opts.pyqtmoddir, "PyQt4")
+
+    # When building static libraries, signed interpreter checking makes no
+    # sense.
+    if opts.vendorcheck and opts.static:
+        sipconfig.error("Using the VendorID package when building static libraries makes no sense.")
+
+    # Get the details of the Qt installation.
+    get_qt_configuration()
+
+    # Provide some defaults that are based on the Qt configuration.
+    if not opts.plugindir:
+        opts.plugindir = qt_pluginsdir
+
+    if opts.qscidir:
+        # An explicit directory implies installing the API file.
+        opts.api = True
+    else:
+        opts.qscidir = os.path.join(qt_datadir, "qsci")
+
+        if opts.api is None:
+            # Install the API file if the default directory exists.
+            opts.api = os.path.isdir(opts.qscidir)
+
+    # Replace the existing build macros with the ones from the Qt installation.
+    macros = get_build_macros(args)
+
+    if macros is None:
+        p.print_help()
+        sys.exit(2)
+
+    cfg = cross_sipcfg or sipcfg
+    if cross_sipcfg:
+        old_macros = cfg.build_macros()
+        macros.update(old_macros)
+    cfg.set_build_macros(macros)
+
+    # Check Qt is what we need.
+    pyqt = check_qt_installation(macros)
+
+    # Check the licenses are compatible.
+    check_license()
+
+    # Check which modules to build.
+    pyqt.check_modules()
+
+    # Check for the VendorID package.
+    check_vendorid()
+
+    # Set the SIP platform, version and feature flags.
+    set_sip_flags(pyqt)
+
+    # Tell the user what's been found.
+    inform_user()
+
+    # Generate the code.
+    pyqt.code()
+
+    # Create the additional Makefiles.
+    sipconfig.inform("Creating top level Makefile...")
+
+    installs=[(pyqt.module_installs(), pyqt_modroot)]
+
+    if opts.api:
+        installs.append(("PyQt4.api", os.path.join(opts.qscidir, "api", "python")))
+
+    xtra_modules = ["Qt"]
+
+    if opts.bigqt:
+        xtra_modules.append("_qt")
+
+        if opts.mwg_qsci_dir:
+            xtra_modules.append("Qsci")
+
+        if opts.mwg_qwt_dir:
+            xtra_modules.append("Qwt5")
+
+    cross_sipconfig.ParentMakefile(
+        configuration=cfg,
+        subdirs=pyqt.qpy_libs() + pyqt_modules + xtra_modules + pyqt.tools(),
+        installs=installs
+    ).generate()
+
+    # Install the configuration module.
+    create_config("pyqtconfig.py", os.path.join(src_dir, "pyqtconfig.py.in"),
+            macros)
+
+
+###############################################################################
+# The script starts here.
+###############################################################################
+
+if __name__ == "__main__":
+
+    print sipconfig._pkg_config
+
+    try:
+        main()
+    except SystemExit:
+        raise
+    except:
+        sys.stderr.write(
+"""An internal error occured.  Please report all the output from the program,
+including the following traceback, to support@riverbankcomputing.com.
+""")
+        raise
diff --git a/package/pyqt/configure.py b/package/pyqt/configure.py
new file mode 100644
index 0000000..0f208aa
--- /dev/null
+++ b/package/pyqt/configure.py
@@ -0,0 +1,2394 @@
+# This script generates the PyQt configuration and generates the Makefiles.
+#
+# Copyright (c) 2012 Riverbank Computing Limited <info@riverbankcomputing.com>
+# 
+# This file is part of PyQt.
+# 
+# This file may be used under the terms of the GNU General Public
+# License versions 2.0 or 3.0 as published by the Free Software
+# Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
+# included in the packaging of this file.  Alternatively you may (at
+# your option) use any later version of the GNU General Public
+# License if such license has been publicly approved by Riverbank
+# Computing Limited (or its successors, if any) and the KDE Free Qt
+# Foundation. In addition, as a special exception, Riverbank gives you
+# certain additional rights. These rights are described in the Riverbank
+# GPL Exception version 1.1, which can be found in the file
+# GPL_EXCEPTION.txt in this package.
+# 
+# If you are unsure which license is appropriate for your use, please
+# contact the sales department at sales@riverbankcomputing.com.
+# 
+# This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+# WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+
+
+import sys
+import os
+import glob
+import optparse
+import shutil
+
+import sipconfig
+
+
+# Initialise the globals.
+pyqt_version = 0x040906
+pyqt_version_str = "4.9.6"
+
+sip_min_version = 0x040e02
+
+qt_version = 0
+qt_edition = ""
+qt_licensee = None
+qt_dir = None
+qt_incdir = None
+qt_libdir = None
+qt_bindir = None
+qt_datadir = None
+qt_pluginsdir = None
+qt_xfeatures = None
+qt_shared = ""
+qt_framework = 0
+
+# This default value will be used by the code that bootstraps the Qt
+# configuration.
+qt_macx_spec = 'macx-g++'
+
+qt_sip_flags = []
+
+pyqt_modules = []
+pyqt_modroot = None
+src_dir = os.path.dirname(os.path.abspath(__file__))
+
+# Get the SIP configuration.
+sipcfg = sipconfig.Configuration()
+
+pydbusmoddir = None
+dbusincdirs = []
+dbuslibdirs = []
+dbuslibs = []
+
+
+# Under Windows qmake and the Qt DLLs must be on the system PATH otherwise the
+# dynamic linker won't be able to resolve the symbols.  On other systems we
+# assume we can just run qmake by using its full pathname.
+if sys.platform == 'win32':
+    MSG_CHECK_QMAKE = "Make sure you have a working Qt qmake on your PATH."
+else:
+    MSG_CHECK_QMAKE = "Make sure you have a working Qt qmake on your PATH or use the -q argument to explicitly specify a working Qt qmake."
+
+
+def find_default_qmake():
+    """Find a default qmake, ie. the first on the path.
+    """
+    try:
+        path = os.environ["PATH"]
+    except KeyError:
+        path = ""
+
+    if sys.platform == 'win32':
+        base_qmake = "qmake.exe"
+    else:
+        base_qmake = "qmake"
+
+    for d in path.split(os.pathsep):
+        qmake = os.path.join(d, base_qmake)
+  
+        if os.access(qmake, os.X_OK):
+            return qmake
+
+    return ""
+
+
+def create_optparser():
+    """Create the parser for the command line.
+    """
+    qmake = find_default_qmake()
+
+    def store_abspath(option, opt_str, value, parser):
+        setattr(parser.values, option.dest, os.path.abspath(value))
+
+    def store_abspath_dir(option, opt_str, value, parser):
+        if not os.path.isdir(value):
+            raise optparse.OptionValueError("'%s' is not a directory" % value)
+        setattr(parser.values, option.dest, os.path.abspath(value))
+        
+    def store_abspath_file(option, opt_str, value, parser):
+        if not os.path.isfile(value):
+            raise optparse.OptionValueError("'%s' is not a file" % value)
+        setattr(parser.values, option.dest, os.path.abspath(value))
+
+    p = optparse.OptionParser(usage="python %prog [opts] [macro=value] "
+            "[macro+=value]", version=pyqt_version_str)
+
+    # Note: we don't use %default to be compatible with Python 2.3.
+    p.add_option("-k", "--static", action="store_true", default=False,
+            dest="static", help="build modules as static libraries")
+    p.add_option("--no-docstrings", action="store_true", default=False,
+            dest="no_docstrings", help="disable the generation of docstrings")
+    p.add_option("-r", "--trace", action="store_true", default=False,
+            dest="tracing", help="build modules with tracing enabled")
+    p.add_option("-u", "--debug", action="store_true", default=False,
+            help="build modules with debugging symbols")
+    p.add_option("-w", "--verbose", action="count", default=0, dest="verbose",
+            help="verbose output during configuration")
+
+    p.add_option("-c", "--concatenate", action="store_true", default=False,
+            dest="concat", help="concatenate each module's C++ source files")
+    p.add_option("-j", "--concatenate-split", type="int", default=1,
+            metavar="N", dest="split",
+            help="split the concatenated C++ source files into N pieces "
+            "[default: 1]")
+    p.add_option("-g", "--consolidate", action="store_true", default=False,
+            dest="bigqt", help="create a single module which links against "
+            "all the Qt libraries")
+
+    # These are internal options used to build the mega Windows GPL package.
+    p.add_option("--mwg-odbc", action="store_true", default=False,
+            dest="mwg_odbc", help=optparse.SUPPRESS_HELP)
+    p.add_option("--mwg-openssl", action="callback", default=None,
+            dest="mwg_ssl_dir", metavar="DIR", callback=store_abspath_dir,
+            type="string", help=optparse.SUPPRESS_HELP)
+    p.add_option("--mwg-qsci", action="callback", default=None,
+            dest="mwg_qsci_dir", metavar="DIR", callback=store_abspath_dir,
+            type="string", help=optparse.SUPPRESS_HELP)
+    p.add_option("--mwg-qwt", action="callback", default=None,
+            dest="mwg_qwt_dir", metavar="DIR", callback=store_abspath_dir,
+            type="string", help=optparse.SUPPRESS_HELP)
+
+    # Configuration.
+    g = optparse.OptionGroup(p, title="Configuration")
+    g.add_option("--confirm-license", action="store_true", default=False,
+            dest="license_confirmed", help="confirm acceptance of the license")
+    g.add_option("-e", "--enable", action="append", default=[],
+            metavar="MODULE", dest="enabled", help="enable checks for the "
+            "specified MODULE [default: checks for all modules will be "
+            "enabled]")
+    g.add_option("--no-designer-plugin", action="store_false", default=True,
+            dest="designer_plugin", help="disable the building of the "
+            "Python plugin for Qt Designer [default: enabled]")
+    g.add_option("-t", "--plugin", action="append", default=[],
+            metavar="PLUGIN", dest="staticplugins", help="add PLUGIN to the "
+            "list be linked (if Qt is built as static libraries)")
+    g.add_option("--assume-shared", action="store_true", default=False,
+            dest="assume_shared", help="assume that the Qt libraries have "
+            "been built as shared libraries [default: check]")
+    g.add_option("-T", "--no-timestamp", action="store_true", default=False,
+            dest="no_timestamp", help="suppress timestamps in the header "
+            "comments of generated code [default: include timestamps]")
+    g.add_option("--no-deprecated", action="store_false", default=True,
+            dest="with_deprecated", help="disable Qt v4 features deprecated "
+            "in Qt v5 [default: enabled]")
+
+    if sys.platform != 'win32':
+        if sys.platform.startswith('linux') or sys.platform == 'darwin':
+            pip_default = True
+            pip_default_str = "enabled"
+        else:
+            pip_default = False
+            pip_default_str = "disabled"
+
+        g.add_option("--protected-is-public", action="store_true",
+                default=pip_default, dest="prot_is_public",
+                help="enable building with 'protected' redefined as 'public' "
+                        "[default: %s]" % pip_default_str)
+        g.add_option("--protected-not-public", action="store_false",
+                dest="prot_is_public",
+                help="disable building with 'protected' redefined as 'public'")
+        g.add_option("-q", "--qmake", action="callback", metavar="FILE",
+                default=qmake, dest="qmake", callback=store_abspath_file,
+                type="string",
+                help="the pathname of qmake [default: %s]" % (qmake or "none"))
+
+    g.add_option("-s", "--dbus", action="callback", metavar="DIR",
+            dest="pydbusincdir", callback=store_abspath_dir, type="string",
+            help="the directory containing the dbus/dbus-python.h header file "
+            "[default: supplied by pkg-config]")
+    p.add_option_group(g)
+
+    if sys.platform == 'darwin':
+        g = optparse.OptionGroup(p, title="MacOS X Configuration")
+        g.add_option("--use-arch", action="store", metavar="ARCH",
+                dest="use_arch", choices=["i386", "x86_64", "ppc"],
+                help="the architecture to use when running pyuic4 "
+                        "[default: system default]")
+        p.add_option_group(g)
+
+    # Installation.
+    g = optparse.OptionGroup(p, title="Installation")
+    g.add_option("-b", "--bindir", action="callback",
+            default=sipcfg.default_bin_dir, type="string", metavar="DIR",
+            dest="pyqtbindir", callback=store_abspath, help="where pyuic4, "
+            "pyrcc4 and pylupdate4 will be installed [default: %s]" %
+            sipcfg.default_bin_dir)
+    g.add_option("-d", "--destdir", action="callback",
+            default=sipcfg.default_mod_dir, type="string", metavar="DIR",
+            dest="pyqtmoddir", callback=store_abspath, help="where the PyQt4 "
+            "Python package will be installed [default: %s]" %
+            sipcfg.default_mod_dir)
+    g.add_option("-p", "--plugin-destdir", action="callback", type="string",
+            metavar="DIR", dest="plugindir", callback=store_abspath,
+            help="where any plugins will be installed [default: "
+            "QTDIR/plugins]")
+    g.add_option("--no-sip-files", action="store_false", default=True,
+            dest="install_sipfiles", help="disable the installation of the "
+            ".sip files [default: enabled]")
+    g.add_option("-v", "--sipdir", action="callback",
+            default=os.path.join(sipcfg.default_sip_dir, "PyQt4"),
+            metavar="DIR", dest="pyqtsipdir", callback=store_abspath,
+            type="string", help="where the PyQt4 .sip files will be installed "
+            "[default: %s]" % sipcfg.default_sip_dir)
+    p.add_option_group(g)
+
+    # Vendor ID.
+    g = optparse.OptionGroup(p, title="VendorID support")
+    g.add_option("-i", "--vendorid", action="store_true", default=False,
+            dest="vendorcheck", help="enable checking of signed interpreters "
+            "using the VendorID package [default: disabled]")
+    g.add_option("-l", "--vendorid-incdir", action="callback",
+            default=sipcfg.py_inc_dir, type="string", metavar="DIR",
+            dest="vendincdir", callback=store_abspath_dir, help="the "
+            "directory containing the VendorID header file [default: %s]" %
+            sipcfg.py_inc_dir)
+    g.add_option("-m", "--vendorid-libdir", action="callback",
+            default=sipcfg.py_lib_dir, type="string", metavar="DIR",
+            dest="vendlibdir", callback=store_abspath_dir, help="the "
+            "directory containing the VendorID library [default: %s]" %
+            sipcfg.py_lib_dir)
+    p.add_option_group(g)
+
+    # QScintilla.
+    g = optparse.OptionGroup(p, title="QScintilla support")
+    g.add_option("-a", "--qsci-api", action="store_true", default=None,
+            dest="api", help="always install the PyQt API file for QScintilla "
+            "[default: install only if QScintilla installed]")
+    g.add_option("--no-qsci-api", action="store_false", default=None,
+            dest="api", help="do not install the PyQt API file for QScintilla "
+            "[default: install only if QScintilla installed]")
+    g.add_option("-n", "--qsci-api-destdir", action="callback", dest="qscidir",
+            metavar="DIR", callback=store_abspath, type="string", help="where "
+            "the PyQt API file for QScintilla will be installed [default: "
+            "QTDIR/qsci]")
+    p.add_option_group(g)
+
+    return p
+
+
+class pyrccMakefile(sipconfig.ProgramMakefile):
+    """This class implements the Makefile for pyrcc.  This is specialised so
+    that pyrcc is automatically run against the examples.
+    """
+
+    def __init__(self):
+        sipconfig.ProgramMakefile.__init__(self, configuration=sipcfg,
+                build_file=os.path.join(src_dir, "pyrcc", "pyrcc.sbf"),
+                dir="pyrcc", install_dir=opts.pyqtbindir, console=1,
+                qt=["QtCore", "QtXml"], debug=opts.debug, warnings=1,
+                universal=sipcfg.universal, arch=sipcfg.arch,
+                deployment_target=sipcfg.deployment_target)
+
+    def generate_target_default(self, mfile):
+        """Generate the default target."""
+        sipconfig.ProgramMakefile.generate_target_default(self, mfile)
+
+        # The correct call to pyrcc depends on the Python version.
+        if sys.hexversion >= 0x03000000:
+            flag = "-py3"
+        else:
+            flag = "-py2"
+
+        exe = "$(TARGET)"
+        if sys.platform != 'win32':
+            exe = "./" + exe
+
+        # Find all the .qrc files in the examples.
+        for root, _, files in os.walk("examples"):
+            rel_root = os.path.join("..", root)
+
+            for fn in files:
+                if fn.endswith(".qrc"):
+                    mfile.write("\t%s %s -o %s %s\n" % (exe, flag, os.path.join(rel_root, fn[:-4] + "_rc.py"), os.path.join(rel_root, fn)))
+
+
+class ConfigurePyQt4:
+    """This class defines the methods to configure PyQt4.
+    """
+    def __init__(self, generator):
+        self.generator = generator
+
+    def qt_version_tags(self):
+        """Get the versions tags for the configuration.
+
+        Returns a dictionary of versions and corresponding tags.
+        """
+        return {
+            0x040101: None,
+            0x040102: "Qt_4_1_1",
+            0x040103: "Qt_4_1_2",
+            0x040200: "Qt_4_1_3",
+            0x040202: "Qt_4_2_0",
+            0x040300: "Qt_4_2_2",
+            0x040303: "Qt_4_3_0",
+            0x040400: "Qt_4_3_3",
+            0x040401: "Qt_4_4_0",
+            0x040500: "Qt_4_4_1",
+            0x040501: "Qt_4_5_0",
+            0x040600: "Qt_4_5_1",
+            0x040601: "Qt_4_6_0",
+            0x040602: "Qt_4_6_1",
+            0x040603: "Qt_4_6_2",
+            0x040700: "Qt_4_6_3",
+            0x040701: "Qt_4_7_0",
+            0x040702: "Qt_4_7_1",
+            0x040800: "Qt_4_7_2",
+            0x040803: "Qt_4_8_0",
+            0x040804: "Qt_4_8_3",
+            0x050000: "Qt_4_8_4",
+            0x060000: "Qt_5_0_0"
+        }
+
+    def check_modules(self):
+        if opts.mwg_odbc:
+            sql_libs = ["odbc32"]
+        else:
+            sql_libs = None
+
+        if opts.mwg_ssl_dir:
+            ass_lib_dirs = [os.path.join(opts.mwg_ssl_dir, "lib")]
+            ass_libs = ["ssleay32", "libeay32"]
+        else:
+            ass_lib_dirs = None
+            ass_libs = None
+
+        # Note that the order in which we check is important for the
+        # consolidated module - a module's dependencies must be checked first.
+        pyqt_modules.append("QtCore")
+
+        check_module("QtGui", "qwidget.h", "new QWidget()")
+        check_module("QtHelp", "qhelpengine.h", "new QHelpEngine(\"foo\")")
+        if qt_version < 0x050000: check_module("QtMultimedia", "QAudioDeviceInfo",
+                "new QAudioDeviceInfo()")
+        check_module("QtNetwork", "qhostaddress.h", "new QHostAddress()")
+        if qt_version < 0x050000: check_module("QtDBus", "qdbusconnection.h",
+                "QDBusConnection::systemBus()")
+        if qt_version < 0x050000: check_module("QtDeclarative", "qdeclarativeview.h",
+                "new QDeclarativeView()")
+        if qt_version < 0x050000: check_module("QtOpenGL", "qgl.h", "new QGLWidget()")
+        if qt_version < 0x050000: check_module("QtScript", "qscriptengine.h", "new QScriptEngine()")
+        if qt_version < 0x050000: check_module("QtScriptTools", "qscriptenginedebugger.h",
+                "new QScriptEngineDebugger()")
+        check_module("QtSql", "qsqldatabase.h", "new QSqlDatabase()",
+                extra_libs=sql_libs)
+        check_module("QtSvg", "qsvgwidget.h", "new QSvgWidget()")
+        if qt_version < 0x050000: check_module("QtTest", "QtTest", "QTest::qSleep(0)")
+        check_module("QtWebKit", "qwebpage.h", "new QWebPage()")
+        check_module("QtXml", "qdom.h", "new QDomDocument()")
+
+        # Qt v5-beta1 causes compiler error messages.  Wait to see if it fixed
+        # in a later release.
+        if qt_version < 0x050000:
+            check_module("QtXmlPatterns", "qxmlname.h", "new QXmlName()")
+
+        if qt_version < 0x050000: check_module("phonon", "phonon/videowidget.h",
+                "new Phonon::VideoWidget()")
+        check_module("QtAssistant", "qassistantclient.h",
+                "new QAssistantClient(\"foo\")", extra_lib_dirs=ass_lib_dirs,
+                extra_libs=ass_libs)
+
+        if not qt_shared:
+            sipconfig.inform("QtDesigner module disabled with static Qt libraries.")
+        elif sipcfg.universal:
+            sipconfig.inform("QtDesigner module disabled with universal binaries.")
+        else:
+            if qt_version < 0x050000: check_module("QtDesigner", "QExtensionFactory",
+                    "new QExtensionFactory()")
+
+        if qt_version < 0x050000: check_module("QAxContainer", "qaxobject.h", "new QAxObject()",
+                extra_libs=["QAxContainer"])
+
+        if os.path.isdir(os.path.join(src_dir, "dbus")):
+            check_dbus()
+
+    def code(self):
+        cons_xtra_incdirs = []
+        cons_xtra_libdirs = []
+        cons_xtra_libs = []
+
+        sp_libs, sp_libdirs = self._static_plugins("QtCore")
+        sp_incdirs = []
+
+        qpy_inc_dir, qpy_lib_dir, qpy_lib = self._qpy_directories("QtCore", "qpycore")
+        sp_incdirs.append(qpy_inc_dir)
+        sp_libdirs.append(qpy_lib_dir)
+        sp_libs.append(qpy_lib)
+
+        if opts.vendorcheck:
+            sp_incdirs.append(opts.vendincdir)
+            sp_libdirs.append(opts.vendlibdir)
+            sp_libs.append("vendorid")
+
+        if opts.bigqt:
+            cons_xtra_incdirs.extend(sp_incdirs)
+            cons_xtra_libdirs.extend(sp_libdirs)
+            cons_xtra_libs.extend(sp_libs)
+
+            generate_code("QtCore")
+        else:
+            generate_code("QtCore", extra_include_dirs=sp_incdirs,
+                        extra_lib_dirs=sp_libdirs, extra_libs=sp_libs)
+
+        if "QtDeclarative" in pyqt_modules:
+            qpy_inc_dir, qpy_lib_dir, qpy_lib = self._qpy_directories("QtDeclarative", "qpydeclarative")
+
+            if opts.bigqt:
+                cons_xtra_incdirs.append(qpy_inc_dir)
+                cons_xtra_libdirs.append(qpy_lib_dir)
+                cons_xtra_libs.append(qpy_lib)
+
+                generate_code("QtDeclarative")
+            else:
+                generate_code("QtDeclarative", extra_include_dirs=[qpy_inc_dir],
+                        extra_lib_dirs=[qpy_lib_dir], extra_libs=[qpy_lib])
+
+        if "QtGui" in pyqt_modules:
+            sp_libs, sp_libdirs = self._static_plugins("QtGui")
+            sp_incdirs = []
+
+            qpy_inc_dir, qpy_lib_dir, qpy_lib = self._qpy_directories("QtGui", "qpygui")
+            sp_incdirs.append(qpy_inc_dir)
+            sp_libdirs.append(qpy_lib_dir)
+            sp_libs.append(qpy_lib)
+
+            if opts.bigqt:
+                cons_xtra_incdirs.extend(sp_incdirs)
+                cons_xtra_libdirs.extend(sp_libdirs)
+                cons_xtra_libs.extend(sp_libs)
+
+                generate_code("QtGui")
+            else:
+                generate_code("QtGui", extra_include_dirs=sp_incdirs,
+                        extra_lib_dirs=sp_libdirs, extra_libs=sp_libs)
+
+        if "QtHelp" in pyqt_modules:
+            generate_code("QtHelp")
+
+        if "QtMultimedia" in pyqt_modules:
+            generate_code("QtMultimedia")
+
+        if "QtNetwork" in pyqt_modules:
+            generate_code("QtNetwork")
+
+        if "QtDBus" in pyqt_modules:
+            qpy_inc_dir, qpy_lib_dir, qpy_lib = self._qpy_directories("QtDBus", "qpydbus")
+
+            if opts.bigqt:
+                cons_xtra_incdirs.append(qpy_inc_dir)
+                cons_xtra_libdirs.append(qpy_lib_dir)
+                cons_xtra_libs.append(qpy_lib)
+
+                generate_code("QtDBus")
+            else:
+                generate_code("QtDBus", extra_include_dirs=[qpy_inc_dir],
+                        extra_lib_dirs=[qpy_lib_dir], extra_libs=[qpy_lib])
+
+        if "QtOpenGL" in pyqt_modules:
+            generate_OpenGL_extras()
+
+            qpy_inc_dir, qpy_lib_dir, qpy_lib = self._qpy_directories("QtOpenGL", "qpyopengl")
+
+            if opts.bigqt:
+                cons_xtra_incdirs.append(qpy_inc_dir)
+                cons_xtra_libdirs.append(qpy_lib_dir)
+                cons_xtra_libs.append(qpy_lib)
+
+                generate_code("QtOpenGL")
+            else:
+                generate_code("QtOpenGL", extra_include_dirs=[qpy_inc_dir],
+                        extra_lib_dirs=[qpy_lib_dir], extra_libs=[qpy_lib])
+
+        if "QtScript" in pyqt_modules:
+            generate_code("QtScript")
+
+        if "QtScriptTools" in pyqt_modules:
+            generate_code("QtScriptTools")
+
+        if "QtSql" in pyqt_modules:
+            sp_libs, sp_libdirs = self._static_plugins("QtSql")
+
+            if opts.bigqt:
+                cons_xtra_libdirs.extend(sp_libdirs)
+                cons_xtra_libs.extend(sp_libs)
+
+                generate_code("QtSql")
+            else:
+                generate_code("QtSql", extra_lib_dirs=sp_libdirs,
+                        extra_libs=sp_libs)
+
+        if "QtSvg" in pyqt_modules:
+            generate_code("QtSvg")
+
+        if "QtTest" in pyqt_modules:
+            generate_code("QtTest")
+
+        if "QtWebKit" in pyqt_modules:
+            generate_code("QtWebKit")
+
+        if "QtXml" in pyqt_modules:
+            generate_code("QtXml")
+
+        if "QtXmlPatterns" in pyqt_modules:
+            generate_code("QtXmlPatterns")
+
+        if "phonon" in pyqt_modules:
+            generate_code("phonon")
+
+        if "QtAssistant" in pyqt_modules:
+            generate_code("QtAssistant")
+
+        if "QtDesigner" in pyqt_modules:
+            qpy_inc_dir, qpy_lib_dir, qpy_lib = self._qpy_directories("QtDesigner", "qpydesigner")
+
+            if opts.bigqt:
+                cons_xtra_incdirs.append(qpy_inc_dir)
+                cons_xtra_libdirs.append(qpy_lib_dir)
+                cons_xtra_libs.append(qpy_lib)
+
+                generate_code("QtDesigner")
+            else:
+                generate_code("QtDesigner", extra_include_dirs=[qpy_inc_dir],
+                        extra_lib_dirs=[qpy_lib_dir], extra_libs=[qpy_lib])
+
+        if "QAxContainer" in pyqt_modules:
+            generate_code("QAxContainer")
+
+        # Generate the composite module.
+        qtmod_sipdir = os.path.join("sip", "Qt")
+        mk_clean_dir(qtmod_sipdir)
+
+        qtmod_sipfile = os.path.join(qtmod_sipdir, "Qtmod.sip")
+        f = open(qtmod_sipfile, "w")
+
+        f.write("""%CompositeModule PyQt4.Qt
+
+""")
+
+        for m in pyqt_modules:
+            f.write("%%Include %s/%smod.sip\n" % (m, m))
+
+        f.close()
+
+        generate_code("Qt")
+
+        # Generate the consolidated module if required.
+        if opts.bigqt:
+            xtra_sip_flags = []
+
+            _qtmod_sipdir = os.path.join("sip", "_qt")
+            mk_clean_dir(_qtmod_sipdir)
+
+            _qtmod_sipfile = os.path.join(_qtmod_sipdir, "_qtmod.sip")
+            f = open(_qtmod_sipfile, "w")
+
+            f.write("""%ConsolidatedModule PyQt4._qt
+
+""")
+
+            for m in pyqt_modules:
+                f.write("%%Include %s/%smod.sip\n" % (m, m))
+
+            if opts.mwg_qsci_dir:
+                f.write("%Include Qsci/Qscimod.sip\n")
+                cons_xtra_libs.append("qscintilla2")
+
+                # Copy in the QScintilla .sip files and fix the main one.
+                src_dir = os.path.join(opts.mwg_qsci_dir, "Python", "sip")
+                dst_dir = os.path.join("sip", "Qsci")
+
+                try:
+                    shutil.rmtree(dst_dir);
+                except:
+                    pass
+
+                shutil.copytree(src_dir, dst_dir)
+                os.rename(os.path.join(dst_dir, "qscimod4.sip"), os.path.join(dst_dir, "Qscimod.sip"))
+
+                generate_code("Qsci")
+
+            if opts.mwg_qwt_dir:
+                f.write("%Include Qwt5/Qwt5mod.sip\n")
+                cons_xtra_incdirs.append(os.path.join(opts.mwg_qwt_dir, "support"))
+                cons_xtra_libs.append("qwt")
+
+                # Copy in the PyQwt .sip files and fix the main one.
+                src_dir = os.path.join(opts.mwg_qwt_dir, "sip", "qwt5qt4")
+                dst_dir = os.path.join("sip", "Qwt5")
+
+                try:
+                    shutil.rmtree(dst_dir);
+                except:
+                    pass
+
+                shutil.copytree(src_dir, dst_dir)
+                os.rename(os.path.join(dst_dir, "QwtModule.sip"), os.path.join(dst_dir, "Qwt5mod.sip"))
+
+                xtra_sip_flags = ["-t", "Qwt_5_0_1",
+                                  "-x", "CXX_DYNAMIC_CAST",
+                                  "-x", "HAS_QWT4",
+                                  "-x", "HAS_NUMARRAY",
+                                  "-x", "HAS_NUMERIC",
+                                  "-x", "HAS_NUMPY"]
+
+                generate_code("Qwt5", extra_sip_flags=xtra_sip_flags)
+
+            f.close()
+
+            if opts.mwg_odbc:
+                cons_xtra_libs.append("odbc32")
+
+            if opts.mwg_ssl_dir:
+                cons_xtra_libdirs.append(os.path.join(opts.mwg_ssl_dir, "lib"))
+                cons_xtra_libs.extend(["ssleay32", "libeay32"])
+
+            generate_code("_qt", extra_include_dirs=cons_xtra_incdirs,
+                    extra_lib_dirs=cons_xtra_libdirs,
+                    extra_libs=cons_xtra_libs, extra_sip_flags=xtra_sip_flags)
+
+        # Tell the user about any plugins not found.
+        if opts.staticplugins:
+            sipconfig.inform("Unable to find the following static plugins: %s" % ", ".join(opts.staticplugins))
+
+        # Generate the QScintilla API file.
+        sipconfig.inform("Creating QScintilla API file...")
+        f = open("PyQt4.api", "w")
+
+        for m in pyqt_modules:
+            api = open(m + ".api")
+
+            for l in api:
+                f.write("PyQt4." + l)
+
+            api.close()
+            os.remove(m + ".api")
+
+        f.close()
+
+    def _qpy_directories(self, mname, lib_name):
+        """Return a 3-tuple of the directories containing the header files, the
+        directory containing the library, and the name of the support library
+        for the given module.
+
+        mname is the name of the module.
+        lib_name is the normal name of the support library.
+        """
+        qpy_dir = os.path.join("qpy", mname)
+
+        if sys.platform == 'win32':
+            if opts.debug:
+                qpy_lib_dir = os.path.join(qpy_dir, "debug")
+                lib_name = 'd' + lib_name
+            else:
+                qpy_lib_dir = os.path.join(qpy_dir, "release")
+        else:
+            qpy_lib_dir = qpy_dir
+
+            if sys.platform == 'darwin' and opts.debug:
+                lib_name += '_debug'
+
+        return os.path.join(src_dir, qpy_dir), os.path.abspath(qpy_lib_dir), lib_name
+
+    def _static_plugins(self, mname):
+        """Return a tuple of the libraries (in platform neutral format) and the
+        directories they are contained in for all the requested static plugins
+        for the given module.  Generate the additional .sip file needed to
+        ensure the plugins get linked.
+
+        mname is the name of the module.
+        """
+        plugin_dirs = {
+            "QtCore":   ("codecs", ),
+            # Note that we put iconengines after imageformats so that qsvg is
+            # found in the latter rather than the former.  The name clash is
+            # probably a Qt bug.
+            "QtGui":    ("inputmethods", "imageformats", "iconengines"),
+            "QtSql":    ("sqldrivers", )
+        }
+
+        libs = []
+        libdirs = []
+
+        for plug in opts.staticplugins:
+            # Convert the plugin name to a platform specific filename.
+            if self.generator in ("MSVC", "MSVC.NET", "BMAKE"):
+                pfname = plug + ".lib"
+            else:
+                pfname = "lib" + plug + ".a"
+
+            for pdir in plugin_dirs[mname]:
+                ppath = os.path.join(qt_pluginsdir, pdir)
+
+                # See if the plugin exists.
+                if os.access(os.path.join(ppath, pfname), os.F_OK):
+                    sipconfig.inform("Adding the %s static plugin to the %s module..." % (plug, mname))
+
+                    libs.append(plug)
+
+                    if ppath not in libdirs:
+                        libdirs.append(ppath)
+
+                    break
+
+        # Remove those plugins we have handled.
+        opts.staticplugins = [p for p in opts.staticplugins if p not in libs]
+
+        # If we have any plugins for this module then generate a .sip file that
+        # will include the code needed to ensure the plugin gets linked.
+        if libs:
+            sp_sipfile = os.path.join("sip", mname, "staticplugins.sip")
+
+            f = open(sp_sipfile, "w")
+
+            f.write("""%ModuleCode
+
+#include <QtPlugin>
+
+""")
+
+            for l in libs:
+                f.write("Q_IMPORT_PLUGIN(%s)\n" % l)
+
+            f.write("""
+%End
+""")
+
+            f.close()
+
+        return libs, libdirs
+
+    def module_installs(self):
+        return [os.path.join(src_dir, "__init__.py"), "pyqtconfig.py"]
+
+    def qpy_libs(self):
+        # See which QPy support libraries to build.
+        qpylibs = {}
+
+        if "QtCore" in pyqt_modules:
+            qpylibs["QtCore"] = "qpycore.pro"
+
+        if "QtGui" in pyqt_modules:
+            qpylibs["QtGui"] = "qpygui.pro"
+
+        if "QtDBus" in pyqt_modules:
+            qpylibs["QtDBus"] = "qpydbus.pro"
+
+        if "QtDeclarative" in pyqt_modules:
+            qpylibs["QtDeclarative"] = "qpydeclarative.pro"
+
+        if "QtDesigner" in pyqt_modules:
+            qpylibs["QtDesigner"] = "qpydesigner.pro"
+
+        if "QtOpenGL" in pyqt_modules:
+            qpylibs["QtOpenGL"] = "qpyopengl.pro"
+
+        # Run qmake to generate the Makefiles.
+        qmake_args = fix_qmake_args()
+        cwd = os.getcwd()
+
+        for qpy, pro in qpylibs.items():
+            sipconfig.inform("Creating QPy support library for %s Makefile..." % qpy)
+
+            qpydir = os.path.join("qpy", qpy)
+            mk_clean_dir(qpydir, clean=0)
+            os.chdir(qpydir)
+
+            wrapped_pro = "w_" + pro
+
+            f = open(wrapped_pro, 'w+')
+
+            if sipcfg.arch:
+                f.write(arch_config())
+
+            if sipcfg.universal:
+                f.write("QMAKE_MAC_SDK = %s\n" % sipcfg.universal)
+
+            if sipcfg.deployment_target:
+                f.write("QMAKE_MACOSX_DEPLOYMENT_TARGET = %s\n" % sipcfg.deployment_target)
+
+            inc_path = [sipcfg.py_inc_dir]
+            if qpy in ("QtCore", "QtDBus", "QtDeclarative", "QtOpenGL"):
+                if sipcfg.sip_inc_dir != sipcfg.py_inc_dir:
+                    inc_path.insert(0, sipcfg.sip_inc_dir)
+
+                if sipcfg.py_conf_inc_dir != sipcfg.py_inc_dir:
+                    inc_path.insert(0, sipcfg.py_conf_inc_dir)
+
+                if opts.bigqt:
+                    api_dir = "../../_qt"
+                else:
+                    api_dir = "../../" + qpy
+
+                inc_path.append(api_dir)
+
+            if opts.debug:
+                pro_config = 'debug'
+            else:
+                pro_config = 'release'
+
+            if src_dir != os.path.curdir:
+                src_qpydir = os.path.join(src_dir, "qpy", qpy)
+                pro = os.path.join(src_qpydir, pro)
+                vpath = "VPATH = " + src_qpydir
+                inc_path.append(src_qpydir)
+            else:
+                vpath = ""
+
+            f.write(
+"""# Tell the original .pro file about additional directories.
+INCLUDEPATH = %s
+CONFIG += %s
+%s
+include(%s)
+""" % (" ".join(['"' + i + '"' for i in inc_path]), pro_config, vpath, pro))
+
+            f.close()
+
+            run_command("%s %s %s" % (opts.qmake, qmake_args, wrapped_pro))
+            os.chdir(cwd)
+
+        sipconfig.inform("Creating QPy support libraries Makefile...")
+
+        sipconfig.ParentMakefile(
+            configuration=sipcfg,
+            dir="qpy",
+            subdirs=list(qpylibs.keys())
+        ).generate()
+
+        return ["qpy"]
+
+    def tools(self):
+        tool = []
+
+        if pydbusmoddir:
+            sipconfig.inform("Creating dbus support module Makefile...")
+
+            makefile = sipconfig.ModuleMakefile(
+                configuration=sipcfg,
+                build_file=os.path.join(src_dir, "dbus", "dbus.sbf"),
+                dir="dbus",
+                install_dir=pydbusmoddir,
+                qt=["QtCore"],
+                debug=opts.debug,
+                universal=sipcfg.universal,
+                arch=sipcfg.arch,
+                deployment_target=sipcfg.deployment_target
+            )
+
+            add_makefile_extras(makefile, dbusincdirs, dbuslibdirs, dbuslibs)
+
+            makefile.generate()
+            tool.append("dbus")
+
+        # Only include ElementTree for older versions of Python.
+        if sipcfg.py_version < 0x020500:
+            sipconfig.inform("Creating elementtree Makefile...")
+
+            makefile = sipconfig.PythonModuleMakefile(
+                configuration=sipcfg,
+                dstdir=os.path.join(pyqt_modroot, "elementtree"),
+                dir="elementtree"
+            )
+
+            makefile.generate()
+            tool.append("elementtree")
+
+        # Create the pyuic4 wrapper.  Use the GUI version on MacOS (so that
+        # previews work properly and normal console use will work anyway), but
+        # not on Windows (so that normal console use will work).
+        sipconfig.inform("Creating pyuic4 wrapper...")
+
+        if sys.platform == 'darwin':
+            gui = True
+            use_arch = opts.use_arch
+        else:
+            gui = False
+            use_arch = ''
+
+        # The pyuic directory may not exist if we are building away from the
+        # source directory.
+        try:
+            os.mkdir("pyuic")
+        except OSError:
+            pass
+
+        uicdir=os.path.join(pyqt_modroot, "uic")
+        wrapper = sipconfig.create_wrapper(os.path.join(uicdir, "pyuic.py"), os.path.join("pyuic", "pyuic4"), gui, use_arch)
+
+        sipconfig.inform("Creating pyuic4 Makefile...")
+
+        makefile = sipconfig.PythonModuleMakefile(
+            configuration=sipcfg,
+            dstdir=uicdir,
+            srcdir=os.path.join(src_dir, "pyuic", "uic"),
+            dir="pyuic",
+            installs=[[os.path.basename(wrapper), opts.pyqtbindir]]
+        )
+
+        makefile.generate()
+        tool.append("pyuic")
+
+        if "QtXml" in pyqt_modules:
+            sipconfig.inform("Creating pylupdate4 Makefile...")
+
+            cxxflags_app = sipcfg.build_macros().get("CXXFLAGS_APP", "")
+
+            makefile = sipconfig.ProgramMakefile(
+                configuration=sipcfg,
+                build_file=os.path.join(src_dir, "pylupdate", "pylupdate.sbf"),
+                dir="pylupdate",
+                install_dir=opts.pyqtbindir,
+                console=1,
+                qt=["QtCore", "QtXml"],
+                debug=opts.debug,
+                warnings=1,
+                universal=sipcfg.universal,
+                arch=sipcfg.arch,
+                deployment_target=sipcfg.deployment_target
+            )
+
+            makefile.extra_include_dirs.append(
+                    os.path.join(src_dir, "pylupdate"))
+
+            if cxxflags_app != "":
+                makefile.extra_cxxflags.append(cxxflags_app)
+
+            makefile.generate()
+            tool.append("pylupdate")
+
+            sipconfig.inform("Creating pyrcc4 Makefile...")
+
+            makefile = pyrccMakefile()
+
+            if cxxflags_app != "":
+                makefile.extra_cxxflags.append(cxxflags_app)
+
+            makefile.generate()
+            tool.append("pyrcc")
+        else:
+            sipconfig.inform("pylupdate4 and pyrcc4 will not be built because the Qt XML module is missing.")
+
+        if opts.designer_plugin and "QtDesigner" in pyqt_modules:
+            py_major = sipcfg.py_version >> 16
+            py_minor = (sipcfg.py_version >> 8) & 0x0ff
+
+            abi = getattr(sys, 'abiflags', '')
+
+            if sys.platform == 'win32':
+                # Use abiflags in case it is supported in a future version.
+                lib_dir_flag = quote("-L%s" % sipcfg.py_lib_dir)
+                link = "%s -lpython%d%d%s" % (lib_dir_flag, py_major, py_minor, abi)
+                pysh_lib = "python%d%d%s.dll" % (py_major, py_minor, abi)
+            else:
+                # Use distutils to get the additional configuration.
+                from distutils.sysconfig import get_config_vars
+                ducfg = get_config_vars()
+
+                config_args = ducfg.get("CONFIG_ARGS", "")
+
+                if sys.platform == "darwin":
+                    dynamic_pylib = "--enable-framework" in config_args
+
+                    # It's probably a Python bug that the library name doesn't
+                    # include the ABI information.
+                    abi = ""
+                else:
+                    dynamic_pylib = "--enable-shared" in config_args
+
+                if dynamic_pylib:
+                    if glob.glob("%s/lib/libpython%d.%d*" % (ducfg["exec_prefix"], py_major, py_minor)):
+                        lib_dir_flag = quote("-L%s/lib" % ducfg["exec_prefix"])
+                    elif glob.glob("%s/libpython%d.%d*" % (ducfg["LIBDIR"], py_major, py_minor)):
+                        lib_dir_flag = quote("-L%s" % ducfg["LIBDIR"])
+                    else:
+                        sipconfig.inform("Qt Designer plugin disabled because Python library couldn't be found")
+                        lib_dir_flag = ''
+                        opts.designer_plugin = False
+
+                    link = "%s -lpython%d.%d%s" % (lib_dir_flag, py_major, py_minor, abi)
+                else:
+                    sipconfig.inform("Qt Designer plugin disabled because Python library is static")
+                    opts.designer_plugin = False
+
+                pysh_lib = ducfg.get("LDLIBRARY", "")
+
+            if opts.designer_plugin:
+                sipconfig.inform("Creating Qt Designer plugin Makefile...")
+
+                # Run qmake to generate the Makefile.
+                qmake_args = fix_qmake_args()
+                cwd = os.getcwd()
+
+                mk_clean_dir("designer", clean=0)
+                os.chdir("designer")
+
+                # Create the qmake project file.
+                fin = open(os.path.join(src_dir, "designer", "python.pro-in"))
+                prj = fin.read()
+                fin.close()
+
+                prj = prj.replace("@PYINCDIR@", quote(sipcfg.py_inc_dir))
+                prj = prj.replace("@PYINCDIR@", " ".join((quote(sipcfg.py_conf_inc_dir), quote(sipcfg.py_inc_dir))))
+                prj = prj.replace("@PYLINK@", link)
+                prj = prj.replace("@PYSHLIB@", pysh_lib)
+                prj = prj.replace("@QTPLUGINDIR@", quote(opts.plugindir + "/designer"))
+
+                fout = open("python.pro", "w+")
+
+                if sipcfg.arch:
+                    fout.write(arch_config())
+
+                if sipcfg.universal:
+                    fout.write("QMAKE_MAC_SDK = %s\n" % sipcfg.universal)
+
+                if sipcfg.deployment_target:
+                    fout.write("QMAKE_MACOSX_DEPLOYMENT_TARGET = %s\n" % sipcfg.deployment_target)
+
+                if src_dir != os.path.curdir:
+                    fout.write("VPATH = %s\n" % os.path.join(src_dir, "designer"))
+
+                fout.write(prj)
+                fout.close()
+
+                run_command("%s %s" % (opts.qmake, qmake_args))
+                os.chdir(cwd)
+
+                tool.append("designer")
+
+        return tool
+
+
+def arch_config():
+    """Return the qmake CONFIG line for a MacOS binary."""
+
+    qmake_archs = []
+    for a in sipcfg.arch.split():
+        if a == 'i386':
+            qmake_archs.append('x86')
+        elif a == 'x86_64':
+            qmake_archs.append('x86_64')
+        elif a == 'ppc':
+            qmake_archs.append('ppc')
+
+    return 'CONFIG += %s\n' % ' '.join(qmake_archs)
+
+
+def quote(path):
+    """Return a path with quotes added if it contains spaces."""
+    if " " in path:
+        path = '"%s"' % path
+
+    return path
+
+
+def inform_user():
+    """Tell the user the option values that are going to be used.
+    """
+    if qt_edition:
+        edstr = qt_edition + " edition "
+    else:
+        edstr = ""
+
+    if qt_shared:
+        lib_type = "shared"
+    else:
+        lib_type = "static"
+
+    sipconfig.inform("Qt v%s %sis being used." % (sipconfig.version_to_string(qt_version), edstr))
+
+    if qt_licensee:
+        sipconfig.inform("Qt is licensed to %s." % qt_licensee)
+
+    if sys.platform == "darwin" and qt_framework:
+        sipconfig.inform("Qt is built as a framework.")
+
+    sipconfig.inform("SIP %s is being used." % sipcfg.sip_version_str)
+    sipconfig.inform("The Qt header files are in %s." % qt_incdir)
+    sipconfig.inform("The %s Qt libraries are in %s." % (lib_type, qt_libdir))
+    sipconfig.inform("The Qt binaries are in %s." % qt_bindir)
+    sipconfig.inform("The Qt mkspecs directory is in %s." % qt_datadir)
+    sipconfig.inform("These PyQt modules will be built: %s." % ", ".join(pyqt_modules))
+    sipconfig.inform("The PyQt Python package will be installed in %s." % opts.pyqtmoddir)
+
+    if opts.with_deprecated:
+        sipconfig.inform("PyQt is being built with deprecated Qt v4 features")
+    else:
+        sipconfig.inform("PyQt is being built without deprecated Qt v4 features")
+
+    if opts.no_docstrings:
+        sipconfig.inform("PyQt is being built without generated docstrings.")
+    else:
+        sipconfig.inform("PyQt is being built with generated docstrings.")
+
+    if opts.prot_is_public:
+        sipconfig.inform("PyQt is being built with 'protected' redefined as 'public'.")
+
+    if opts.designer_plugin:
+        sipconfig.inform("The Designer plugin will be installed in %s." % os.path.join(opts.plugindir, "designer"))
+
+    if opts.api:
+        sipconfig.inform("The QScintilla API file will be installed in %s." % os.path.join(opts.qscidir, "api", "python"))
+
+    if pydbusmoddir:
+        sipconfig.inform("The dbus support module will be installed in %s." % pydbusmoddir)
+
+    sipconfig.inform("The PyQt .sip files will be installed in %s." % opts.pyqtsipdir)
+
+    sipconfig.inform("pyuic4, pyrcc4 and pylupdate4 will be installed in %s." % opts.pyqtbindir)
+
+    if opts.vendorcheck:
+        sipconfig.inform("PyQt will only be usable with signed interpreters.")
+
+
+def create_config(module, template, macros):
+    """Create the PyQt configuration module so that it can be imported by build
+    scripts.
+
+    module is the module file name.
+    template is the template file name.
+    macros is the dictionary of platform specific build macros.
+    """
+    sipconfig.inform("Creating %s..." % module)
+
+    content = {
+        "pyqt_config_args":   sys.argv[1:],
+        "pyqt_version":       pyqt_version,
+        "pyqt_version_str":   pyqt_version_str,
+        "pyqt_bin_dir":       opts.pyqtbindir,
+        "pyqt_mod_dir":       pyqt_modroot,
+        "pyqt_sip_dir":       opts.pyqtsipdir,
+        "pyqt_modules":       pyqt_modules,
+        "pyqt_sip_flags":     qt_sip_flags,
+        "qt_version":         qt_version,
+        "qt_edition":         qt_edition,
+        "qt_winconfig":       qt_shared,
+        "qt_framework":       qt_framework,
+        "qt_threaded":        1,
+        "qt_dir":             qt_dir,
+        "qt_data_dir":        qt_datadir,
+        "qt_inc_dir":         qt_incdir,
+        "qt_lib_dir":         qt_libdir
+    }
+
+    sipconfig.create_config_module(module, template, content, macros)
+
+
+def run_command(cmd, envvars=None):
+    """Run a command and display the output if verbose mode is enabled.
+
+    cmd is the command to run.
+    """
+    if opts.verbose:
+        sys.stdout.write(cmd + "\n")
+
+    fout = get_command_stdout(cmd, and_stderr=True, envvars=envvars)
+
+    # Read stdout and stderr until there is no more output.
+    lout = fout.readline()
+    while lout:
+        if opts.verbose:
+            if sys.hexversion >= 0x03000000:
+                sys.stdout.write(str(lout, encoding=sys.stdout.encoding))
+            else:
+                sys.stdout.write(lout)
+
+        lout = fout.readline()
+
+    fout.close()
+
+    try:
+        os.wait()
+    except:
+        pass
+
+
+def remove_file(fname):
+    """Remove a file which may or may not exist.
+
+    fname is the name of the file.
+    """
+    try:
+        os.remove(fname)
+    except OSError:
+        pass
+
+
+def generate_OpenGL_extras():
+    """Generate the extras needed by the QtOpenGL module (i.e. the .sip file
+    defining the correct typedefs for the OpenGL data types.
+    """
+    sipconfig.inform("Determining the OpenGL data types...")
+
+    src = "opengl_extras.cpp"
+
+    f = open(src, "w")
+
+    f.write(
+"""#include <QFile>
+#include <QTextStream>
+#include <qgl.h>
+
+int main(int, char **)
+{
+    QFile outf("./sip/QtOpenGL/opengl_types.sip");
+
+    if (!outf.open(QIODevice::WriteOnly|QIODevice::Truncate|QIODevice::Text))
+        return 1;
+
+    QTextStream out(&outf);
+
+    if (sizeof (long) == sizeof (GLint))
+        out << "typedef long GLint;\\n";
+    else
+        out << "typedef int GLint;\\n";
+
+    if (sizeof (unsigned long) == sizeof (GLuint))
+        out << "typedef unsigned long GLuint;\\n";
+    else
+        out << "typedef unsigned GLuint;\\n";
+
+    if (sizeof (unsigned long) == sizeof (GLenum))
+        out << "typedef unsigned long GLenum;\\n";
+    else
+        out << "typedef unsigned GLenum;\\n";
+
+    if (sizeof (unsigned long) == sizeof (GLbitfield))
+        out << "typedef unsigned long GLbitfield;\\n";
+    else
+        out << "typedef unsigned GLbitfield;\\n";
+
+    out << "typedef float GLfloat;\\n";
+
+    return 0;
+}
+""")
+
+    f.close()
+
+    cmd = compile_qt_program(src, "QtOpenGL")
+
+    if cmd is None:
+        sipconfig.error("Unable to determine the OpenGL data types.")
+
+    # SIP's build system (specifically ProgramMakefile.build_command()) assumes
+    # that an executable can be created by running a single command.  In the
+    # case of MSVC this is incorrect.  As a quick hack we do the extra step
+    # here if it looks like it is needed.
+    if os.access("opengl_extras.manifest", os.F_OK):
+        run_command("mt -nologo -manifest opengl_extras.manifest -outputresource:opengl_extras.exe;1")
+
+    run_command(cmd)
+
+
+def compile_qt_program(name, mname, extra_include_dirs=None, extra_lib_dirs=None, extra_libs=None):
+    """Compile a simple Qt application.
+
+    name is the name of the single source file.
+    mname is the name of the Qt module.
+    extra_include_dirs is an optional list of extra include directories.
+    extra_lib_dirs is an optional list of extra library directories.
+    extra_libs is an optional list of extra libraries.
+
+    Returns the name of the executable suitable for running or None if it
+    wasn't created.
+    """
+    opengl = (mname == "QtOpenGL")
+
+    qt = [mname]
+    if mname in ("QtAssistant", "QtHelp", "QtOpenGL", "QtWebKit"):
+        qt.append("QtCore")
+
+    makefile = sipconfig.ProgramMakefile(sipcfg, console=1, qt=qt, warnings=0,
+            opengl=opengl, debug=opts.debug, arch=sipcfg.arch,
+            deployment_target=sipcfg.deployment_target)
+
+    add_makefile_extras(makefile, extra_include_dirs, extra_lib_dirs, extra_libs)
+
+    exe, build = makefile.build_command(name)
+
+    if sipcfg.deployment_target:
+        envvars = {'MACOSX_DEPLOYMENT_TARGET': '%s' % sipcfg.deployment_target}
+    else:
+        envvars = None
+
+    # Make sure the executable file doesn't exist.
+    remove_file(exe)
+    run_command(build, envvars=envvars)
+
+    if not os.access(exe, os.X_OK):
+        return None
+
+    if sys.platform != 'win32':
+        exe = "./" + exe
+
+    return exe
+
+
+def add_makefile_extras(makefile, extra_include_dirs, extra_lib_dirs, extra_libs):
+    """Add any extra include or library directories or libraries to a makefile.
+
+    makefile is the makefile.
+    extra_include_dirs is the list of extra include directories.
+    extra_lib_dirs is the list of extra library directories.
+    extra_libs is the list of extra libraries.
+    """
+    if extra_include_dirs:
+        makefile.extra_include_dirs.extend(extra_include_dirs)
+
+    if extra_lib_dirs:
+        makefile.extra_lib_dirs.extend(extra_lib_dirs)
+
+    if extra_libs:
+        makefile.extra_libs.extend(extra_libs)
+
+
+def check_vendorid():
+    """See if the VendorID library and include file can be found.
+    """
+    if opts.vendorcheck:
+        if os.access(os.path.join(opts.vendincdir, "vendorid.h"), os.F_OK):
+            if glob.glob(os.path.join(opts.vendlibdir, "*vendorid*")):
+                sipconfig.inform("The VendorID package was found.")
+            else:
+                opts.vendorcheck = 0
+                sipconfig.inform("The VendorID library could not be found in "
+                                 "%s and so signed interpreter checking will "
+                                 "be disabled. If the VendorID library is "
+                                 "installed then use the -m argument to "
+                                 "explicitly specify the correct "
+                                 "directory." % opts.vendlibdir)
+        else:
+            opts.vendorcheck = 0
+            sipconfig.inform("vendorid.h could not be found in %s and so "
+                             "signed interpreter checking will be disabled. "
+                             "If the VendorID package is installed then use "
+                             "the -l argument to explicitly specify the "
+                             "correct directory." % opts.vendincdir)
+
+
+def get_command_stdout(cmd, and_stderr=False, envvars=None):
+    """Return stdout (and optionally stderr) from the given command.
+    """
+    if envvars is not None:
+        env = os.environ.copy()
+        env.update(envvars)
+    else:
+        env = None
+
+    try:
+        import subprocess
+    except ImportError:
+        if and_stderr:
+            _, sout = os.popen4(cmd)
+        else:
+            _, sout, _ = os.popen3(cmd)
+
+        return sout
+
+    if and_stderr:
+        stderr = subprocess.STDOUT
+    else:
+        stderr = subprocess.PIPE
+
+    p = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE,
+            stdout=subprocess.PIPE, stderr=stderr, env=env)
+
+    return p.stdout
+
+
+def check_dbus():
+    """See if the DBus support module should be built.
+    """
+    sipconfig.inform("Checking to see if the dbus support module should be built...")
+
+    sout = get_command_stdout("pkg-config --cflags-only-I --libs dbus-1")
+    iflags = sout.read().strip()
+
+    if not iflags:
+        sipconfig.inform("DBus v1 does not seem to be installed.")
+        return
+
+    if sys.hexversion >= 0x03000000:
+        iflags = iflags.decode()
+
+    for f in iflags.split():
+        if f.startswith("-I"):
+            dbusincdirs.append(f[2:])
+        elif f.startswith("-L"):
+            dbuslibdirs.append(f[2:])
+        elif f.startswith("-l"):
+            dbuslibs.append(f[2:])
+
+    try:
+        import dbus.mainloop
+    except:
+        sipconfig.inform("The Python dbus module doesn't seem to be installed.")
+        return
+
+    global pydbusmoddir
+    pydbusmoddir = dbus.mainloop.__path__[0]
+
+    # Try and find dbus-python.h.  We don't use pkg-config because it is broken
+    # for dbus-python (at least for versions up to and including v0.81.0).
+    # Instead we look where DBus itself is installed - which in most cases will
+    # be where dbus-python is also installed.
+    if opts.pydbusincdir:
+        dlist = [opts.pydbusincdir]
+    else:
+        dlist = dbusincdirs
+
+    for d in dlist:
+        if os.access(os.path.join(d, "dbus", "dbus-python.h"), os.F_OK):
+            if d not in dbusincdirs:
+                dbusincdirs.append(d)
+
+            break
+    else:
+        sipconfig.inform("dbus/dbus-python.h could not be found and so the "
+                         "DBus support module will be disabled. If "
+                         "dbus-python v0.80 or later is installed then use "
+                         "the -s argument to explicitly specify the directory "
+                         "containing dbus/dbus-python.h.")
+        pydbusmoddir = None
+
+
+def check_module(mname, incfile, test, extra_include_dirs=None, extra_lib_dirs=None, extra_libs=None):
+    """See if a module can be built and, if so, add it to the global list of
+    modules.
+
+    mname is the name of the module.
+    incfile is the name of the include file needed for the test.
+    test is a C++ statement being used for the test.
+    extra_include_dirs is an optional list of extra include directories.
+    extra_lib_dirs is an optional list of extra library directories.
+    extra_libs is an optional list of extra libraries.
+    """
+    # Check that the module is enabled if we are not automatically enabling all
+    # modules.
+    if len(opts.enabled) > 0 and mname not in opts.enabled:
+        return
+
+    # Check the module's main .sip file exists.
+    if os.access(os.path.join(src_dir, "sip", mname, mname + "mod.sip"), os.F_OK):
+        sipconfig.inform("Checking to see if the %s module should be built..." % mname)
+
+        if check_api(incfile, test, mname, extra_include_dirs=extra_include_dirs, extra_lib_dirs=extra_lib_dirs, extra_libs=extra_libs):
+            pyqt_modules.append(mname)
+
+
+def check_api(incfile, test, mname, extra_include_dirs=None, extra_lib_dirs=None, extra_libs=None):
+    """Return non-zero if a class is available.
+
+    incfile is the name of the include file needed for the test.
+    test is a C++ statement being used for the test.
+    mname is the name of the module.
+    extra_include_dirs is an optional list of extra include directories.
+    extra_lib_dirs is an optional list of extra library directories.
+    extra_libs is an optional list of extra libraries.
+    """
+    # We use a module specific name to avoid a potential problem on Windows
+    # where the operating system doesn't delete previous tests quickly enough.
+    cfgtest = "cfgtest_%s.cpp" % mname
+
+    f = open(cfgtest, "w")
+
+    f.write("""#include <%s>
+
+int main(int, char **)
+{
+    %s;
+}
+""" % (incfile, test))
+
+    f.close()
+
+    return compile_qt_program(cfgtest, mname,
+            extra_include_dirs=extra_include_dirs,
+            extra_lib_dirs=extra_lib_dirs, extra_libs=extra_libs)
+
+
+def set_sip_flags(pyqt):
+    """Set the SIP platform, version and feature flags.
+
+    pyqt is the configuration instance.
+    """
+    # If we don't check for signed interpreters, we exclude the 'VendorID'
+    # feature
+    if not opts.vendorcheck:
+        qt_sip_flags.append("-x")
+        qt_sip_flags.append("VendorID")
+
+    if not opts.with_deprecated:
+        qt_sip_flags.append("-x")
+        qt_sip_flags.append("PyQt_Deprecated_5_0")
+
+    # Handle the platform tag.
+    if sys.platform == 'win32':
+        plattag = "WS_WIN"
+    elif sys.platform == "darwin":
+        if "__USE_WS_X11__" in sipcfg.build_macros()["DEFINES"]:
+            plattag = "WS_X11"
+        else:
+            plattag = "WS_MACX"
+    else:
+        plattag = "WS_X11"
+
+    qt_sip_flags.append("-t")
+    qt_sip_flags.append(plattag)
+
+    # Handle the Qt version tag.
+    verstag = sipconfig.version_to_sip_tag(qt_version, pyqt.qt_version_tags(), "Qt")
+
+    # Handle any feature flags.
+    for xf in qt_xfeatures:
+        qt_sip_flags.append("-x")
+        qt_sip_flags.append(xf)
+
+    if verstag:
+        qt_sip_flags.append("-t")
+        qt_sip_flags.append(verstag)
+
+    # Handle the version specific Python features.
+    if sipcfg.py_version < 0x020400:
+        qt_sip_flags.append("-x")
+        qt_sip_flags.append("Py_DateTime")
+
+    if sipcfg.py_version < 0x030000:
+        qt_sip_flags.append("-x")
+        qt_sip_flags.append("Py_v3")
+
+    # There is an issue creating QObjects while the GIL is held causing
+    # deadlocks in multi-threaded applications.  We don't fully understand this
+    # yet so we make sure we avoid the problem by always releasing the GIL.
+    qt_sip_flags.append("-g")
+
+
+def needed_qt_libs(mname, qt_libs):
+    """Add any additional Qt libraries needed by a module to an existing list.
+
+    mname is the name of the module.
+    qt_libs is the current list of libraries.
+    """
+
+    # The dependencies between the different Qt libraries.  The order within
+    # each list is important.  Note that this affects the include directories
+    # as well as the libraries.
+    LIB_DEPS = {
+        "QtCore": [],
+        "QtDBus": ["QtCore"],
+        "QtDeclarative": ["QtNetwork", "QtGui"],
+        "QtGui": ["QtCore"],
+        "QtHelp": ["QtGui"],
+        "QtMultimedia": ["QtGui"],
+        "QtNetwork": ["QtCore"],
+        "QtOpenGL": ["QtGui"],
+        "QtScript": ["QtCore"],
+        "QtScriptTools": ["QtScript", "QtGui", "QtCore"],
+        "QtSql": ["QtGui"],
+        "QtSvg": ["QtGui"],
+        "QtTest": ["QtGui"],
+        "QtWebKit": ["QtNetwork", "QtGui"],
+        "QtXml": ["QtCore"],
+        "QtXmlPatterns": ["QtNetwork", "QtCore"],
+        "phonon": ["QtGui"],
+        "QtAssistant": ["QtNetwork", "QtGui"],
+        "QtDesigner": ["QtGui"],
+        "QAxContainer": ["QtGui"]
+    }
+
+    # Handle the dependencies first.
+    for d in LIB_DEPS[mname]:
+        needed_qt_libs(d, qt_libs)
+
+    if mname not in qt_libs:
+        qt_libs.insert(0, mname)
+
+
+def mk_clean_dir(name, clean=1):
+    """Create a clean (ie. empty) directory.
+
+    name is the name of the directory.
+    """
+    if clean:
+        try:
+            shutil.rmtree(name)
+        except:
+            pass
+
+    try:
+        os.makedirs(name)
+    except:
+        if clean:
+            sipconfig.error("Unable to create the %s directory." % name)
+
+
+def generate_code(mname, extra_include_dirs=None, extra_lib_dirs=None, extra_libs=None, extra_sip_flags=None):
+    """Generate the code for a module.
+
+    mname is the name of the module to generate the code for.
+    extra_include_dirs is an optional list of additional directories to add to
+    the list of include directories.
+    extra_lib_dirs is an optional list of additional directories to add to the
+    list of library directories.
+    extra_libs is an optional list of additional libraries to add to the list
+    of libraries.
+    extra_sip_flags is an optional list of additional flags to pass to SIP.
+    """
+    sipconfig.inform("Generating the C++ source for the %s module..." % mname)
+
+    mk_clean_dir(mname)
+
+    # Work out what Qt libraries need to be linked against and how SIP is
+    # supposed to handle the consolidated module and its components.
+    cons_args = []
+
+    if opts.bigqt:
+        if mname == "_qt":
+            qt_libs = []
+
+            for m in pyqt_modules:
+                needed_qt_libs(m, qt_libs)
+        else:
+            if mname != "Qt":
+                cons_args.append("-p")
+                cons_args.append("PyQt4._qt")
+
+            qt_libs = 0
+    else:
+        if mname == "Qt":
+            qt_libs = 0
+        else:
+            qt_libs = []
+            needed_qt_libs(mname, qt_libs)
+
+    # Build the SIP command line.
+    argv = ['"' + sipcfg.sip_bin + '"', '-w']
+
+    if opts.no_timestamp:
+        argv.append("-T")
+
+    if not opts.no_docstrings:
+        argv.append("-o");
+
+    if opts.prot_is_public:
+        argv.append("-P");
+
+    argv.extend(qt_sip_flags)
+    argv.extend(cons_args)
+
+    if extra_sip_flags:
+        argv.extend(extra_sip_flags)
+
+    if opts.concat:
+        argv.append("-j")
+        argv.append(str(opts.split))
+
+    if opts.tracing:
+        argv.append("-r")
+
+    if mname not in ("Qt", "_qt", "Qsci"):
+        argv.append("-a")
+        argv.append(mname + ".api")
+
+    # Pass the absolute pathname so that #line files are absolute.
+    argv.append("-c")
+    argv.append(os.path.abspath(mname))
+
+    buildfile = os.path.join(mname, mname + ".sbf")
+    argv.append("-b")
+    argv.append(buildfile)
+
+    argv.append("-I")
+    argv.append(os.path.join(src_dir, "sip"))
+
+    # Add the name of the .sip file keeping in mind SIP assumes POSIX style
+    # path separators.  The Qt module's .sip file is generated by this script
+    # and so will be in a different place if this is an out-of-tree build.
+    if mname == "Qt":
+        argv.append("sip/Qt/Qtmod.sip")
+    else:
+        drive, path = os.path.splitdrive(src_dir)
+        parts = path.split(os.pathsep)
+        parts.extend(["sip", mname, mname + "mod.sip"])
+        argv.append(drive + "/".join(parts))
+
+    cmd = " ".join(argv)
+
+    if opts.verbose:
+        sys.stdout.write(cmd + "\n")
+
+    os.system(cmd)
+
+    # Check the result.
+    if not os.access(buildfile, os.F_OK):
+        sipconfig.error("Unable to create the C++ code.")
+
+    # Generate the Makefile.
+    sipconfig.inform("Creating the Makefile for the %s module..." % mname)
+
+    installs = []
+
+    if opts.install_sipfiles:
+        sipfiles = []
+
+        sipdir = os.path.join("sip", mname)
+        if mname != "Qt":
+            sipdir = os.path.join(src_dir, sipdir)
+            rel_sipdir = sipdir
+        else:
+            rel_sipdir = os.path.join("..", sipdir)
+
+        for s in glob.glob(os.path.join(sipdir, "*.sip")):
+            sipfiles.append(os.path.join(rel_sipdir, os.path.basename(s)))
+
+        installs.append([sipfiles, os.path.join(opts.pyqtsipdir, mname)])
+
+    opengl = (mname == "QtOpenGL")
+
+    makefile = sipconfig.SIPModuleMakefile(
+        configuration=sipcfg,
+        build_file=mname + ".sbf",
+        dir=mname,
+        install_dir=pyqt_modroot,
+        installs=installs,
+        qt=qt_libs,
+        opengl=opengl,
+        warnings=1,
+        static=opts.static,
+        debug=opts.debug,
+        universal=sipcfg.universal,
+        arch=sipcfg.arch,
+        prot_is_public=opts.prot_is_public,
+        deployment_target=sipcfg.deployment_target
+    )
+
+    add_makefile_extras(makefile, extra_include_dirs, extra_lib_dirs, extra_libs)
+
+    if qt_version >= 0x050000 and opts.with_deprecated:
+        # The name of this macro is very confusing.
+        makefile.extra_defines.append('QT_DISABLE_DEPRECATED_BEFORE=0x040900')
+
+    makefile.generate()
+
+
+def fix_license(name):
+    """ Fix the license file, if there is one, so that it conforms to the SIP
+    v5 syntax.
+    """
+
+    try:
+        f = open(name, "r")
+    except IOError:
+        sipconfig.error("Failed to open license file %s." % name)
+
+    f5 = open(name + "5", "w")
+
+    for line in f:
+        if line.startswith("%License"):
+            anno_start = line.find("/")
+            anno_end = line.rfind("/")
+
+            if anno_start < 0 or anno_end < 0 or anno_start == anno_end:
+                sipconfig.error("%s has missing annotations." % name)
+
+            annos = line[anno_start + 1:anno_end].split(", ")
+            annos5 = [anno[0].lower() + anno[1:] for anno in annos]
+
+            f5.write("%License(")
+            f5.write(", ".join(annos5))
+            f5.write(")\n")
+        else:
+            f5.write(line)
+
+    f5.close()
+    f.close()
+
+
+def check_license():
+    """Handle the validation of the PyQt license.
+    """
+    try:
+        import license
+        ltype = license.LicenseType
+        lname = license.LicenseName
+
+        try:
+            lfile = license.LicenseFile
+        except AttributeError:
+            lfile = None
+    except ImportError:
+        ltype = None
+
+    if ltype is None:
+        ltype = "GPL"
+        lname = "GNU General Public License"
+        lfile = "pyqt-gpl.sip"
+
+    sipconfig.inform("This is the %s version of PyQt %s (licensed under the %s) for Python %s on %s." % (ltype, pyqt_version_str, lname, sys.version.split()[0], sys.platform))
+
+    # Common checks.
+    if qt_licensee and ltype == "GPL":
+        sipconfig.error("This version of PyQt and the commercial version of Qt have incompatible licenses.")
+
+    # Confirm the license if not already done.
+    if not opts.license_confirmed:
+        if ltype == "GPL":
+            loptions = """
+Type '2' to view the GPL v2 license.
+Type '3' to view the GPL v3 license.
+"""
+        else:
+            loptions = """
+Type 'L' to view the license.
+"""
+
+        sys.stdout.write(loptions)
+        sys.stdout.write("""Type 'yes' to accept the terms of the license.
+Type 'no' to decline the terms of the license.
+
+""")
+
+        while 1:
+            sys.stdout.write("Do you accept the terms of the license? ")
+            sys.stdout.flush()
+
+            try:
+                resp = sys.stdin.readline()
+            except KeyboardInterrupt:
+                raise SystemExit
+            except:
+                resp = ""
+
+            resp = resp.strip().lower()
+
+            if resp == "yes":
+                break
+
+            if resp == "no":
+                sys.exit(0)
+
+            if ltype == "GPL":
+                if resp == "2":
+                    os.system("more LICENSE.GPL2")
+                elif resp == "3":
+                    os.system("more LICENSE.GPL3")
+            else:
+                if resp == "l":
+                    os.system("more LICENSE")
+
+    # Check that the license file exists and fix its syntax.
+    lfile_path = os.path.join(src_dir, "sip", lfile)
+
+    if os.access(lfile_path, os.F_OK):
+        sipconfig.inform("Found the license file %s." % lfile)
+        fix_license(lfile_path)
+    else:
+        sipconfig.error("Please copy the license file %s to the sip directory." % lfile)
+
+
+def get_build_macros(overrides):
+    """Return the dictionary of platform specific build macros from the Qt
+    installation.  Return None if any of the overrides was invalid.
+
+    overrides is a list of macros overrides from the user.
+    """
+    global qt_macx_spec
+
+    # Get the name of the qmake configuration file to take the macros from.
+    if "QMAKESPEC" in list(os.environ.keys()):
+        fname = os.environ["QMAKESPEC"]
+
+        if not os.path.dirname(fname):
+            qt_macx_spec = fname
+            fname = os.path.join(qt_datadir, "mkspecs", fname)
+    elif sys.platform == "darwin":
+        # The Qt Mac binary installer defaults to xcode which we don't want.
+        # Use Qt5's macx-clang if it is available, otherwise fall back to
+        # macx-g++.
+        fname = os.path.join(qt_datadir, "mkspecs", "macx-clang")
+        if os.path.isdir(fname):
+            qt_macx_spec = "macx-clang"
+        else:
+            fname = os.path.join(qt_datadir, "mkspecs", "macx-g++")
+            qt_macx_spec = "macx-g++"
+    else:
+        fname = os.path.join(qt_datadir, "mkspecs", "default")
+
+    fname = os.path.join(fname, "qmake.conf")
+
+    if not os.access(fname, os.F_OK):
+        sipconfig.error("Unable to find the qmake configuration file %s. Use the QMAKESPEC environment variable to specify the correct platform." % fname)
+
+    # Add the Qt specific macros to the default.
+    names = list(sipcfg.build_macros().keys())
+    names.append("INCDIR_QT")
+    names.append("LIBDIR_QT")
+    names.append("MOC")
+
+    properties = {
+        "QT_INSTALL_BINS":      qt_bindir,
+        "QT_INSTALL_HEADERS":   qt_incdir,
+        "QT_INSTALL_LIBS":      qt_libdir
+    }
+
+    macros = sipconfig.parse_build_macros(fname, names, overrides, properties)
+
+    if macros is None:
+        return None
+
+    # Qt5 doesn't seem to support the specific macros so add them if they are
+    # missing.
+    if macros.get("INCDIR_QT", "") == "":
+        macros["INCDIR_QT"] = qt_incdir
+
+    if macros.get("LIBDIR_QT", "") == "":
+        macros["LIBDIR_QT"] = qt_libdir
+
+    if macros.get("MOC", "") == "":
+        default_moc = os.path.join(qt_bindir, "moc")
+        if sys.platform == 'win32':
+            default_moc += ".exe"
+
+        macros["MOC"] = default_moc
+
+    return macros
+
+
+def check_qt_installation(macros):
+    """Check the Qt installation and get the version number and edition and
+    return the configuration instance.
+
+    macros is the dictionary of build macros.
+    """
+    # Check the Qt version number.
+    if qt_version < 0x040100:
+        sipconfig.error("PyQt v4 requires Qt v4.1.0 or later.")
+
+    # Starting with v4.7, Qt (when built with MinGW) assumes that stack frames
+    # are 16 byte aligned because it uses SSE.  However the Python Windows
+    # installers are built with 4 byte aligned stack frames.  We therefore need
+    # to tweak the g++ flags to deal with it.
+    if sipcfg.platform == 'win32-g++' and qt_version >= 0x040700:
+        macros['CFLAGS'] += ' -mstackrealign'
+        macros['CXXFLAGS'] += ' -mstackrealign'
+
+    # Work out how Qt was built on MacOS.
+    if sys.platform == "darwin":
+        if os.access(os.path.join(qt_libdir, "QtCore.framework"), os.F_OK):
+            global qt_framework
+            qt_framework = 1
+
+    # Get the Makefile generator.
+    generator = macros["MAKEFILE_GENERATOR"]
+
+    # We haven't yet factored out sipconfig's knowledge of how to build Qt
+    # binaries and it is expecting to find these in the configuration when it
+    # generates the Makefiles.
+    sipcfg.qt_version = qt_version
+    sipcfg.qt_edition = qt_edition
+    sipcfg.qt_winconfig = qt_shared
+    sipcfg.qt_framework = qt_framework
+    sipcfg.qt_threaded = 1
+    sipcfg.qt_dir = qt_dir
+    sipcfg.qt_lib_dir = qt_libdir
+
+    return ConfigurePyQt4(generator)
+
+
+def fix_qmake_args(args=""):
+    """Make any platform specific adjustments to the arguments passed to qmake.
+    """
+    if sys.platform == "darwin":
+        # The Qt binary installer has macx-xcode as the default.
+        args = "-spec %s %s" % (qt_macx_spec, args)
+
+    return args
+
+
+def get_qt_configuration():
+    """Set the qt_dir, qt_incdir, qt_libdir, qt_bindir, qt_datadir,
+    qt_pluginsdir and qt_xfeatures globals for the Qt installation.
+    """
+    sipconfig.inform("Determining the layout of your Qt installation...")
+
+    # The file names we will use to get the directory information.
+    app = "qtdirs"
+    pro_file = app + ".pro"
+    make_file = app + ".mk"
+    make_target = ""
+    cpp_file = app + ".cpp"
+    out_file = app + ".out"
+    qmake_args = fix_qmake_args("-o " + make_file)
+
+    if sys.platform == 'win32':
+        if opts.debug:
+            exe_file = os.path.join("debug", app + ".exe")
+            make_target = " debug"
+        else:
+            exe_file = os.path.join("release", app + ".exe")
+            make_target = " release"
+    elif sys.platform == "darwin":
+        exe_file = os.path.join(app + ".app", "Contents", "MacOS", app)
+    else:
+        exe_file = os.path.join(".", app)
+
+    # Generate the qmake project file.
+    f = open(pro_file, "w")
+
+    if sipcfg.arch:
+        f.write(arch_config())
+
+    f.write(
+"""QT = core
+# This is for certain broken Linux distros and is needed to make sure that
+# QT_SHARED is properly defined.
+CONFIG += link_prl
+TARGET = %s
+SOURCES = %s
+""" % (app, cpp_file))
+
+    f.close()
+
+    # Generate the source code.
+    f = open(cpp_file, "w")
+
+    f.write(
+"""#include <QCoreApplication>
+#include <QFile>
+#include <QLibraryInfo>
+#include <QTextStream>
+
+// These seem to be missing from the Qt v5 beta.
+#if !defined(QT_EDITION_DESKTOP)
+#define QT_EDITION_DESKTOP      8
+#endif
+#if !defined(QT_EDITION_OPENSOURCE)
+#define QT_EDITION_OPENSOURCE   8
+#endif
+
+int main(int argc, char **argv)
+{
+    QCoreApplication app(argc, argv);
+    QFile outf("%s");
+
+    if (!outf.open(QIODevice::WriteOnly|QIODevice::Truncate|QIODevice::Text))
+        return 1;
+
+    QTextStream out(&outf);
+
+    out << QLibraryInfo::location(QLibraryInfo::PrefixPath) << '\\n';
+    out << QLibraryInfo::location(QLibraryInfo::HeadersPath) << '\\n';
+    out << QLibraryInfo::location(QLibraryInfo::LibrariesPath) << '\\n';
+    out << QLibraryInfo::location(QLibraryInfo::BinariesPath) << '\\n';
+    out << QLibraryInfo::location(QLibraryInfo::DataPath) << '\\n';
+    out << QLibraryInfo::location(QLibraryInfo::PluginsPath) << '\\n';
+
+    out << QT_VERSION << '\\n';
+    out << QT_EDITION << '\\n';
+
+    out << QLibraryInfo::licensee() << '\\n';
+
+#if defined(QT_SHARED) || defined(QT_DLL)
+    out << "shared\\n";
+#else
+    out << "\\n";
+#endif
+
+    // Determine which features should be disabled.
+
+#if defined(QT_NO_ACCESSIBILITY)
+    out << "PyQt_Accessibility\\n";
+#endif
+
+#if defined(QT_NO_SESSIONMANAGER)
+    out << "PyQt_SessionManager\\n";
+#endif
+
+#if defined(QT_NO_STATUSTIP)
+    out << "PyQt_StatusTip\\n";
+#endif
+
+#if defined(QT_NO_TOOLTIP)
+    out << "PyQt_ToolTip\\n";
+#endif
+
+#if defined(QT_NO_WHATSTHIS)
+    out << "PyQt_WhatsThis\\n";
+#endif
+
+#if defined(QT_NO_OPENSSL)
+    out << "PyQt_OpenSSL\\n";
+#endif
+
+#if defined(QT_NO_SIZEGRIP)
+    out << "PyQt_SizeGrip\\n";
+#endif
+
+#if defined(QT_NO_SYSTEMTRAYICON)
+    out << "PyQt_SystemTrayIcon\\n";
+#endif
+
+#if defined(QT_NO_PRINTDIALOG)
+    out << "PyQt_PrintDialog\\n";
+#endif
+
+#if defined(QT_NO_PRINTER)
+    out << "PyQt_Printer\\n";
+#endif
+
+#if defined(QT_NO_PRINTPREVIEWDIALOG)
+    out << "PyQt_PrintPreviewDialog\\n";
+#endif
+
+#if defined(QT_NO_PRINTPREVIEWWIDGET)
+    out << "PyQt_PrintPreviewWidget\\n";
+#endif
+
+#if defined(QT_NO_RAWFONT)
+    out << "PyQt_RawFont\\n";
+#endif
+
+#if !defined(QT3_SUPPORT) || QT_VERSION >= 0x040200
+    out << "PyQt_NoPrintRangeBug\\n";
+#endif
+
+#if defined(QT_OPENGL_ES)
+    out << "PyQt_NoOpenGLES\\n";
+#endif
+
+    if (sizeof (qreal) != sizeof (double))
+        out << "PyQt_qreal_double\\n";
+
+    return 0;
+}
+""" % out_file)
+
+    f.close()
+
+    # Create the makefile, first making sure it doesn't already exist.
+    remove_file(make_file)
+    run_command("%s %s %s" % (opts.qmake, qmake_args, pro_file))
+
+    if not os.access(make_file, os.F_OK):
+        sipconfig.error("%s failed to create a makefile. %s" % (opts.qmake, MSG_CHECK_QMAKE))
+
+    # Try and work out the name of make.
+    if sipcfg.platform.startswith("win32-msvc"):
+        make = "nmake"
+    elif sipcfg.platform == "win32-borland":
+        make = "bmake"
+    elif sipcfg.platform == "win32-g++":
+        make = "mingw32-make"
+    else:
+        make = "make"
+
+    # Create the executable, first making sure it doesn't exist.
+    remove_file(exe_file)
+    run_command("%s -f %s%s" % (make, make_file, make_target))
+
+    if not os.access(exe_file, os.X_OK):
+        sipconfig.error("Failed to determine the layout of your Qt installation. Try again using the --verbose flag to see more detail about the problem.")
+
+    # Create the output file, first making sure it doesn't exist.
+    remove_file(out_file)
+    run_command(exe_file)
+
+    if not os.access(out_file, os.F_OK):
+        sipconfig.error("%s failed to create %s. Make sure your Qt installation is correct." % (exe_file, out_file))
+
+    # Read the directories.
+    f = open(out_file, "r")
+    lines = f.read().strip().split("\n")
+    f.close()
+
+    global qt_dir, qt_incdir, qt_libdir, qt_bindir, qt_datadir, qt_pluginsdir
+    global qt_version, qt_edition, qt_licensee, qt_shared, qt_xfeatures
+
+    qt_dir = lines[0]
+    qt_incdir = lines[1]
+    qt_libdir = lines[2]
+    qt_bindir = lines[3]
+    qt_datadir = lines[4]
+    qt_pluginsdir = lines[5]
+    qt_version = lines[6]
+    qt_edition = lines[7]
+    qt_licensee = lines[8]
+    qt_shared = lines[9]
+    qt_xfeatures = lines[10:]
+
+    if opts.assume_shared:
+        qt_shared = "shared"
+
+    # 'Nokia' is the value that is used by Maemo's version of Qt.
+    if qt_licensee in ('Open Source', 'Nokia'):
+        qt_licensee = None
+
+    try:
+        qt_version = int(qt_version)
+    except ValueError:
+        sipconfig.error("QT_VERSION should be a number but \"%s\" was found." % qt_version)
+
+    try:
+        qt_edition = int(qt_edition)
+    except ValueError:
+        sipconfig.error("QT_EDITION should be a number but \"%s\" was found." % qt_edition)
+
+    # Now convert the edition to a descriptive string.  The order of testing is
+    # important.
+    if qt_edition & 0x200:
+        # It has ActiveQt.
+        qt_edition = "Desktop"
+
+        # ActiveQt became part of the open source version in v4.5.2.
+        if qt_version >= 0x040502 and qt_licensee is None:
+            qt_edition = "free"
+    elif qt_edition & 0x008:
+        # It has OpenGL.
+        qt_edition = "free"
+    elif qt_edition & 0x002:
+        # It has GUI.
+        qt_edition = "Desktop Light"
+    else:
+        qt_edition = "Console"
+
+    if qt_shared:
+        if opts.staticplugins:
+            sipconfig.inform("Static plugins are disabled because Qt has been built as shared libraries.")
+            opts.staticplugins = []
+    else:
+        if opts.static or opts.bigqt:
+            pass
+        else:
+            sipconfig.error("Qt has been built as static libraries so either the -g or -k argument should be used.")
+
+
+def main():
+    """Create the configuration module module.
+    """
+    # Check SIP is new enough.
+    if sipcfg.sip_version < sip_min_version:
+        sipconfig.error("This version of PyQt requires SIP v%s or later" % sipconfig.version_to_string(sip_min_version))
+
+    global opts
+
+    # Parse the command line.
+    p = create_optparser()
+    opts, args = p.parse_args()
+
+    # Provide defaults for platform-specific options.
+    if sys.platform == 'win32':
+        opts.qmake = find_default_qmake()
+        opts.prot_is_public = False
+
+    if not opts.qmake:
+        sipconfig.error(MSG_CHECK_QMAKE)
+
+    # Where the modules will be placed.
+    global pyqt_modroot
+    pyqt_modroot = os.path.join(opts.pyqtmoddir, "PyQt4")
+
+    # When building static libraries, signed interpreter checking makes no
+    # sense.
+    if opts.vendorcheck and opts.static:
+        sipconfig.error("Using the VendorID package when building static libraries makes no sense.")
+
+    # Get the details of the Qt installation.
+    get_qt_configuration()
+
+    # Provide some defaults that are based on the Qt configuration.
+    if not opts.plugindir:
+        opts.plugindir = qt_pluginsdir
+
+    if opts.qscidir:
+        # An explicit directory implies installing the API file.
+        opts.api = True
+    else:
+        opts.qscidir = os.path.join(qt_datadir, "qsci")
+
+        if opts.api is None:
+            # Install the API file if the default directory exists.
+            opts.api = os.path.isdir(opts.qscidir)
+
+    # Replace the existing build macros with the ones from the Qt installation.
+    macros = get_build_macros(args)
+
+    if macros is None:
+        p.print_help()
+        sys.exit(2)
+
+    sipcfg.set_build_macros(macros)
+
+    # Check Qt is what we need.
+    pyqt = check_qt_installation(macros)
+
+    # Check the licenses are compatible.
+    check_license()
+
+    # Check which modules to build.
+    pyqt.check_modules()
+
+    # Check for the VendorID package.
+    check_vendorid()
+
+    # Set the SIP platform, version and feature flags.
+    set_sip_flags(pyqt)
+
+    # Tell the user what's been found.
+    inform_user()
+
+    # Generate the code.
+    pyqt.code()
+
+    # Create the additional Makefiles.
+    sipconfig.inform("Creating top level Makefile...")
+
+    installs=[(pyqt.module_installs(), pyqt_modroot)]
+
+    if opts.api:
+        installs.append(("PyQt4.api", os.path.join(opts.qscidir, "api", "python")))
+
+    xtra_modules = ["Qt"]
+
+    if opts.bigqt:
+        xtra_modules.append("_qt")
+
+        if opts.mwg_qsci_dir:
+            xtra_modules.append("Qsci")
+
+        if opts.mwg_qwt_dir:
+            xtra_modules.append("Qwt5")
+
+    sipconfig.ParentMakefile(
+        configuration=sipcfg,
+        subdirs=pyqt.qpy_libs() + pyqt_modules + xtra_modules + pyqt.tools(),
+        installs=installs
+    ).generate()
+
+    # Install the configuration module.
+    create_config("pyqtconfig.py", os.path.join(src_dir, "pyqtconfig.py.in"),
+            macros)
+
+
+###############################################################################
+# The script starts here.
+###############################################################################
+
+if __name__ == "__main__":
+    try:
+        main()
+    except SystemExit:
+        raise
+    except:
+        sys.stderr.write(
+"""An internal error occured.  Please report all the output from the program,
+including the following traceback, to support@riverbankcomputing.com.
+""")
+        raise
diff --git a/package/pyqt/local_settings.py b/package/pyqt/local_settings.py
new file mode 100644
index 0000000..1aa8949
--- /dev/null
+++ b/package/pyqt/local_settings.py
@@ -0,0 +1,11 @@
+
+qt_configuration_profile = None
+
+extra_qt_configuration = [
+    "QT_NO_ACCESSIBILITY", # "QT_NO_CURSOR", "QT_NO_QWS_CURSOR",
+    "QT_NO_SESSIONMANAGER", "QT_QWS_SCREEN_COORDINATES", "QT_NO_RAW_FONT"
+    ]
+
+extra_pyqt_configuration = [
+    "PyQt_qreal_double", "PyQt_OpenSSL", "PyQt_RawFont"
+    ]
diff --git a/package/pyqt/mkconf.py b/package/pyqt/mkconf.py
new file mode 100644
index 0000000..b24e61d
--- /dev/null
+++ b/package/pyqt/mkconf.py
@@ -0,0 +1,453 @@
+#!/usr/bin/env python
+
+# install.py - Build and install Qt 4, SIP, Python and PyQt4 for Embedded Linux.
+# Copyright (C) 2009-2010 David Boddie <david@boddie.org.uk>
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+import os, popen2, sets, sys, getopt
+
+################################################################################
+# Set up some useful configuration settings.
+################################################################################
+
+def read_option(options, argv):
+
+    number = len(argv)
+    
+    for option in options:
+        try:
+            argv.remove(option)
+        except ValueError:
+            pass
+    
+    return len(argv) != number
+
+################################################################################
+# Define useful functions.
+################################################################################
+
+def mkdir(path, dir = None):
+
+    if dir:
+        path = os.path.join(path, dir)
+    if not os.path.exists(path):
+        os.mkdir(path)
+        print "Created", path, "directory."
+
+def chdir(path):
+    os.chdir(path)
+    print "Entered", path, "directory."
+    print
+
+def system(command, verbose = True):
+
+    if verbose:
+        print command
+    if os.system(command):
+        sys.exit(1)
+
+def prefix_join(*args):
+
+    # Prepend the DESTDIR installation prefix to the absolute path beginning
+    # with an absolute prefix path. We need to join these two directly instead
+    # of using the os.path module's join() function because that will not
+    # join absolute paths.
+    dest_dir = env.get("DESTDIR", "")
+    prefix_path = os.path.join(*args)
+    
+    if dest_dir.endswith(os.sep) or prefix_path.startswith(os.sep):
+        return dest_dir + prefix_path
+    else:
+        return dest_dir + os.sep + prefix_path
+
+
+################################################################################
+# Build PyQt4 for Embedded Linux.
+################################################################################
+
+# Qt features with an empty PyQt feature are internal Qt features that should
+# have no effect on the PyQt API.
+
+conversion_dict = {
+    "QT_NO_ACCESSIBILITY": "PyQt_Accessibility",
+    "QT_NO_ACTION": "PyQt_Action",
+    "QT_NO_ANIMATION": "PyQt_Animation",
+    "QT_NO_BIG_CODECS": "PyQt_BigCodecs",                       # internal
+    "QT_NO_BUTTONGROUP": "PyQt_ButtonGroup",
+    "QT_NO_CALENDARWIDGET": "PyQt_CalendarWidget",
+    "QT_NO_CLIPBOARD": "PyQt_Clipboard",
+    "QT_NO_CODECS": "PyQt_Codecs",                              # internal
+    "QT_NO_COLORDIALOG": "PyQt_ColorDialog",
+    "QT_NO_COLORNAMES": "",
+    "QT_NO_COLUMNVIEW": "PyQt_ColumnView",
+    "QT_NO_COMBOBOX": "PyQt_ComboBox",
+    "QT_NO_COMPLETER": "PyQt_Completer",
+    "QT_NO_CONCURRENT": "PyQt_Concurrent",                      # not wrapped
+    "QT_NO_CONTEXTMENU": "PyQt_ContextMenu",
+    "QT_NO_COP": "PyQt_COP",                                    # not wrapped
+    "QT_NO_CSSPARSER": "PyQt_CSSParser",
+    "QT_NO_CUPS": "",                                           # internal
+    "QT_NO_CURSOR": "PyQt_Cursor",
+    "QT_NO_DBUS": "PyQt_DBus",
+    "QT_NO_DATASTREAM": "PyQt_DataStream",
+    "QT_NO_DATAWIDGETMAPPER": "PyQt_DataWidgetMapper",
+    "QT_NO_DATESTRING": "PyQt_DateString",
+    "QT_NO_DATETIMEEDIT": "PyQt_DateTimeEdit",
+    "QT_NO_DESKTOPSERVICES": "PyQt_DesktopServices",
+    "QT_NO_DIAL": "PyQt_Dial",
+    "QT_NO_DIRECTPAINTER": "",                                  # internal
+    "QT_NO_DIRMODEL": "PyQt_DirModel",
+    "QT_NO_DOCKWIDGET": "PyQt_DockWidget",
+    "QT_NO_DOM": "PyQt_DOMClasses",
+    "QT_NO_DRAGANDDROP": "PyQt_DragAndDrop",
+    "QT_NO_EFFECTS": "",                                        # internal
+    "QT_NO_ERRORMESSAGE": "PyQt_ErrorMessage",
+    "QT_NO_FILEDIALOG": "PyQt_FileDialog",
+    "QT_NO_FILESYSTEMMODEL": "PyQt_FileSystemModel",
+    "QT_NO_FILESYSTEMWATCHER": "PyQt_FileSystemWatcher",
+    "QT_NO_FONTCOMBOBOX": "PyQt_FontComboBox",
+    "QT_NO_FONTDIALOG": "PyQt_FontDialog",
+    "QT_NO_FREETYPE": "",                                       # internal
+    "QT_NO_FSCOMPLETER": "PyQt_FSCompleter",
+    "QT_NO_FTP": "PyQt_FTP",
+    "QT_NO_QFUTURE": "PyQt_Future",
+    "QT_NO_GESTURES": "PyQt_Gestures",
+    "QT_NO_GRAPHICSEFFECT": "PyQt_GraphicsEffect",
+    "QT_NO_GRAPHICSSVGITEM": "PyQt_GraphicsSVGItem",
+    "QT_NO_GRAPHICSVIEW": "PyQt_GraphicsView",
+    "QT_NO_GROUPBOX": "PyQt_GroupBox",
+    "QT_NO_HOSTINFO": "PyQt_HostInfo",          # May be missing a test in Qt.
+    "QT_NO_HTTP": "PyQt_HTTP",
+    "QT_NO_ICON": "PyQt_Icon",                  # May be missing a test in Qt.
+    "QT_NO_IDENTITYPROXYMODEL": "PyQt_IdentityProxyModel",
+    "QT_NO_IM": "PyQt_IM",
+    "QT_NO_IMAGEFORMATPLUGIN": "PyQt_ImageFormatPlugin",
+    "QT_NO_IMAGEFORMAT_BMP": "PyQt_ImageFormat_BMP",
+    "QT_NO_IMAGEFORMAT_JPEG": "PyQt_ImageFormat_JPEG",
+    "QT_NO_IMAGEFORMAT_PNG": "PyQt_ImageFormat_PNG",
+    "QT_NO_IMAGEFORMAT_PPM": "PyQt_ImageFormat_PPM",
+    "QT_NO_IMAGEFORMAT_XBM": "PyQt_ImageFormat_XBM",
+    "QT_NO_IMAGEFORMAT_XPM": "PyQt_ImageFormat_XPM",
+    "QT_NO_IMAGE_HEURISTIC_MASK": "PyQt_Image_Heuristic_Mask",
+    "QT_NO_IMAGE_TEXT": "PyQt_Image_Text",
+    "QT_NO_INPUTDIALOG": "PyQt_InputDialog",
+    "QT_NO_ITEMVIEWS": "PyQt_ItemViews",
+    "QT_NO_LCDNUMBER": "PyQt_LCDNumber",
+    "QT_NO_LIBRARY": "PyQt_Library",
+    "QT_NO_LINEEDIT": "PyQt_LineEdit",
+    "QT_NO_LINEEDITMENU": "PyQt_LineEditMenu",
+    "QT_NO_LISTVIEW": "PyQt_ListView",
+    "QT_NO_LISTWIDGET": "PyQt_ListWidget",
+    "QT_NO_MAINWINDOW": "PyQt_MainWindow",
+    "QT_NO_MDIAREA": "PyQt_MDIArea",
+    "QT_NO_MENU": "PyQt_Menu",
+    "QT_NO_MENUBAR": "PyQt_MenuBar",
+    "QT_NO_MESSAGEBOX": "PyQt_MessageBox",
+    "QT_NO_MOVIE": "PyQt_Movie",
+    "QT_NO_NETWORKDISKCACHE": "PyQt_NetworkDiskCache",
+    "QT_NO_NETWORKPROXY": "PyQt_NetworkProxy",
+    "QT_NO_BEARERMANAGEMENT": "PyQt_BearerManagement",
+    "QT_NO_PAINTONSCREEN": "",                                  # internal
+    "QT_NO_PAINT_DEBUG": "",                                    # internal
+    "QT_NO_PHONON_ABSTRACTMEDIASTREAM": "",
+    "QT_NO_PHONON_AUDIOCAPTURE": "",
+    "QT_NO_PHONON_EFFECT": "",
+    "QT_NO_PHONON_EFFECTWIDGET": "PyQt_Phonon_EffectWidget",
+    "QT_NO_PHONON_MEDIACONTROLLER": "",
+    "QT_NO_PHONON_OBJECTDESCRIPTIONMODEL": "",
+    "QT_NO_PHONON_PLATFORMPLUGIN": "",
+    "QT_NO_PHONON_SEEKSLIDER": "PyQt_Phonon_SeekSlider",
+    "QT_NO_PHONON_SETTINGSGROUP": "PyQt_Phonon_SettingsGroup",
+    "QT_NO_PHONON_VIDEO": "",
+    "QT_NO_PHONON_VIDEOPLAYER": "",
+    "QT_NO_PHONON_VOLUMEFADEREFFECT": "",
+    "QT_NO_PHONON_VOLUMESLIDER": "PyQt_Phonon_VolumeSlider",
+    "QT_NO_PICTURE": "PyQt_Picture",
+    "QT_NO_PRINTDIALOG": "PyQt_PrintDialog",
+    "QT_NO_PRINTER": "PyQt_Printer",
+    "QT_NO_PRINTPREVIEWDIALOG": "PyQt_PrintPreviewDialog",
+    "QT_NO_PRINTPREVIEWWIDGET": "PyQt_PrintPreviewWidget",
+    "QT_NO_PROCESS": "PyQt_Process",
+    "QT_NO_PROGRESSBAR": "PyQt_ProgressBar",
+    "QT_NO_PROGRESSDIALOG": "PyQt_ProgressDialog",
+    "QT_NO_PROPERTIES": "PyQt_Properties",                      # internal
+    "QT_NO_PROXYMODEL": "PyQt_ProxyModel",
+    "QT_NO_QUUID_STRING": "PyQt_UUIDString",
+    "QT_NO_QWSEMBEDWIDGET": "",                                 # not wrapped
+    "QT_NO_QWS_ALPHA_CURSOR": "",                               # internal
+    "QT_NO_QWS_CURSOR": "PyQt_QWS_Cursor",  # Not used in any wrapped classes.
+    "QT_NO_QWS_DECORATION_DEFAULT": "",                         # not wrapped
+    "QT_NO_QWS_DECORATION_STYLED": "",                          # not wrapped
+    "QT_NO_QWS_DECORATION_WINDOWS": "",                         # not wrapped
+    "QT_NO_QWS_DYNAMICSCREENTRANSFORMATION": "",                # internal
+    "QT_NO_QWS_INPUTMETHODS": "",                               # not wrapped
+    "QT_NO_QWS_KEYBOARD": "",                                   # not wrapped
+    "QT_NO_QWS_MANAGER": "PyQt_QWS_Manager",
+    "QT_NO_QWS_MOUSE": "",                                      # not wrapped
+    "QT_NO_QWS_MOUSE_AUTO": "",                                 # internal
+    "QT_NO_QWS_MOUSE_MANUAL": "",                               # internal
+    "QT_NO_QWS_MULTIPROCESS": "",                               # internal
+    "QT_NO_QWS_PROPERTIES": "",                                 # internal
+    "QT_NO_QWS_PROXYSCREEN": "",                                # internal
+    "QT_NO_QWS_QPF": "",                                       # internal
+    "QT_NO_QWS_QPF2": "",                                       # internal
+    "QT_NO_QWS_SOUNDSERVER": "",                                # not wrapped
+    "QT_NO_QWS_TRANSFORMED": "",
+    "QT_NO_QWS_VNC": "",
+    "QT_NO_RASTERCALLBACKS": "",                                # not wrapped
+    "QT_NO_RAWFONT": "PyQt_RawFont",                            # internal
+    "QT_NO_RAW_FONT": "PyQt_RawFont",                            # internal
+    "QT_NO_RESIZEHANDLER": "",                                  # internal
+    "QT_NO_RUBBERBAND": "PyQt_RubberBand",
+    "QT_NO_SCRIPT": "",                                 # internal/unnecessary
+    "QT_NO_SCROLLAREA": "PyQt_ScrollArea",
+    "QT_NO_SCROLLBAR": "PyQt_ScrollBar",
+    "QT_NO_SESSIONMANAGER": "PyQt_SessionManager",
+    "QT_NO_SETTINGS": "PyQt_Settings",
+    "QT_NO_SHAREDMEMORY": "PyQt_SharedMemory",
+    "QT_NO_SHORTCUT": "PyQt_Shortcut",
+    "QT_NO_SIGNALMAPPER": "PyQt_SignalMapper",
+    "QT_NO_SIZEGRIP": "PyQt_SizeGrip",
+    "QT_NO_SLIDER": "PyQt_Slider",
+    "QT_NO_SOCKS5": "",                                         # internal
+    "QT_NO_SOFTKEYMANAGER": "PyQt_SoftKeyManager",
+    "QT_NO_SORTFILTERPROXYMODEL": "PyQt_SortFilterProxyModel",
+    "QT_NO_SOUND": "PyQt_Sound",
+    "QT_NO_SPINBOX": "PyQt_SpinBox",
+    "QT_NO_SPINWIDGET": "",                                 # not wrapped (Qt 3)
+    "QT_NO_SPLASHSCREEN": "PyQt_SplashScreen",
+    "QT_NO_SPLITTER": "PyQt_Splitter",
+    "QT_NO_STACKEDWIDGET": "PyQt_StackedWidget",
+    "QT_NO_STANDARDITEMMODEL": "PyQt_StandardItemModel",
+    "QT_NO_STATUSBAR": "PyQt_StatusBar",
+    "QT_NO_STATUSTIP": "PyQt_StatusTip",
+    "QT_NO_STATEMACHINE": "PyQt_StateMachine",
+    "QT_NO_STL": "",                                            # internal
+    "QT_NO_STRINGLISTMODEL": "PyQt_StringListModel",
+    "QT_NO_STYLE_CDE": "",                                      # not wrapped
+    "QT_NO_STYLE_CLEANLOOKS": "",                               # not wrapped
+    "QT_NO_STYLE_MOTIF": "",                                    # not wrapped
+    "QT_NO_STYLE_PLASTIQUE": "",                                # not wrapped
+    "QT_NO_STYLE_STYLESHEET": "PyQt_Style_StyleSheet",
+        # Beware: QApplication::styleSheet() is not covered.
+    "QT_NO_STYLE_WINDOWS": "",                                  # not wrapped
+    "QT_NO_STYLE_WINDOWSCE": "",                                # not wrapped
+    "QT_NO_STYLE_WINDOWSMOBILE": "",                            # not wrapped
+    "QT_NO_STYLE_WINDOWSVISTA": "",                             # not wrapped
+    "QT_NO_STYLE_WINDOWSXP": "",                                # not wrapped
+    "QT_NO_SVG": "",                                    # internal/unnecessary
+    "QT_NO_SVGGENERATOR": "PyQt_SVGGenerator",
+    "QT_NO_SVGRENDERER": "PyQt_SVGRenderer",
+    "QT_NO_SVGWIDGET": "PyQt_SVGWidget",
+    "QT_NO_SXE": "",                                            # internal
+    "QT_NO_SYNTAXHIGHLIGHTER": "PyQt_SyntaxHighlighter",
+    "QT_NO_SYSTEMSEMAPHORE": "PyQt_SystemSemaphore",
+    "QT_NO_SYSTEMTRAYICON": "PyQt_SystemTrayIcon",
+    "QT_NO_TABBAR": "PyQt_TabBar",
+    "QT_NO_TABDIALOG": "",                                      # internal
+    "QT_NO_TABLETEVENT": "PyQt_TabletEvent",
+    "QT_NO_TABLEVIEW": "PyQt_TableView",
+    "QT_NO_TABLEWIDGET": "PyQt_TableWidget",
+    "QT_NO_TABWIDGET": "PyQt_TabWidget",
+    "QT_NO_TEMPORARYFILE": "PyQt_TemporaryFile",
+    "QT_NO_TEXTBROWSER": "PyQt_TextBrowser",
+    "QT_NO_TEXTCODEC": "PyQt_TextCodec",
+    "QT_NO_TEXTCODECPLUGIN": "",                                # not wrapped
+    "QT_NO_TEXTDATE": "PyQt_TextDate",
+    "QT_NO_TEXTEDIT": "PyQt_TextEdit",
+    "QT_NO_TEXTEDITMENU": "PyQt_TextEditMenu",
+    "QT_NO_TEXTHTMLPARSER": "PyQt_TextHTMLParser",
+    "QT_NO_TEXTODFWRITER": "",                                  # to do
+    "QT_NO_TEXTSTREAM": "PyQt_TextStream",
+    "QT_NO_THREAD": "PyQt_Thread",
+    "QT_NO_TOOLBAR": "PyQt_ToolBar",
+    "QT_NO_TOOLBOX": "PyQt_ToolBox",
+    "QT_NO_TOOLBUTTON": "PyQt_ToolButton",
+    "QT_NO_TOOLTIP": "PyQt_ToolTip",
+    "QT_NO_TRANSLATION": "PyQt_Translation",
+    "QT_NO_TRANSLATION_UTF8": "",                               # internal
+    "QT_NO_TREEVIEW": "PyQt_TreeView",
+    "QT_NO_TREEWIDGET": "PyQt_TreeWidget",
+    "QT_NO_UDPSOCKET": "PyQt_UDPSocket",
+    "QT_NO_UNDOCOMMAND": "PyQt_UndoCommand",
+    "QT_NO_UNDOGROUP": "PyQt_UndoGroup",
+    "QT_NO_UNDOSTACK": "PyQt_UndoStack",
+        # Beware: QUndoView::setStack() and stack() are not covered.
+    "QT_NO_UNDOVIEW": "PyQt_UndoView",
+    "QT_NO_URLINFO": "PyQt_URLInfo",
+    "QT_NO_VALIDATOR": "PyQt_Validator",
+    "QT_NO_WHATSTHIS": "PyQt_WhatsThis",
+    "QT_NO_WHEELEVENT": "PyQt_WheelEvent",
+    "QT_NO_WIN_ACTIVEQT": "",                                   # internal
+    "QT_NO_WIZARD": "PyQt_Wizard",
+    "QT_NO_WORKSPACE": "PyQt_Workspace",
+    "QT_NO_XMLSTREAM": "PyQt_XMLStream",
+    "QT_NO_XMLSTREAMREADER": "PyQt_XMLStreamReader",
+    "QT_NO_XMLSTREAMWRITER": "PyQt_XMLStreamWriter",
+    "QT_QWS_SCREEN_COORDINATES": ""                             # internal
+    }
+
+# Features not introduced by Qt need to be passed to build_embedded_pyqt() as additional
+# configuration lines.
+
+def read_configuration(configuration_file, features_file):
+
+    dependents = read_features(features_file)
+    
+    definitions = sets.Set()
+    for line in open(configuration_file).readlines():
+    
+        pieces = line.strip().split()
+        if len(pieces) == 3 and pieces[:2] == ["#", "define"]:
+        
+            definitions.add(pieces[2])
+            
+            features = dependents.get(pieces[2], [])
+            i = 0
+            while i < len(features):
+                definitions.add(features[i])
+                features += dependents.get(features[i], [])
+                i += 1
+    
+    return list(definitions)
+
+def read_features(features_file):
+
+    features = {}
+    lines = map(lambda line: line.strip(), open(features_file).readlines())
+    feature = ""
+    
+    for line in lines:
+    
+        try:
+            key, value = line.split(":")
+        except ValueError:
+            continue
+        
+        if key == "Feature":
+            feature = value.lstrip()
+        elif feature and key == "Requires" and value:
+            features[feature] = value.lstrip().split()
+    
+    # Turn the dictionary of dependencies into a dictionary of dependents
+    # so that we can figure out which features to switch off when any given
+    # feature is disabled.
+    
+    dependents = {}
+    for feature, dependencies in features.items():
+    
+        for dependency in dependencies:
+            dependents.setdefault("QT_NO_"+dependency, []).append("QT_NO_"+feature)
+    
+    return dependents
+
+def convert_configuration(configuration_lines):
+
+    definitions = []
+    unknown = []
+    for definition in configuration_lines:
+    
+        try:
+            definition = conversion_dict[definition]
+        except KeyError:
+            unknown.append(definition)
+            continue
+        
+        if definition:
+            definitions.append(definition)
+    
+    if unknown:
+        sys.stderr.write("Unknown features: %s\n" % " ".join(unknown))
+        sys.exit(1)
+    
+    definitions.sort()
+    
+    qt_version_number = (env["QT_VERSION"][0] << 16) + \
+                        (env["QT_VERSION"][1] << 8) + \
+                        env["QT_VERSION"][2]
+    
+    lines = [prefix_join(env["TARGETDIR"]),
+             prefix_join(env["TARGETDIR"], "include"),
+             prefix_join(env["TARGETDIR"], "lib"),
+             prefix_join(env["TARGETDIR"], "bin"),
+             prefix_join(env["TARGETDIR"]),
+             prefix_join(env["TARGETDIR"], "plugins"),
+             str(qt_version_number),
+             "8",                       # open source edition
+             "Open Source",
+             "shared"] + definitions
+    
+    return lines
+
+################################################################################
+# Calls to build functions and additional changes to configuration go here.
+################################################################################
+
+if __name__ == "__main__":
+
+    py_suffix = os.extsep + "py"
+    pyc_suffix = os.extsep + "pyc"
+    
+    import local_settings
+    global env
+    
+    
+#    env = local_settings.env
+    env = {}
+    env.update({
+	    "QTDIR"      : sys.argv[1],
+	    "TARGETDIR"  : sys.argv[2],
+	    "QT_VERSION" : [4,8,4]
+	    })
+
+
+
+    # Check whether the Qt configuration profile exists before we start.
+    if local_settings.qt_configuration_profile:
+    
+        qconfig_path = os.path.join(env["QTDIR"], "src", "corelib", "global")
+        features_path = os.path.join(qconfig_path, "qfeatures" + os.extsep + "txt")
+        configuration_file = "qconfig-" + local_settings.qt_configuration_profile+os.extsep+"h"
+        
+        config_dirs = [os.pardir, qconfig_path]
+        
+        for config_dir in config_dirs:
+            config_path = os.path.join(config_dir, configuration_file)
+            if os.path.exists(config_path):
+                if config_dir != qconfig_path:
+                    system("cp " + config_path + " " + os.path.join(qconfig_path, configuration_file))
+                break
+        else:
+            sys.stderr.write("Cannot locate %s.\n" % configuration_file)
+            sys.exit(1)
+        
+        qt_configuration_lines = read_configuration(config_path, features_path)
+    else:
+        qt_configuration_lines = []
+    
+    qt_configuration_profile = local_settings.qt_configuration_profile
+    extra_qt_configuration = local_settings.extra_qt_configuration
+    
+    pyqt_configuration_lines = convert_configuration(qt_configuration_lines + extra_qt_configuration)
+    pyqt_configuration_lines += local_settings.extra_pyqt_configuration
+    
+
+    if not pyqt_configuration_lines:
+         pyqt_configuration_lines = []
+    
+    # Create a configuration file for the configure script to use.
+    open("qtdirs_.out", "w").write("\n".join( pyqt_configuration_lines))
+
+    sys.exit()
diff --git a/package/pyqt/pyqt-4.9.6-full.patch b/package/pyqt/pyqt-4.9.6-full.patch
new file mode 100644
index 0000000..0cbdf24
--- /dev/null
+++ b/package/pyqt/pyqt-4.9.6-full.patch
@@ -0,0 +1,953 @@
+diff -ur PyQt-x11-gpl-4.9.6/qpy/QtCore/qpycore_api.h pyqt-4.9.6/qpy/QtCore/qpycore_api.h
+--- PyQt-x11-gpl-4.9.6/qpy/QtCore/qpycore_api.h	2012-12-08 13:51:39.000000000 +0400
++++ pyqt-4.9.6/qpy/QtCore/qpycore_api.h	2013-04-24 14:25:37.154000018 +0400
+@@ -28,6 +28,7 @@
+ #define _QPYCORE_API_H
+ 
+ 
++#include <qconfig.h>
+ #include <QCoreApplication>
+ #include <QString>
+ #include <QVariant>
+@@ -47,7 +48,9 @@
+ PyObject *qpycore_pyqtsignature(PyObject *args, PyObject *kwds);
+ 
+ // Support for pyqtConfigure().
++#ifndef QT_NO_PROPERTIES
+ int qpycore_pyqtconfigure(PyObject *self, QObject *qobj, PyObject *kwds);
++#endif
+ 
+ // Support for converting between PyObject and QString.
+ PyObject *qpycore_PyObject_FromQString(const QString &qstr);
+diff -ur PyQt-x11-gpl-4.9.6/qpy/QtCore/qpycore_init.cpp pyqt-4.9.6/qpy/QtCore/qpycore_init.cpp
+--- PyQt-x11-gpl-4.9.6/qpy/QtCore/qpycore_init.cpp	2012-12-08 13:51:39.000000000 +0400
++++ pyqt-4.9.6/qpy/QtCore/qpycore_init.cpp	2013-04-24 14:25:37.154000018 +0400
+@@ -25,6 +25,7 @@
+ 
+ #include <Python.h>
+ 
++#include <qconfig.h>
+ #include "qpycore_chimera.h"
+ #include "qpycore_qobject_helpers.h"
+ #include "qpycore_shared.h"
+@@ -54,7 +55,9 @@
+     sipExportSymbol("qpycore_qobject_receivers",
+             (void *)qpycore_qobject_receivers);
+ 
++#ifndef QT_NO_PROPERTIES
+     sipExportSymbol("pyqt_kw_handler", (void *)qpycore_pyqtconfigure);
++#endif
+ 
+     sipExportSymbol("qpycore_ArgvToC", (void *)qpycore_ArgvToC);
+     sipExportSymbol("qpycore_UpdatePyArgv", (void *)qpycore_UpdatePyArgv);
+diff -ur PyQt-x11-gpl-4.9.6/qpy/QtCore/qpycore_pyqtconfigure.cpp pyqt-4.9.6/qpy/QtCore/qpycore_pyqtconfigure.cpp
+--- PyQt-x11-gpl-4.9.6/qpy/QtCore/qpycore_pyqtconfigure.cpp	2012-12-08 13:51:39.000000000 +0400
++++ pyqt-4.9.6/qpy/QtCore/qpycore_pyqtconfigure.cpp	2013-04-24 14:25:37.154000018 +0400
+@@ -23,6 +23,8 @@
+ // WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ 
+ 
++#include <qconfig.h>
++#ifndef QT_NO_PROPERTIES
+ #include <Python.h>
+ 
+ #include <QByteArray>
+@@ -167,3 +169,4 @@
+ 
+     return 0;
+ }
++#endif // QT_NO_PROPERTIES
+diff -ur PyQt-x11-gpl-4.9.6/qpy/QtCore/qpycore_qstring.cpp pyqt-4.9.6/qpy/QtCore/qpycore_qstring.cpp
+--- PyQt-x11-gpl-4.9.6/qpy/QtCore/qpycore_qstring.cpp	2012-12-08 13:51:39.000000000 +0400
++++ pyqt-4.9.6/qpy/QtCore/qpycore_qstring.cpp	2013-04-24 14:25:37.154000018 +0400
+@@ -26,8 +26,11 @@
+ #include <Python.h>
+ #include <string.h>
+ 
++#include <qconfig.h>
+ #include <QString>
++#ifndef QT_NO_TEXTCODEC
+ #include <QTextCodec>
++#endif
+ #include <QVector>
+ 
+ #include "qpycore_sip.h"
+@@ -169,6 +172,7 @@
+         }
+         else
+         {
++#ifndef QT_NO_TEXTCODEC
+             QTextCodec *codec = QTextCodec::codecForTr();
+ 
+             if (codec)
+@@ -188,6 +192,9 @@
+             {
+                 obj = PyUnicode_AsLatin1String(obj);
+             }
++#else
++                obj = PyUnicode_AsLatin1String(obj);
++#endif
+         }
+ 
+         if (obj)
+diff -ur PyQt-x11-gpl-4.9.6/sip/phonon/phononmod.sip pyqt-4.9.6/sip/phonon/phononmod.sip
+--- PyQt-x11-gpl-4.9.6/sip/phonon/phononmod.sip	2012-12-08 13:51:38.000000000 +0400
++++ pyqt-4.9.6/sip/phonon/phononmod.sip	2013-04-24 14:14:54.168000018 +0400
+@@ -62,7 +62,9 @@
+ %Include backendcapabilities.sip
+ %Include effect.sip
+ %Include effectparameter.sip
+-%Include effectwidget.sip
++%If (PyQt_Phonon_EffectWidget)
++  %Include effectwidget.sip
++%End
+ %Include mediacontroller.sip
+ %Include medianode.sip
+ %Include mediaobject.sip
+@@ -70,7 +72,11 @@
+ %Include objectdescription.sip
+ %Include path.sip
+ %Include phononnamespace.sip
+-%Include seekslider.sip
++%If (PyQt_Phonon_SeekSlider)
++  %Include seekslider.sip
++%End
+ %Include videoplayer.sip
+ %Include videowidget.sip
+-%Include volumeslider.sip
++%If (PyQt_Phonon_VolumeSlider)
++  %Include volumeslider.sip
++%End
+diff -ur PyQt-x11-gpl-4.9.6/sip/QtCore/qnamespace.sip pyqt-4.9.6/sip/QtCore/qnamespace.sip
+--- PyQt-x11-gpl-4.9.6/sip/QtCore/qnamespace.sip	2012-12-08 13:51:38.000000000 +0400
++++ pyqt-4.9.6/sip/QtCore/qnamespace.sip	2013-04-24 17:50:22.845000018 +0400
+@@ -1670,7 +1670,7 @@
+ %End
+ %End
+ %If (- Qt_5_0_0)
+-%If (WS_X11)
++%If (WS_X11 || WS_QWS)
+     typedef unsigned long HANDLE;
+ %End
+ %End
+diff -ur PyQt-x11-gpl-4.9.6/sip/QtCore/qprocess.sip pyqt-4.9.6/sip/QtCore/qprocess.sip
+--- PyQt-x11-gpl-4.9.6/sip/QtCore/qprocess.sip	2012-12-08 13:51:38.000000000 +0400
++++ pyqt-4.9.6/sip/QtCore/qprocess.sip	2013-04-24 17:47:46.808000017 +0400
+@@ -28,7 +28,7 @@
+ %If (WS_WIN)
+ typedef void *Q_PID;
+ %End
+-%If (WS_X11 || WS_MACX)
++%If (WS_X11 || WS_MACX || WS_QWS)
+ typedef qint64 Q_PID;
+ %End
+ 
+diff -ur PyQt-x11-gpl-4.9.6/sip/QtCore/QtCoremod.sip pyqt-4.9.6/sip/QtCore/QtCoremod.sip
+--- PyQt-x11-gpl-4.9.6/sip/QtCore/QtCoremod.sip	2012-12-08 13:51:39.000000000 +0400
++++ pyqt-4.9.6/sip/QtCore/QtCoremod.sip	2013-04-24 17:48:37.599000018 +0400
+@@ -29,7 +29,7 @@
+ 
+ %Timeline {Qt_4_1_1 Qt_4_1_2 Qt_4_1_3 Qt_4_2_0 Qt_4_2_2 Qt_4_2_3 Qt_4_3_0 Qt_4_3_1 Qt_4_3_2 Qt_4_3_3 Qt_4_3_4 Qt_4_4_0 Qt_4_4_1 Qt_4_4_2 Qt_4_5_0 Qt_4_5_1 Qt_4_5_2 Qt_4_5_3 Qt_4_6_0 Qt_4_6_1 Qt_4_6_2 Qt_4_6_3 Qt_4_7_0 Qt_4_7_1 Qt_4_7_2 Qt_4_7_3 Qt_4_7_4 Qt_4_8_0 Qt_4_8_1 Qt_4_8_2 Qt_4_8_3 Qt_4_8_4 Qt_5_0_0}
+ 
+-%Platforms {WS_X11 WS_WIN WS_MACX}
++%Platforms {WS_X11 WS_WIN WS_MACX WS_QWS}
+ 
+ %Feature PyQt_Accessibility
+ %Feature PyQt_SessionManager
+diff -ur PyQt-x11-gpl-4.9.6/sip/QtGui/qabstractbutton.sip pyqt-4.9.6/sip/QtGui/qabstractbutton.sip
+--- PyQt-x11-gpl-4.9.6/sip/QtGui/qabstractbutton.sip	2012-12-08 13:51:38.000000000 +0400
++++ pyqt-4.9.6/sip/QtGui/qabstractbutton.sip	2013-04-24 16:53:31.003000018 +0400
+@@ -51,8 +51,10 @@
+     void setIcon(const QIcon &icon);
+     QIcon icon() const;
+     QSize iconSize() const;
++%If (PyQt_Shortcut)
+     void setShortcut(const QKeySequence &key);
+     QKeySequence shortcut() const;
++%End
+     void setCheckable(bool);
+     bool isCheckable() const;
+     bool isChecked() const;
+@@ -62,7 +64,9 @@
+     bool autoRepeat() const;
+     void setAutoExclusive(bool);
+     bool autoExclusive() const;
++%If (PyQt_ButtonGroup)
+     QButtonGroup *group() const;
++%End
+ 
+ public slots:
+     void setIconSize(const QSize &size);
+diff -ur PyQt-x11-gpl-4.9.6/sip/QtGui/qaction.sip pyqt-4.9.6/sip/QtGui/qaction.sip
+--- PyQt-x11-gpl-4.9.6/sip/QtGui/qaction.sip	2012-12-08 13:51:38.000000000 +0400
++++ pyqt-4.9.6/sip/QtGui/qaction.sip	2013-04-24 14:14:54.272000018 +0400
+@@ -44,20 +44,30 @@
+     QString text() const;
+     void setIconText(const QString &text);
+     QString iconText() const;
+-    void setToolTip(const QString &tip);
+-    QString toolTip() const;
+-    void setStatusTip(const QString &statusTip);
+-    QString statusTip() const;
+-    void setWhatsThis(const QString &what);
+-    QString whatsThis() const;
++%If (PyQt_ToolTip)
++      void setToolTip(const QString &tip);
++      QString toolTip() const;
++%End
++%If (PyQt_StatusTip)
++      void setStatusTip(const QString &statusTip);
++      QString statusTip() const;
++%End
++%If (PyQt_WhatsThis)
++      void setWhatsThis(const QString &what);
++      QString whatsThis() const;
++%End
++%If (PyQt_Menu)
+     QMenu *menu() const;
+     void setMenu(QMenu *menu /KeepReference/);
++%End
+     void setSeparator(bool b);
+     bool isSeparator() const;
++%If (PyQt_Shortcut)
+     void setShortcut(const QKeySequence &shortcut);
+     QKeySequence shortcut() const;
+     void setShortcutContext(Qt::ShortcutContext context);
+     Qt::ShortcutContext shortcutContext() const;
++%End
+     void setFont(const QFont &font);
+     QFont font() const;
+     void setCheckable(bool);
+@@ -111,6 +121,7 @@
+     };
+ 
+ %End
++%If (PyQt_Shortcut)
+ %If (Qt_4_2_0 -)
+     void setShortcuts(const QList<QKeySequence> &shortcuts);
+ %End
+@@ -126,6 +137,7 @@
+ %If (Qt_4_2_0 -)
+     bool autoRepeat() const;
+ %End
++%End
+ %If (Qt_4_2_0 -)
+     void setMenuRole(QAction::MenuRole menuRole);
+ %End
+@@ -136,8 +148,10 @@
+     QList<QWidget*> associatedWidgets() const;
+ %End
+ %If (Qt_4_5_0 -)
++%If (PyQt_GraphicsView)
+     QList<QGraphicsWidget*> associatedGraphicsWidgets() const;
+ %End
++%End
+ %If (Qt_4_4_0 -)
+     void setIconVisibleInMenu(bool visible);
+ %End
+diff -ur PyQt-x11-gpl-4.9.6/sip/QtGui/qcolor.sip pyqt-4.9.6/sip/QtGui/qcolor.sip
+--- PyQt-x11-gpl-4.9.6/sip/QtGui/qcolor.sip	2012-12-08 13:51:38.000000000 +0400
++++ pyqt-4.9.6/sip/QtGui/qcolor.sip	2013-04-24 14:14:54.205000018 +0400
+@@ -227,5 +227,7 @@
+ %End
+ };
+ 
++%If (PyQt_DataStream)
+ QDataStream &operator<<(QDataStream &, const QColor & /Constrained/);
+ QDataStream &operator>>(QDataStream &, QColor & /Constrained/);
++%End
+diff -ur PyQt-x11-gpl-4.9.6/sip/QtGui/qcursor.sip pyqt-4.9.6/sip/QtGui/qcursor.sip
+--- PyQt-x11-gpl-4.9.6/sip/QtGui/qcursor.sip	2012-12-08 13:51:38.000000000 +0400
++++ pyqt-4.9.6/sip/QtGui/qcursor.sip	2013-04-24 14:14:54.227000018 +0400
+@@ -24,6 +24,7 @@
+ // This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+ // WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ 
++%If (PyQt_Cursor)
+ 
+ %ModuleCode
+ #include <qcursor.h>
+@@ -82,5 +83,9 @@
+     static void setPos(const QPoint &p);
+ };
+ 
++%If (PyQt_DataStream)
+ QDataStream &operator<<(QDataStream &outS, const QCursor &cursor /Constrained/);
+ QDataStream &operator>>(QDataStream &inS, QCursor &cursor /Constrained/);
++%End
++
++%End
+diff -ur PyQt-x11-gpl-4.9.6/sip/QtGui/qfont.sip pyqt-4.9.6/sip/QtGui/qfont.sip
+--- PyQt-x11-gpl-4.9.6/sip/QtGui/qfont.sip	2012-12-08 13:51:38.000000000 +0400
++++ pyqt-4.9.6/sip/QtGui/qfont.sip	2013-05-22 14:06:38.335000022 +0400
+@@ -185,7 +185,9 @@
+ %End
+     static void initialize();
+     static void cleanup();
++%If (!WS_QWS)
+     static void cacheStatistics();
++%End
+     QString defaultFamily() const;
+     QString lastResortFamily() const;
+     QString lastResortFont() const;
+@@ -264,5 +266,7 @@
+ %End
+ };
+ 
++%If (PyQt_DataStream)
+ QDataStream &operator<<(QDataStream &, const QFont & /Constrained/);
+ QDataStream &operator>>(QDataStream &, QFont & /Constrained/);
++%End
+diff -ur PyQt-x11-gpl-4.9.6/sip/QtGui/qgraphicsproxywidget.sip pyqt-4.9.6/sip/QtGui/qgraphicsproxywidget.sip
+--- PyQt-x11-gpl-4.9.6/sip/QtGui/qgraphicsproxywidget.sip	2012-12-08 13:51:38.000000000 +0400
++++ pyqt-4.9.6/sip/QtGui/qgraphicsproxywidget.sip	2013-04-24 14:14:54.256000018 +0400
+@@ -69,7 +69,9 @@
+     virtual bool eventFilter(QObject *object, QEvent *event);
+     virtual void showEvent(QShowEvent *event);
+     virtual void hideEvent(QHideEvent *event);
++%If (PyQt_ContextMenu)
+     virtual void contextMenuEvent(QGraphicsSceneContextMenuEvent *event);
++%End
+     virtual void hoverEnterEvent(QGraphicsSceneHoverEvent *event);
+     virtual void hoverLeaveEvent(QGraphicsSceneHoverEvent *event);
+     virtual void hoverMoveEvent(QGraphicsSceneHoverEvent *event);
+@@ -79,7 +81,9 @@
+     virtual void mousePressEvent(QGraphicsSceneMouseEvent *event);
+     virtual void mouseReleaseEvent(QGraphicsSceneMouseEvent *event);
+     virtual void mouseDoubleClickEvent(QGraphicsSceneMouseEvent *event);
++%If (PyQt_WheelEvent)
+     virtual void wheelEvent(QGraphicsSceneWheelEvent *event);
++%End
+     virtual void keyPressEvent(QKeyEvent *event);
+     virtual void keyReleaseEvent(QKeyEvent *event);
+     virtual void focusInEvent(QFocusEvent *event);
+@@ -87,6 +91,7 @@
+     virtual bool focusNextPrevChild(bool next);
+     virtual QSizeF sizeHint(Qt::SizeHint which, const QSizeF &constraint = QSizeF()) const;
+     virtual void resizeEvent(QGraphicsSceneResizeEvent *event);
++%If (PyQt_DragAndDrop)
+ %If (Qt_4_5_0 -)
+     virtual void dragEnterEvent(QGraphicsSceneDragDropEvent *event);
+ %End
+@@ -99,6 +104,7 @@
+ %If (Qt_4_5_0 -)
+     virtual void dropEvent(QGraphicsSceneDragDropEvent *event);
+ %End
++%End
+ %If (Qt_4_5_0 -)
+     QGraphicsProxyWidget *newProxyWidget(const QWidget *) /Factory/;
+ %End
+Only in pyqt-4.9.6/sip/QtGui: qgraphicsproxywidget.sip.diff
+Only in pyqt-4.9.6/sip/QtGui: qgraphicsproxywidget.sip.old
+Only in pyqt-4.9.6/sip/QtGui: qgraphicssceneevent.sip.diff
+Only in pyqt-4.9.6/sip/QtGui: qgraphicsscene.sip.diff
+diff -ur PyQt-x11-gpl-4.9.6/sip/QtGui/qgraphicsview.sip pyqt-4.9.6/sip/QtGui/qgraphicsview.sip
+--- PyQt-x11-gpl-4.9.6/sip/QtGui/qgraphicsview.sip	2012-12-08 13:51:38.000000000 +0400
++++ pyqt-4.9.6/sip/QtGui/qgraphicsview.sip	2013-04-24 14:14:54.261000018 +0400
+@@ -142,11 +142,15 @@
+ protected:
+     virtual bool event(QEvent *event);
+     virtual bool viewportEvent(QEvent *event);
++%If (PyQt_ContextMenu)
+     virtual void contextMenuEvent(QContextMenuEvent *event);
++%End
++%If (PyQt_DragAndDrop)
+     virtual void dragEnterEvent(QDragEnterEvent *event);
+     virtual void dragLeaveEvent(QDragLeaveEvent *event);
+     virtual void dragMoveEvent(QDragMoveEvent *event);
+     virtual void dropEvent(QDropEvent *event);
++%End
+     virtual void focusInEvent(QFocusEvent *event);
+     virtual void focusOutEvent(QFocusEvent *event);
+ %If (Qt_4_4_0 -)
+@@ -158,7 +162,9 @@
+     virtual void mousePressEvent(QMouseEvent *event);
+     virtual void mouseMoveEvent(QMouseEvent *event);
+     virtual void mouseReleaseEvent(QMouseEvent *event);
++%If (PyQt_WheelEvent)
+     virtual void wheelEvent(QWheelEvent *event);
++%End
+     virtual void paintEvent(QPaintEvent *event);
+     virtual void resizeEvent(QResizeEvent *event);
+     virtual void scrollContentsBy(int dx, int dy);
+@@ -310,12 +316,14 @@
+ %If (Qt_4_3_0 -)
+     void setOptimizationFlags(QFlags<QGraphicsView::OptimizationFlag> flags);
+ %End
++%If (PyQt_RubberBand)
+ %If (Qt_4_3_0 -)
+     Qt::ItemSelectionMode rubberBandSelectionMode() const;
+ %End
+ %If (Qt_4_3_0 -)
+     void setRubberBandSelectionMode(Qt::ItemSelectionMode mode);
+ %End
++%End
+ %If (Qt_4_3_0 -)
+     QTransform transform() const;
+ %End
+diff -ur PyQt-x11-gpl-4.9.6/sip/QtGui/qicon.sip pyqt-4.9.6/sip/QtGui/qicon.sip
+--- PyQt-x11-gpl-4.9.6/sip/QtGui/qicon.sip	2012-12-08 13:51:38.000000000 +0400
++++ pyqt-4.9.6/sip/QtGui/qicon.sip	2013-04-24 14:14:54.288000018 +0400
+@@ -115,12 +115,14 @@
+ %End
+ };
+ 
++%If (PyQt_DataStream)
+ %If (Qt_4_2_0 -)
+ QDataStream &operator<<(QDataStream &, const QIcon & /Constrained/);
+ %End
+ %If (Qt_4_2_0 -)
+ QDataStream &operator>>(QDataStream &, QIcon & /Constrained/);
+ %End
++%End
+ %If (Qt_4_3_0 -)
+ void qSwap(QIcon &value1, QIcon &value2);
+ %End
+diff -ur PyQt-x11-gpl-4.9.6/sip/QtGui/qlistwidget.sip pyqt-4.9.6/sip/QtGui/qlistwidget.sip
+--- PyQt-x11-gpl-4.9.6/sip/QtGui/qlistwidget.sip	2012-12-08 13:51:38.000000000 +0400
++++ pyqt-4.9.6/sip/QtGui/qlistwidget.sip	2013-04-24 14:14:54.234000018 +0400
+@@ -64,7 +64,9 @@
+     Qt::ItemFlags flags() const;
+     QString text() const;
+     QIcon icon() const;
++%If (PyQt_StatusTip)
+     QString statusTip() const;
++%End
+ %If (PyQt_ToolTip)
+     QString toolTip() const;
+ %End
+@@ -85,13 +87,17 @@
+     virtual QVariant data(int role) const;
+     virtual void setData(int role, const QVariant &value);
+     virtual bool operator<(const QListWidgetItem &other /NoCopy/) const;
++%If (PyQt_DataStream)
+     virtual void read(QDataStream &in) /ReleaseGIL/;
+     virtual void write(QDataStream &out) const /ReleaseGIL/;
++%End
+     int type() const;
+     void setFlags(Qt::ItemFlags aflags);
+     void setText(const QString &atext);
+     void setIcon(const QIcon &aicon);
++%If (PyQt_StatusTip)
+     void setStatusTip(const QString &astatusTip);
++%End
+ %If (PyQt_ToolTip)
+     void setToolTip(const QString &atoolTip);
+ %End
+@@ -128,8 +134,10 @@
+     QListWidgetItem &operator=(const QListWidgetItem &);
+ };
+ 
++%If (PyQt_DataStream)
+ QDataStream &operator<<(QDataStream &out, const QListWidgetItem &item /Constrained/);
+ QDataStream &operator>>(QDataStream &in, QListWidgetItem &item /Constrained/);
++%End
+ 
+ class QListWidget : QListView
+ {
+@@ -212,8 +220,10 @@
+ protected:
+     virtual QStringList mimeTypes() const;
+     virtual QMimeData *mimeData(const QList<QListWidgetItem*> items) const /TransferBack/;
++%If (PyQt_DragAndDrop)
+     virtual bool dropMimeData(int index, const QMimeData *data, Qt::DropAction action);
+     virtual Qt::DropActions supportedDropActions() const;
++%End
+     QList<QListWidgetItem*> items(const QMimeData *data) const;
+     QModelIndex indexFromItem(QListWidgetItem *item) const;
+     QListWidgetItem *itemFromIndex(const QModelIndex &index) const;
+@@ -227,8 +237,10 @@
+     bool isSortingEnabled() const;
+ %End
+ %If (Qt_4_2_0 -)
++%If (PyQt_DragAndDrop)
+     virtual void dropEvent(QDropEvent *event);
+ %End
++%End
+ %If (Qt_4_3_0 -)
+     void removeItemWidget(QListWidgetItem *aItem);
+ %MethodCode
+diff -ur PyQt-x11-gpl-4.9.6/sip/QtGui/qmainwindow.sip pyqt-4.9.6/sip/QtGui/qmainwindow.sip
+--- PyQt-x11-gpl-4.9.6/sip/QtGui/qmainwindow.sip	2012-12-08 13:51:38.000000000 +0400
++++ pyqt-4.9.6/sip/QtGui/qmainwindow.sip	2013-04-24 14:14:54.246000018 +0400
+@@ -47,14 +47,21 @@
+     void setIconSize(const QSize &iconSize);
+     Qt::ToolButtonStyle toolButtonStyle() const;
+     void setToolButtonStyle(Qt::ToolButtonStyle toolButtonStyle);
++%If (PyQt_MenuBar)
+     QMenuBar *menuBar() const /Transfer/;
+     void setMenuBar(QMenuBar *menubar /Transfer/);
++%End
++%If (PyQt_StatusBar)
+     QStatusBar *statusBar() const /Transfer/;
+     void setStatusBar(QStatusBar *statusbar /Transfer/);
++%End
+     QWidget *centralWidget() const;
+     void setCentralWidget(QWidget *widget /Transfer/);
++%If (PyQt_DockWidget)
+     void setCorner(Qt::Corner corner, Qt::DockWidgetArea area);
+     Qt::DockWidgetArea corner(Qt::Corner corner) const;
++%End
++%If (PyQt_ToolBar)
+     void addToolBarBreak(Qt::ToolBarArea area = Qt::TopToolBarArea);
+     void insertToolBarBreak(QToolBar *before);
+     void addToolBar(Qt::ToolBarArea area, QToolBar *toolbar /Transfer/);
+@@ -63,47 +70,61 @@
+     void insertToolBar(QToolBar *before, QToolBar *toolbar /Transfer/);
+     void removeToolBar(QToolBar *toolbar);
+     Qt::ToolBarArea toolBarArea(QToolBar *toolbar) const;
++%End
++%If (PyQt_DockWidget)
+     void addDockWidget(Qt::DockWidgetArea area, QDockWidget *dockwidget /Transfer/);
+     void addDockWidget(Qt::DockWidgetArea area, QDockWidget *dockwidget /Transfer/, Qt::Orientation orientation);
+     void splitDockWidget(QDockWidget *after, QDockWidget *dockwidget /Transfer/, Qt::Orientation orientation);
+     void removeDockWidget(QDockWidget *dockwidget /TransferBack/);
+     Qt::DockWidgetArea dockWidgetArea(QDockWidget *dockwidget) const;
++%End
+     QByteArray saveState(int version = 0) const;
+     bool restoreState(const QByteArray &state, int version = 0);
++%If (PyQt_Menu)
+     virtual QMenu *createPopupMenu();
++%End
+ 
+ public slots:
++%If (PyQt_DockWidget)
+ %If (Qt_4_2_0 -)
+     void setAnimated(bool enabled);
+ %End
+ %If (Qt_4_2_0 -)
+     void setDockNestingEnabled(bool enabled);
+ %End
++%End
+ 
+ signals:
+     void iconSizeChanged(const QSize &iconSize);
+     void toolButtonStyleChanged(Qt::ToolButtonStyle toolButtonStyle);
+ 
+ protected:
++%If (PyQt_ContextMenu)
+     virtual void contextMenuEvent(QContextMenuEvent *event);
++%End
+     virtual bool event(QEvent *event);
+ 
+ public:
++%If (PyQt_DockWidget)
+ %If (Qt_4_2_0 -)
+     bool isAnimated() const;
+ %End
+ %If (Qt_4_2_0 -)
+     bool isDockNestingEnabled() const;
+ %End
++%End
+ %If (Qt_4_2_0 -)
+     bool isSeparator(const QPoint &pos) const;
+ %End
++%If (PyQt_MenuBar)
+ %If (Qt_4_2_0 -)
+     QWidget *menuWidget() const;
+ %End
+ %If (Qt_4_2_0 -)
+     void setMenuWidget(QWidget *menubar /Transfer/);
+ %End
++%End
++%If (PyQt_DockWidget)
+ %If (Qt_4_2_0 -)
+     void tabifyDockWidget(QDockWidget *first, QDockWidget *second);
+ %End
+@@ -128,12 +149,16 @@
+ %If (Qt_4_3_0 -)
+     QFlags<QMainWindow::DockOption> dockOptions() const;
+ %End
++%End
++%If (PyQt_ToolBar)
+ %If (Qt_4_3_0 -)
+     void removeToolBarBreak(QToolBar *before);
+ %End
+ %If (Qt_4_3_0 -)
+     bool toolBarBreak(QToolBar *toolbar) const;
+ %End
++%End
++%If (PyQt_DockWidget)
+ %If (Qt_4_3_0 -)
+     void setUnifiedTitleAndToolBarOnMac(bool set);
+ %End
+@@ -143,18 +168,23 @@
+ %If (Qt_4_4_0 -)
+     bool restoreDockWidget(QDockWidget *dockwidget);
+ %End
++%End
++%If (PyQt_TabBar)
+ %If (Qt_4_5_0 -)
+     bool documentMode() const;
+ %End
+ %If (Qt_4_5_0 -)
+     void setDocumentMode(bool enabled);
+ %End
++%End
++%If (PyQt_TabWidget)
+ %If (Qt_4_5_0 -)
+     QTabWidget::TabShape tabShape() const;
+ %End
+ %If (Qt_4_5_0 -)
+     void setTabShape(QTabWidget::TabShape tabShape);
+ %End
++%If (PyQt_DockWidget)
+ %If (Qt_4_5_0 -)
+     QTabWidget::TabPosition tabPosition(Qt::DockWidgetArea area) const;
+ %End
+@@ -164,11 +194,15 @@
+ %If (Qt_4_5_0 -)
+     QList<QDockWidget*> tabifiedDockWidgets(QDockWidget *dockwidget) const;
+ %End
++%End // PyQt_DockWidget
++%End // PyQt_TabWidget
+ 
+ private:
+     QMainWindow(const QMainWindow &);
+ };
+ 
++%If (PyQt_DockWidget)
+ %If (Qt_4_3_0 -)
+ QFlags<QMainWindow::DockOption> operator|(QMainWindow::DockOption f1, QFlags<QMainWindow::DockOption> f2);
+ %End
++%End
+diff -ur PyQt-x11-gpl-4.9.6/sip/QtGui/qplaintextedit.sip pyqt-4.9.6/sip/QtGui/qplaintextedit.sip
+--- PyQt-x11-gpl-4.9.6/sip/QtGui/qplaintextedit.sip	2012-12-08 13:51:38.000000000 +0400
++++ pyqt-4.9.6/sip/QtGui/qplaintextedit.sip	2013-04-24 14:14:54.219000018 +0400
+@@ -74,7 +74,9 @@
+     QString toPlainText() const;
+     void ensureCursorVisible();
+     virtual QVariant loadResource(int type, const QUrl &name);
++%If (PyQt_ContextMenu)
+     QMenu *createStandardContextMenu() /Factory/;
++%End
+     QTextCursor cursorForPosition(const QPoint &pos) const;
+     QRect cursorRect(const QTextCursor &cursor) const;
+     QRect cursorRect() const;
+@@ -110,9 +112,11 @@
+ 
+ public slots:
+     void setPlainText(const QString &text);
++%If (PyQt_Clipboard)
+     void cut();
+     void copy();
+     void paste();
++%End
+     void undo();
+     void redo();
+     void clear();
+@@ -145,16 +149,22 @@
+     virtual void mouseReleaseEvent(QMouseEvent *e);
+     virtual void mouseDoubleClickEvent(QMouseEvent *e);
+     virtual bool focusNextPrevChild(bool next);
++%If (PyQt_ContextMenu)
+     virtual void contextMenuEvent(QContextMenuEvent *e);
++%End
++%If (PyQt_DragAndDrop)
+     virtual void dragEnterEvent(QDragEnterEvent *e);
+     virtual void dragLeaveEvent(QDragLeaveEvent *e);
+     virtual void dragMoveEvent(QDragMoveEvent *e);
+     virtual void dropEvent(QDropEvent *e);
++%End
+     virtual void focusInEvent(QFocusEvent *e);
+     virtual void focusOutEvent(QFocusEvent *e);
+     virtual void showEvent(QShowEvent *);
+     virtual void changeEvent(QEvent *e);
++%If (PyQt_WheelEvent)
+     virtual void wheelEvent(QWheelEvent *e);
++%End
+     virtual void inputMethodEvent(QInputMethodEvent *);
+ 
+ public:
+diff -ur PyQt-x11-gpl-4.9.6/sip/QtGui/qpushbutton.sip pyqt-4.9.6/sip/QtGui/qpushbutton.sip
+--- PyQt-x11-gpl-4.9.6/sip/QtGui/qpushbutton.sip	2012-12-08 13:51:38.000000000 +0400
++++ pyqt-4.9.6/sip/QtGui/qpushbutton.sip	2013-04-24 14:14:54.267000018 +0400
+@@ -44,13 +44,17 @@
+     void setAutoDefault(bool);
+     bool isDefault() const;
+     void setDefault(bool);
++%If (PyQt_Menu)
+     void setMenu(QMenu *menu /KeepReference/);
+     QMenu *menu() const;
++%End
+     void setFlat(bool);
+     bool isFlat() const;
+ 
+ public slots:
++%If (PyQt_Menu)
+     void showMenu();
++%End
+ 
+ protected:
+ %If (Qt_4_3_0 -)
+diff -ur PyQt-x11-gpl-4.9.6/sip/QtGui/qregion.sip pyqt-4.9.6/sip/QtGui/qregion.sip
+--- PyQt-x11-gpl-4.9.6/sip/QtGui/qregion.sip	2012-12-08 13:51:38.000000000 +0400
++++ pyqt-4.9.6/sip/QtGui/qregion.sip	2013-04-24 14:14:54.282000018 +0400
+@@ -156,5 +156,7 @@
+ %End
+ };
+ 
++%If (PyQt_DataStream)
+ QDataStream &operator<<(QDataStream &, const QRegion & /Constrained/);
+ QDataStream &operator>>(QDataStream &, QRegion & /Constrained/);
++%End
+diff -ur PyQt-x11-gpl-4.9.6/sip/QtGui/qscrollbar.sip pyqt-4.9.6/sip/QtGui/qscrollbar.sip
+--- PyQt-x11-gpl-4.9.6/sip/QtGui/qscrollbar.sip	2012-12-08 13:51:38.000000000 +0400
++++ pyqt-4.9.6/sip/QtGui/qscrollbar.sip	2013-04-24 14:24:33.684000018 +0400
+@@ -47,7 +47,9 @@
+     virtual void mouseReleaseEvent(QMouseEvent *);
+     virtual void mouseMoveEvent(QMouseEvent *);
+     virtual void hideEvent(QHideEvent *);
++%If (PyQt_ContextMenu)
+     virtual void contextMenuEvent(QContextMenuEvent *);
++%End
+ %If (Qt_5_0_0 -)
+     virtual void wheelEvent(QWheelEvent *);
+ %End
+diff -ur PyQt-x11-gpl-4.9.6/sip/QtGui/qstandarditemmodel.sip pyqt-4.9.6/sip/QtGui/qstandarditemmodel.sip
+--- PyQt-x11-gpl-4.9.6/sip/QtGui/qstandarditemmodel.sip	2012-12-08 13:51:38.000000000 +0400
++++ pyqt-4.9.6/sip/QtGui/qstandarditemmodel.sip	2013-04-24 14:14:54.197000018 +0400
+@@ -56,8 +56,10 @@
+     virtual Qt::ItemFlags flags(const QModelIndex &index) const;
+     void clear();
+ %If (Qt_4_2_0 -)
++%If (PyQt_DragAndDrop)
+     virtual Qt::DropActions supportedDropActions() const;
+ %End
++%End
+ %If (Qt_4_2_0 -)
+     virtual QMap<int, QVariant> itemData(const QModelIndex &index) const;
+ %End
+@@ -208,9 +210,15 @@
+     virtual void setData(const QVariant &value, int role = Qt::UserRole+1);
+     QString text() const;
+     QIcon icon() const;
++%If (PyQt_ToolTip)
+     QString toolTip() const;
++%End
++%If (PyQt_StatusTip)
+     QString statusTip() const;
++%End
++%If (PyQt_WhatsThis)
+     QString whatsThis() const;
++%End
+     QSize sizeHint() const;
+     QFont font() const;
+     Qt::Alignment textAlignment() const;
+@@ -231,10 +239,12 @@
+     void setCheckable(bool checkable);
+     bool isTristate() const;
+     void setTristate(bool tristate);
++%If (PyQt_DragAndDrop)
+     bool isDragEnabled() const;
+     void setDragEnabled(bool dragEnabled);
+     bool isDropEnabled() const;
+     void setDropEnabled(bool dropEnabled);
++%End
+     QStandardItem *parent() const;
+     int row() const;
+     int column() const;
+@@ -270,14 +280,22 @@
+     };
+ 
+     virtual int type() const;
++%If (PyQt_DataStream)
+     virtual void read(QDataStream &in);
+     virtual void write(QDataStream &out) const;
++%End
+     virtual bool operator<(const QStandardItem &other /NoCopy/) const;
+     void setText(const QString &atext);
+     void setIcon(const QIcon &aicon);
++%If (PyQt_ToolTip)
+     void setToolTip(const QString &atoolTip);
++%End
++%If (PyQt_StatusTip)
+     void setStatusTip(const QString &astatusTip);
++%End
++%If (PyQt_WhatsThis)
+     void setWhatsThis(const QString &awhatsThis);
++%End
+     void setSizeHint(const QSize &asizeHint);
+     void setFont(const QFont &afont);
+     void setTextAlignment(Qt::Alignment atextAlignment);
+@@ -304,9 +322,11 @@
+ };
+ 
+ %End
++%If (PyQt_DataStream)
+ %If (Qt_4_2_0 -)
+ QDataStream &operator>>(QDataStream &in, QStandardItem &item /Constrained/);
+ %End
+ %If (Qt_4_2_0 -)
+ QDataStream &operator<<(QDataStream &out, const QStandardItem &item /Constrained/);
+ %End
++%End
+diff -ur PyQt-x11-gpl-4.9.6/sip/QtGui/qtextformat.sip pyqt-4.9.6/sip/QtGui/qtextformat.sip
+--- PyQt-x11-gpl-4.9.6/sip/QtGui/qtextformat.sip	2012-12-08 13:51:38.000000000 +0400
++++ pyqt-4.9.6/sip/QtGui/qtextformat.sip	2013-04-24 14:14:54.240000018 +0400
+@@ -60,8 +60,10 @@
+ %End
+ };
+ 
++%If (PyQt_DataStream)
+ QDataStream &operator<<(QDataStream &, const QTextLength & /Constrained/);
+ QDataStream &operator>>(QDataStream &, QTextLength & /Constrained/);
++%End
+ 
+ class QTextFormat
+ {
+@@ -327,8 +329,10 @@
+ %End
+ };
+ 
++%If (PyQt_DataStream)
+ QDataStream &operator<<(QDataStream &, const QTextFormat & /Constrained/);
+ QDataStream &operator>>(QDataStream &, QTextFormat & /Constrained/);
++%End
+ 
+ class QTextCharFormat : QTextFormat
+ {
+diff -ur PyQt-x11-gpl-4.9.6/sip/QtGui/QtGuimod.sip pyqt-4.9.6/sip/QtGui/QtGuimod.sip
+--- PyQt-x11-gpl-4.9.6/sip/QtGui/QtGuimod.sip	2012-12-08 13:51:39.000000000 +0400
++++ pyqt-4.9.6/sip/QtGui/QtGuimod.sip	2013-04-24 17:50:50.951000020 +0400
+@@ -57,6 +57,24 @@
+ 
+ %DefaultSupertype sip.simplewrapper
+ 
++%Feature PyQt_ButtonGroup
++%Feature PyQt_Clipboard
++%Feature PyQt_ContextMenu
++%Feature PyQt_Cursor
++%Feature PyQt_DataStream
++%Feature PyQt_DockWidget
++%Feature PyQt_DragAndDrop
++%Feature PyQt_GraphicsView
++%Feature PyQt_Menu
++%Feature PyQt_MenuBar
++%Feature PyQt_RubberBand
++%Feature PyQt_StatusBar
++%Feature PyQt_TabBar
++%Feature PyQt_TabWidget
++%Feature PyQt_ToolBar
++%Feature PyQt_WheelEvent
++%Feature PyQt_Shortcut
++
+ %Include qabstractbutton.sip
+ %Include qabstractitemdelegate.sip
+ %Include qabstractitemview.sip
+diff -ur PyQt-x11-gpl-4.9.6/sip/QtGui/qtransform.sip pyqt-4.9.6/sip/QtGui/qtransform.sip
+--- PyQt-x11-gpl-4.9.6/sip/QtGui/qtransform.sip	2012-12-08 13:51:38.000000000 +0400
++++ pyqt-4.9.6/sip/QtGui/qtransform.sip	2013-04-24 14:14:54.190000018 +0400
+@@ -122,12 +122,14 @@
+ };
+ 
+ %End
++%If (PyQt_DataStream)
+ %If (Qt_4_3_0 -)
+ QDataStream &operator<<(QDataStream &, const QTransform & /Constrained/);
+ %End
+ %If (Qt_4_3_0 -)
+ QDataStream &operator>>(QDataStream &, QTransform & /Constrained/);
+ %End
++%End
+ %If (Qt_4_3_0 -)
+ QPoint operator*(const QPoint &p, const QTransform &m);
+ %End
+diff -ur PyQt-x11-gpl-4.9.6/sip/QtGui/qwindowdefs.sip pyqt-4.9.6/sip/QtGui/qwindowdefs.sip
+--- PyQt-x11-gpl-4.9.6/sip/QtGui/qwindowdefs.sip	2012-12-08 13:51:38.000000000 +0400
++++ pyqt-4.9.6/sip/QtGui/qwindowdefs.sip	2013-04-24 14:14:54.251000018 +0400
+@@ -41,3 +41,6 @@
+ // MacOS/X specific definitions.
+ typedef long WId;
+ %End
++%If (WS_QWS)
++typedef unsigned long  WId;
++%End
+diff -ur PyQt-x11-gpl-4.9.6/sip/QtGui/qworkspace.sip pyqt-4.9.6/sip/QtGui/qworkspace.sip
+--- PyQt-x11-gpl-4.9.6/sip/QtGui/qworkspace.sip	2012-12-08 13:51:38.000000000 +0400
++++ pyqt-4.9.6/sip/QtGui/qworkspace.sip	2013-04-24 14:14:54.211000018 +0400
+@@ -79,7 +79,9 @@
+     virtual bool eventFilter(QObject *, QEvent *);
+     virtual void showEvent(QShowEvent *e);
+     virtual void hideEvent(QHideEvent *e);
++%If (PyQt_WheelEvent)
+     virtual void wheelEvent(QWheelEvent *e);
++%End
+ 
+ private:
+     QWorkspace(const QWorkspace &);
+diff -ur PyQt-x11-gpl-4.9.6/sip/QtSql/qsqldriver.sip pyqt-4.9.6/sip/QtSql/qsqldriver.sip
+--- PyQt-x11-gpl-4.9.6/sip/QtSql/qsqldriver.sip	2012-12-08 13:51:38.000000000 +0400
++++ pyqt-4.9.6/sip/QtSql/qsqldriver.sip	2013-04-24 14:14:54.182000018 +0400
+@@ -37,11 +37,15 @@
+             sipTypeDef **type;
+             int yes, no;
+         } graph[] = {
++#if defined(SIP_FEATURE_PyQt_ItemViews)
+             {sipName_QSqlQueryModel,	&sipType_QSqlQueryModel,	3, 1},
+             {sipName_QSqlRelationalDelegate,	&sipType_QSqlRelationalDelegate,	-1, 2},
++#endif
+             {sipName_QSqlDriver,	&sipType_QSqlDriver,	-1, -1},
++#if defined(SIP_FEATURE_PyQt_ItemViews)
+             {sipName_QSqlTableModel,	&sipType_QSqlTableModel,	4, -1},
+             {sipName_QSqlRelationalTableModel,	&sipType_QSqlRelationalTableModel,	-1, -1},
++#endif
+         };
+     
+         int i = 0;
+diff -ur PyQt-x11-gpl-4.9.6/sip/QtSql/QtSqlmod.sip pyqt-4.9.6/sip/QtSql/QtSqlmod.sip
+--- PyQt-x11-gpl-4.9.6/sip/QtSql/QtSqlmod.sip	2012-12-08 13:51:38.000000000 +0400
++++ pyqt-4.9.6/sip/QtSql/QtSqlmod.sip	2013-04-24 18:03:22.426000018 +0400
+@@ -58,6 +58,8 @@
+ 
+ %DefaultSupertype sip.simplewrapper
+ 
++%Feature PyQt_ItemViews
++
+ %Include qsql.sip
+ %Include qsqldatabase.sip
+ %Include qsqldriver.sip
+@@ -65,9 +67,15 @@
+ %Include qsqlfield.sip
+ %Include qsqlindex.sip
+ %Include qsqlquery.sip
+-%Include qsqlquerymodel.sip
++%If (PyQt_ItemViews)
++  %Include qsqlquerymodel.sip
++%End
+ %Include qsqlrecord.sip
+-%Include qsqlrelationaldelegate.sip
+-%Include qsqlrelationaltablemodel.sip
+-%Include qsqlresult.sip
+-%Include qsqltablemodel.sip
++%If (PyQt_ItemViews)
++  %Include qsqlrelationaldelegate.sip
++  %Include qsqlrelationaltablemodel.sip
++%End
++  %Include qsqlresult.sip
++%If (PyQt_ItemViews)
++  %Include qsqltablemodel.sip
++%End
+diff -ur PyQt-x11-gpl-4.9.6/sip/QtSvg/QtSvgmod.sip pyqt-4.9.6/sip/QtSvg/QtSvgmod.sip
+--- PyQt-x11-gpl-4.9.6/sip/QtSvg/QtSvgmod.sip	2012-12-08 13:51:38.000000000 +0400
++++ pyqt-4.9.6/sip/QtSvg/QtSvgmod.sip	2013-04-24 14:14:54.160000018 +0400
+@@ -56,7 +56,15 @@
+ 
+ %DefaultSupertype sip.simplewrapper
+ 
+-%Include qgraphicssvgitem.sip
+-%Include qsvggenerator.sip
+-%Include qsvgrenderer.sip
+-%Include qsvgwidget.sip
++%If (PyQt_GraphicsSVGItem)
++  %Include qgraphicssvgitem.sip
++%End
++%If (PyQt_SVGGenerator)
++  %Include qsvggenerator.sip
++%End
++%If (PyQt_SVGRenderer)
++  %Include qsvgrenderer.sip
++%End
++%If (PyQt_SVGWidget)
++  %Include qsvgwidget.sip
++%End
diff --git a/package/pyqt/pyqt.mk b/package/pyqt/pyqt.mk
new file mode 100644
index 0000000..83cab71
--- /dev/null
+++ b/package/pyqt/pyqt.mk
@@ -0,0 +1,78 @@
+#############################################################
+#
+# sip
+#
+#############################################################
+PYQT_VERSION = 4.9.6
+PYQT_SOURCE = PyQt-x11-gpl-$(PYQT_VERSION).tar.gz
+PYQT_SITE = http://sourceforge.net/projects/pyqt/files/PyQt4/PyQt-$(PYQT_VERSION)
+
+
+#PYQT_MAKE = $(MAKE1)
+
+################################################
+# TARGET
+
+PYQT_CONF_OPT = \
+
+#PYQT_AUTORECONF = YES
+PYQT_DEPENDENCIES = sip qt
+
+#	CROSS_SIPCONFIG=$(TARGET_DIR)/usr/lib/python$(PYTHON_VERSION_MAJOR)/site-packages \
+
+
+define PYQT_CONFIGURE_CMDS
+    echo "Construting qtdirs"
+    echo $(STAGING_DIR)/usr             > $(@D)/qtdirs.out
+    echo $(STAGING_DIR)/usr/include    >> $(@D)/qtdirs.out
+    echo $(STAGING_DIR)/usr/lib        >> $(@D)/qtdirs.out
+    echo $(HOST_DIR)/usr/bin           >> $(@D)/qtdirs.out
+    echo $(STAGING_DIR)/usr            >> $(@D)/qtdirs.out
+    echo $(STAGING_DIR)/usr/plugins    >> $(@D)/qtdirs.out
+
+    echo 264196                >> $(@D)/qtdirs.out
+    echo 8                     >> $(@D)/qtdirs.out
+    echo Open Source           >> $(@D)/qtdirs.out
+    echo shared                >> $(@D)/qtdirs.out
+    echo PyQt_Accessibility    >> $(@D)/qtdirs.out
+    echo PyQt_SessionManager   >> $(@D)/qtdirs.out
+    echo PyQt_qreal_double     >> $(@D)/qtdirs.out
+    echo PyQt_OpenSSL          >> $(@D)/qtdirs.out
+    echo PyQt_Shortcut         >> $(@D)/qtdirs.out
+    echo PyQt_ButtonGroup      >> $(@D)/qtdirs.out
+    echo PyQt_RawFont          >> $(@D)/qtdirs.out
+    echo WS_MACX               >> $(@D)/qtdirs.out
+    echo WS_WIN                >> $(@D)/qtdirs.out
+
+    ( cd $(@D); \
+	echo "TARGET_DIR=$(TARGET_DIR)" \
+	echo "HOST_DIR=$(HOST_DIR)" \
+	echo "BUILD_DIR=$(BUILD_DIR)" \
+	echo "PyQT Configuring Target DIR=`pwd`"; \
+	cp -f ../../../package/pyqt/configure-qws.py .;  \
+	PATH=$$PATH:$(HOST_DIR)/usr/bin \
+	CROSS_SIPCONFIG=$(BUILD_DIR)/sip-$(SIP_VERSION)/ \
+	QMAKESPEC=$(BUILD_DIR)/qt-$(QT_VERSION)/mkspecs/qws/linux-arm-g++ \
+	LD_LIBRARY_PATH=$(HOST_DIR)/lib $(HOST_DIR)/usr/bin/python configure-qws.py \
+		-b $(TARGET_DIR)/usr/bin \
+		-d $(TARGET_DIR)/usr/lib/python$(PYTHON_VERSION_MAJOR)/site-packages \
+		-l $(STAGING_DIR)/usr/include/python$(PYTHON_VERSION_MAJOR)  \
+		-m $(STAGING_DIR)/usr/lib/python$(PYTHON_VERSION_MAJOR)/config \
+		-q $(HOST_DIR)/usr/bin/qmake \
+		-v $(TARGET_DIR)/usr/share/sip/PyQt4 \
+		-w --confirm-license \
+    )
+    
+    echo "Configuring done"
+#    exit -1
+endef
+
+define PYQT_INSTALL_TARGET_CMDS
+# TODO copy only needed files  DESTDIR=
+    PATH="$(PATH):$(HOST_DIR)/usr/bin"  $(MAKE1) install -C $(@D)
+#    exit -1
+endef
+
+
+$(eval $(autotools-package))
+# $(eval $(host-autotools-package))
diff --git a/package/pyqt/pyqt.mk.exp b/package/pyqt/pyqt.mk.exp
new file mode 100644
index 0000000..bf12808
--- /dev/null
+++ b/package/pyqt/pyqt.mk.exp
@@ -0,0 +1,63 @@
+#############################################################
+#
+# sip
+#
+#############################################################
+PYQT_VERSION = 4.9.6
+PYQT_SOURCE = PyQt-x11-gpl-$(PYQT_VERSION).tar.gz
+PYQT_SITE = http://sourceforge.net/projects/pyqt/files/PyQt4/PyQt-$(PYQT_VERSION)
+
+
+#PYQT_MAKE = $(MAKE1)
+
+################################################
+# TARGET
+
+PYQT_CONF_OPT = \
+
+#PYQT_AUTORECONF = YES
+PYQT_DEPENDENCIES = sip qt
+
+#	CROSS_SIPCONFIG=$(TARGET_DIR)/usr/lib/python$(PYTHON_VERSION_MAJOR)/site-packages \
+
+
+define PYQT_CONFIGURE_CMDS
+    echo "Construting qtdirs"
+    ( cd $(@D); \
+	cp -f ../../../package/pyqt/mkconf.py .; \
+	$(HOST_DIR)/usr/bin/python mkconf.py "$(BUILD_DIR)/qt-$(QT_VERSION)" "$(TARGET_DIR)/usr" \
+    )
+    exit -1
+    echo "Configuring pyqt"
+    ( cd $(@D); \
+	echo "TARGET_DIR=$(TARGET_DIR)" \
+	echo "HOST_DIR=$(HOST_DIR)" \
+	echo "BUILD_DIR=$(BUILD_DIR)" \
+	echo "PyQT Configuring Target DIR=`pwd`"; \
+	cp -f ../../../package/pyqt/configure-qws.py .;  \
+	PATH=$$PATH:$(HOST_DIR)/usr/bin \
+	CROSS_SIPCONFIG=$(BUILD_DIR)/sip-$(SIP_VERSION)/ \
+	QMAKESPEC=$(BUILD_DIR)/qt-$(QT_VERSION)/mkspecs/qws/linux-arm-g++ \
+	LD_LIBRARY_PATH=$(HOST_DIR)/lib $(HOST_DIR)/usr/bin/python configure-qws.py \
+		-b $(TARGET_DIR)/usr/bin \
+		-d $(TARGET_DIR)/usr/lib/python$(PYTHON_VERSION_MAJOR)/site-packages \
+		-l $(STAGING_DIR)/usr/include/python$(PYTHON_VERSION_MAJOR)  \
+		-m $(STAGING_DIR)/usr/lib/python$(PYTHON_VERSION_MAJOR)/config \
+		-q $(HOST_DIR)/usr/bin/qmake \
+		-v $(TARGET_DIR)/usr/share/sip/PyQt4 \
+		-w --confirm-license \
+    )
+    
+    echo "Configuring done"
+#    exit -1
+endef
+
+define PYQT_INSTALL_TARGET_CMDS
+# TODO copy only needed files  DESTDIR=
+    PATH="$(PATH):$(HOST_DIR)/usr/bin"  $(MAKE1) install -C $(@D)
+#    exit -1
+endef
+
+
+$(eval $(autotools-package))
+# $(eval $(host-autotools-package))
diff --git a/package/pyqt/qtdirs.out b/package/pyqt/qtdirs.out
new file mode 100644
index 0000000..6637168
--- /dev/null
+++ b/package/pyqt/qtdirs.out
@@ -0,0 +1,19 @@
+/sd/serg/CIRROS/buildroot/output/host/usr/arm-buildroot-linux-uclibcgnueabi/sysroot/usr
+/sd/serg/CIRROS/buildroot/output/host/usr/arm-buildroot-linux-uclibcgnueabi/sysroot/usr/include
+/sd/serg/CIRROS/buildroot/output/host/usr/arm-buildroot-linux-uclibcgnueabi/sysroot/usr/lib
+/sd/serg/CIRROS/buildroot/output/host/usr/bin
+/sd/serg/CIRROS/buildroot/output/host/usr/arm-buildroot-linux-uclibcgnueabi/sysroot/usr
+/sd/serg/CIRROS/buildroot/output/host/usr/arm-buildroot-linux-uclibcgnueabi/sysroot/usr/plugins
+264197
+8
+Open Source
+shared
+PyQt_Accessibility
+PyQt_SessionManager
+PyQt_qreal_double
+PyQt_OpenSSL
+PyQt_Shortcut
+PyQt_ButtonGroup
+PyQt_RawFont
+WS_MACX
+WS_WIN
diff --git a/package/pyqt/qws.diff b/package/pyqt/qws.diff
new file mode 100644
index 0000000..8cada68
--- /dev/null
+++ b/package/pyqt/qws.diff
@@ -0,0 +1,968 @@
+--- configure.py	2012-12-08 13:51:13.000000000 +0400
++++ configure-qws.py	2013-08-19 15:45:31.845000032 +0400
+@@ -1,6 +1,7 @@
+ # This script generates the PyQt configuration and generates the Makefiles.
+ #
+ # Copyright (c) 2012 Riverbank Computing Limited <info@riverbankcomputing.com>
++# Copyright (c) 2012 David Boddie <david@boddie.org.uk>
+ # 
+ # This file is part of PyQt.
+ # 
+@@ -28,15 +29,21 @@
+ import glob
+ import optparse
+ import shutil
++import imp
++
+ 
+ import sipconfig
++cross_sipconfig = sipconfig
++
++## sipconfig = imp.load_source('sipconfig', '/sd/serg/CIRROS/buildroot-2013.02/output/build/sip-4.14.5/sipconfig.py')
++## cross_sipconfig = sipconfig
+ 
+ 
+ # Initialise the globals.
+ pyqt_version = 0x040906
+-pyqt_version_str = "4.9.6"
++pyqt_version_str = "4.9.6 (QWS)"
+ 
+-sip_min_version = 0x040e02
++sip_min_version = 0x040d03
+ 
+ qt_version = 0
+ qt_edition = ""
+@@ -74,9 +81,9 @@
+ # dynamic linker won't be able to resolve the symbols.  On other systems we
+ # assume we can just run qmake by using its full pathname.
+ if sys.platform == 'win32':
+-    MSG_CHECK_QMAKE = "Make sure you have a working Qt qmake on your PATH."
++    MSG_CHECK_QMAKE = "Make sure you have a working Qt v4 qmake on your PATH."
+ else:
+-    MSG_CHECK_QMAKE = "Make sure you have a working Qt qmake on your PATH or use the -q argument to explicitly specify a working Qt qmake."
++    MSG_CHECK_QMAKE = "Make sure you have a working Qt v4 qmake on your PATH or use the -q argument to explicitly specify a working Qt v4 qmake."
+ 
+ 
+ def find_default_qmake():
+@@ -177,9 +184,6 @@
+     g.add_option("-T", "--no-timestamp", action="store_true", default=False,
+             dest="no_timestamp", help="suppress timestamps in the header "
+             "comments of generated code [default: include timestamps]")
+-    g.add_option("--no-deprecated", action="store_false", default=True,
+-            dest="with_deprecated", help="disable Qt v4 features deprecated "
+-            "in Qt v5 [default: enabled]")
+ 
+     if sys.platform != 'win32':
+         if sys.platform.startswith('linux') or sys.platform == 'darwin':
+@@ -280,13 +284,14 @@
+     that pyrcc is automatically run against the examples.
+     """
+ 
+-    def __init__(self):
+-        sipconfig.ProgramMakefile.__init__(self, configuration=sipcfg,
++    def __init__(self, cfg = sipcfg):
++        self.cfg = cfg
++        sipconfig.ProgramMakefile.__init__(self, configuration=cfg,
+                 build_file=os.path.join(src_dir, "pyrcc", "pyrcc.sbf"),
+                 dir="pyrcc", install_dir=opts.pyqtbindir, console=1,
+                 qt=["QtCore", "QtXml"], debug=opts.debug, warnings=1,
+-                universal=sipcfg.universal, arch=sipcfg.arch,
+-                deployment_target=sipcfg.deployment_target)
++                universal=cfg.universal, arch=cfg.arch,
++                deployment_target=cfg.deployment_target)
+ 
+     def generate_target_default(self, mfile):
+         """Generate the default target."""
+@@ -303,12 +308,12 @@
+             exe = "./" + exe
+ 
+         # Find all the .qrc files in the examples.
+-        for root, _, files in os.walk("examples"):
+-            rel_root = os.path.join("..", root)
+-
+-            for fn in files:
+-                if fn.endswith(".qrc"):
+-                    mfile.write("\t%s %s -o %s %s\n" % (exe, flag, os.path.join(rel_root, fn[:-4] + "_rc.py"), os.path.join(rel_root, fn)))
++        #for root, _, files in os.walk("examples"):
++        #    rel_root = os.path.join("..", root)
++        #
++        #    for fn in files:
++        #        if fn.endswith(".qrc"):
++        #            mfile.write("\t%s %s-o %s %s\n" % (exe, flag, os.path.join(rel_root, fn[:-4] + "_rc.py"), os.path.join(rel_root, fn)))
+ 
+ 
+ class ConfigurePyQt4:
+@@ -342,9 +347,7 @@
+             0x040701: "Qt_4_7_0",
+             0x040702: "Qt_4_7_1",
+             0x040800: "Qt_4_7_2",
+-            0x040803: "Qt_4_8_0",
+-            0x040804: "Qt_4_8_3",
+-            0x050000: "Qt_4_8_4",
++            0x050000: "Qt_4_8_0",
+             0x060000: "Qt_5_0_0"
+         }
+ 
+@@ -366,10 +369,10 @@
+         pyqt_modules.append("QtCore")
+ 
+         check_module("QtGui", "qwidget.h", "new QWidget()")
+-        check_module("QtHelp", "qhelpengine.h", "new QHelpEngine(\"foo\")")
++        if qt_version < 0x050000: check_module("QtHelp", "qhelpengine.h", "new QHelpEngine(\"foo\")")
+         if qt_version < 0x050000: check_module("QtMultimedia", "QAudioDeviceInfo",
+                 "new QAudioDeviceInfo()")
+-        check_module("QtNetwork", "qhostaddress.h", "new QHostAddress()")
++        if qt_version < 0x050000: check_module("QtNetwork", "qhostaddress.h", "new QHostAddress()")
+         if qt_version < 0x050000: check_module("QtDBus", "qdbusconnection.h",
+                 "QDBusConnection::systemBus()")
+         if qt_version < 0x050000: check_module("QtDeclarative", "qdeclarativeview.h",
+@@ -378,39 +381,36 @@
+         if qt_version < 0x050000: check_module("QtScript", "qscriptengine.h", "new QScriptEngine()")
+         if qt_version < 0x050000: check_module("QtScriptTools", "qscriptenginedebugger.h",
+                 "new QScriptEngineDebugger()")
+-        check_module("QtSql", "qsqldatabase.h", "new QSqlDatabase()",
++        if qt_version < 0x050000: check_module("QtSql", "qsqldatabase.h", "new QSqlDatabase()",
+                 extra_libs=sql_libs)
+-        check_module("QtSvg", "qsvgwidget.h", "new QSvgWidget()")
++        if qt_version < 0x050000: check_module("QtSvg", "qsvgwidget.h", "new QSvgWidget()")
+         if qt_version < 0x050000: check_module("QtTest", "QtTest", "QTest::qSleep(0)")
+-        check_module("QtWebKit", "qwebpage.h", "new QWebPage()")
+-        check_module("QtXml", "qdom.h", "new QDomDocument()")
+-
+-        # Qt v5-beta1 causes compiler error messages.  Wait to see if it fixed
+-        # in a later release.
+-        if qt_version < 0x050000:
+-            check_module("QtXmlPatterns", "qxmlname.h", "new QXmlName()")
+-
++        if qt_version < 0x050000: check_module("QtWebKit", "qwebpage.h", "new QWebPage()")
++        if qt_version < 0x050000: check_module("QtXml", "qdom.h", "new QDomDocument()")
++        if qt_version < 0x050000: check_module("QtXmlPatterns", "qxmlname.h", "new QXmlName()")
+         if qt_version < 0x050000: check_module("phonon", "phonon/videowidget.h",
+                 "new Phonon::VideoWidget()")
+-        check_module("QtAssistant", "qassistantclient.h",
++        if qt_version < 0x050000: check_module("QtAssistant", "qassistantclient.h",
+                 "new QAssistantClient(\"foo\")", extra_lib_dirs=ass_lib_dirs,
+                 extra_libs=ass_libs)
+ 
+-        if not qt_shared:
+-            sipconfig.inform("QtDesigner module disabled with static Qt libraries.")
+-        elif sipcfg.universal:
+-            sipconfig.inform("QtDesigner module disabled with universal binaries.")
+-        else:
+-            if qt_version < 0x050000: check_module("QtDesigner", "QExtensionFactory",
+-                    "new QExtensionFactory()")
++        #if not qt_shared:
++        #    sipconfig.inform("QtDesigner module disabled with static Qt libraries.")
++        #elif sipcfg.universal:
++        #    sipconfig.inform("QtDesigner module disabled with universal binaries.")
++        #else:
++        #    if qt_version < 0x050000: check_module("QtDesigner", "QExtensionFactory",
++        #            "new QExtensionFactory()")
+ 
+-        if qt_version < 0x050000: check_module("QAxContainer", "qaxobject.h", "new QAxObject()",
+-                extra_libs=["QAxContainer"])
++        #if qt_version < 0x050000: check_module("QAxContainer", "qaxobject.h", "new QAxObject()",
++        #        extra_libs=["QAxContainer"])
+ 
+-        if os.path.isdir(os.path.join(src_dir, "dbus")):
+-            check_dbus()
++        #if os.path.isdir(os.path.join(src_dir, "dbus")):
++        #    check_dbus()
+ 
+     def code(self):
++        # Note that the order of the dependent modules is important.
++
+         cons_xtra_incdirs = []
+         cons_xtra_libdirs = []
+         cons_xtra_libs = []
+@@ -794,6 +794,7 @@
+         qmake_args = fix_qmake_args()
+         cwd = os.getcwd()
+ 
++        cfg = cross_sipcfg or sipcfg
+         for qpy, pro in qpylibs.items():
+             sipconfig.inform("Creating QPy support library for %s Makefile..." % qpy)
+ 
+@@ -805,22 +806,19 @@
+ 
+             f = open(wrapped_pro, 'w+')
+ 
+-            if sipcfg.arch:
+-                f.write(arch_config())
++            if cfg.arch:
++                f.write(arch_config(cfg))
+ 
+-            if sipcfg.universal:
+-                f.write("QMAKE_MAC_SDK = %s\n" % sipcfg.universal)
++            if cfg.universal:
++                f.write("QMAKE_MAC_SDK = %s\n" % cfg.universal)
+ 
+-            if sipcfg.deployment_target:
+-                f.write("QMAKE_MACOSX_DEPLOYMENT_TARGET = %s\n" % sipcfg.deployment_target)
++            if cfg.deployment_target:
++                f.write("QMAKE_MACOSX_DEPLOYMENT_TARGET = %s\n" % cfg.deployment_target)
+ 
+-            inc_path = [sipcfg.py_inc_dir]
++            inc_path = [cfg.py_inc_dir]
+             if qpy in ("QtCore", "QtDBus", "QtDeclarative", "QtOpenGL"):
+-                if sipcfg.sip_inc_dir != sipcfg.py_inc_dir:
+-                    inc_path.insert(0, sipcfg.sip_inc_dir)
+-
+-                if sipcfg.py_conf_inc_dir != sipcfg.py_inc_dir:
+-                    inc_path.insert(0, sipcfg.py_conf_inc_dir)
++                if cfg.sip_inc_dir != cfg.py_inc_dir:
++                    inc_path.insert(0, cfg.sip_inc_dir)
+ 
+                 if opts.bigqt:
+                     api_dir = "../../_qt"
+@@ -858,7 +856,7 @@
+         sipconfig.inform("Creating QPy support libraries Makefile...")
+ 
+         sipconfig.ParentMakefile(
+-            configuration=sipcfg,
++            configuration=cfg,
+             dir="qpy",
+             subdirs=list(qpylibs.keys())
+         ).generate()
+@@ -868,6 +866,7 @@
+     def tools(self):
+         tool = []
+ 
++        cfg = cross_sipcfg or sipcfg
+         if pydbusmoddir:
+             sipconfig.inform("Creating dbus support module Makefile...")
+ 
+@@ -878,9 +877,9 @@
+                 install_dir=pydbusmoddir,
+                 qt=["QtCore"],
+                 debug=opts.debug,
+-                universal=sipcfg.universal,
+-                arch=sipcfg.arch,
+-                deployment_target=sipcfg.deployment_target
++                universal=cfg.universal,
++                arch=cfg.arch,
++                deployment_target=cfg.deployment_target
+             )
+ 
+             add_makefile_extras(makefile, dbusincdirs, dbuslibdirs, dbuslibs)
+@@ -889,29 +888,29 @@
+             tool.append("dbus")
+ 
+         # Only include ElementTree for older versions of Python.
+-        if sipcfg.py_version < 0x020500:
+-            sipconfig.inform("Creating elementtree Makefile...")
++        #if sipcfg.py_version < 0x020500:
++        #    sipconfig.inform("Creating elementtree Makefile...")
+ 
+-            makefile = sipconfig.PythonModuleMakefile(
+-                configuration=sipcfg,
+-                dstdir=os.path.join(pyqt_modroot, "elementtree"),
+-                dir="elementtree"
+-            )
++        #    makefile = sipconfig.PythonModuleMakefile(
++        #        configuration=sipcfg,
++        #        dstdir=os.path.join(pyqt_modroot, "elementtree"),
++        #        dir="elementtree"
++        #    )
+ 
+-            makefile.generate()
+-            tool.append("elementtree")
++        #    makefile.generate()
++        #    tool.append("elementtree")
+ 
+         # Create the pyuic4 wrapper.  Use the GUI version on MacOS (so that
+         # previews work properly and normal console use will work anyway), but
+         # not on Windows (so that normal console use will work).
+-        sipconfig.inform("Creating pyuic4 wrapper...")
++        #sipconfig.inform("Creating pyuic4 wrapper...")
+ 
+-        if sys.platform == 'darwin':
+-            gui = True
+-            use_arch = opts.use_arch
+-        else:
+-            gui = False
+-            use_arch = ''
++        #if sys.platform == 'darwin':
++        #    gui = True
++        #    use_arch = opts.use_arch
++        #else:
++        #    gui = False
++        #    use_arch = ''
+ 
+         # The pyuic directory may not exist if we are building away from the
+         # source directory.
+@@ -921,12 +920,12 @@
+             pass
+ 
+         uicdir=os.path.join(pyqt_modroot, "uic")
+-        wrapper = sipconfig.create_wrapper(os.path.join(uicdir, "pyuic.py"), os.path.join("pyuic", "pyuic4"), gui, use_arch)
++        wrapper = cross_sipconfig.create_wrapper(os.path.join(uicdir, "pyuic.py"), os.path.join("pyuic", "pyuic4"), (sys.platform == "darwin"))
+ 
+         sipconfig.inform("Creating pyuic4 Makefile...")
+ 
+-        makefile = sipconfig.PythonModuleMakefile(
+-            configuration=sipcfg,
++        makefile = cross_sipconfig.PythonModuleMakefile(
++            configuration=cfg,
+             dstdir=uicdir,
+             srcdir=os.path.join(src_dir, "pyuic", "uic"),
+             dir="pyuic",
+@@ -936,55 +935,48 @@
+         makefile.generate()
+         tool.append("pyuic")
+ 
+-        if "QtXml" in pyqt_modules:
+-            sipconfig.inform("Creating pylupdate4 Makefile...")
++        if "QtXml" in pyqt_modules and \
++            "PyQt_Translation" not in qt_xfeatures and \
++            "PyQt_MessageBox" not in qt_xfeatures:
+ 
+-            cxxflags_app = sipcfg.build_macros().get("CXXFLAGS_APP", "")
++            sipconfig.inform("Creating pylupdate4 Makefile...")
+ 
+-            makefile = sipconfig.ProgramMakefile(
+-                configuration=sipcfg,
++            ### Note that the dependency on QtNetwork is only there on Embedded Linux.
++            makefile = cross_sipconfig.ProgramMakefile(
++                configuration=cfg,
+                 build_file=os.path.join(src_dir, "pylupdate", "pylupdate.sbf"),
+                 dir="pylupdate",
+                 install_dir=opts.pyqtbindir,
+                 console=1,
+-                qt=["QtCore", "QtXml"],
++                qt=["QtCore", "QtNetwork", "QtGui", "QtXml"],
+                 debug=opts.debug,
+                 warnings=1,
+-                universal=sipcfg.universal,
+-                arch=sipcfg.arch,
+-                deployment_target=sipcfg.deployment_target
++                universal=cfg.universal,
++                arch=cfg.arch,
++                deployment_target=cfg.deployment_target
+             )
+ 
+-            makefile.extra_include_dirs.append(
+-                    os.path.join(src_dir, "pylupdate"))
+-
+-            if cxxflags_app != "":
+-                makefile.extra_cxxflags.append(cxxflags_app)
+-
++            makefile.extra_include_dirs.append(os.path.join(src_dir, "pylupdate"))
+             makefile.generate()
+             tool.append("pylupdate")
+ 
+             sipconfig.inform("Creating pyrcc4 Makefile...")
+ 
+-            makefile = pyrccMakefile()
+-
+-            if cxxflags_app != "":
+-                makefile.extra_cxxflags.append(cxxflags_app)
+-
++            makefile = pyrccMakefile(cfg)
+             makefile.generate()
+             tool.append("pyrcc")
+         else:
+             sipconfig.inform("pylupdate4 and pyrcc4 will not be built because the Qt XML module is missing.")
+ 
+         if opts.designer_plugin and "QtDesigner" in pyqt_modules:
+-            py_major = sipcfg.py_version >> 16
+-            py_minor = (sipcfg.py_version >> 8) & 0x0ff
++            py_major = cfg.py_version >> 16
++            py_minor = (cfg.py_version >> 8) & 0x0ff
+ 
+             abi = getattr(sys, 'abiflags', '')
+ 
+             if sys.platform == 'win32':
+                 # Use abiflags in case it is supported in a future version.
+-                lib_dir_flag = quote("-L%s" % sipcfg.py_lib_dir)
++                lib_dir_flag = quote("-L%s" % cfg.py_lib_dir)
+                 link = "%s -lpython%d%d%s" % (lib_dir_flag, py_major, py_minor, abi)
+                 pysh_lib = "python%d%d%s.dll" % (py_major, py_minor, abi)
+             else:
+@@ -1035,8 +1027,8 @@
+                 prj = fin.read()
+                 fin.close()
+ 
+-                prj = prj.replace("@PYINCDIR@", quote(sipcfg.py_inc_dir))
+-                prj = prj.replace("@PYINCDIR@", " ".join((quote(sipcfg.py_conf_inc_dir), quote(sipcfg.py_inc_dir))))
++                prj = prj.replace("@PYINCDIR@", quote(cfg.py_inc_dir))
++                prj = prj.replace("@PYINCDIR@", " ".join((quote(cfg.py_conf_inc_dir), quote(cfg.py_inc_dir))))
+                 prj = prj.replace("@PYLINK@", link)
+                 prj = prj.replace("@PYSHLIB@", pysh_lib)
+                 prj = prj.replace("@QTPLUGINDIR@", quote(opts.plugindir + "/designer"))
+@@ -1044,13 +1036,13 @@
+                 fout = open("python.pro", "w+")
+ 
+                 if sipcfg.arch:
+-                    fout.write(arch_config())
++                    fout.write(arch_config(cfg))
+ 
+                 if sipcfg.universal:
+-                    fout.write("QMAKE_MAC_SDK = %s\n" % sipcfg.universal)
++                    fout.write("QMAKE_MAC_SDK = %s\n" % cfg.universal)
+ 
+                 if sipcfg.deployment_target:
+-                    fout.write("QMAKE_MACOSX_DEPLOYMENT_TARGET = %s\n" % sipcfg.deployment_target)
++                    fout.write("QMAKE_MACOSX_DEPLOYMENT_TARGET = %s\n" % cfg.deployment_target)
+ 
+                 if src_dir != os.path.curdir:
+                     fout.write("VPATH = %s\n" % os.path.join(src_dir, "designer"))
+@@ -1066,7 +1058,7 @@
+         return tool
+ 
+ 
+-def arch_config():
++def arch_config(cfg):
+     """Return the qmake CONFIG line for a MacOS binary."""
+ 
+     qmake_archs = []
+@@ -1110,7 +1102,8 @@
+     if sys.platform == "darwin" and qt_framework:
+         sipconfig.inform("Qt is built as a framework.")
+ 
+-    sipconfig.inform("SIP %s is being used." % sipcfg.sip_version_str)
++    cfg = cross_sipcfg or sipcfg
++    sipconfig.inform("SIP %s is being used." % cfg.sip_version_str)
+     sipconfig.inform("The Qt header files are in %s." % qt_incdir)
+     sipconfig.inform("The %s Qt libraries are in %s." % (lib_type, qt_libdir))
+     sipconfig.inform("The Qt binaries are in %s." % qt_bindir)
+@@ -1118,11 +1111,6 @@
+     sipconfig.inform("These PyQt modules will be built: %s." % ", ".join(pyqt_modules))
+     sipconfig.inform("The PyQt Python package will be installed in %s." % opts.pyqtmoddir)
+ 
+-    if opts.with_deprecated:
+-        sipconfig.inform("PyQt is being built with deprecated Qt v4 features")
+-    else:
+-        sipconfig.inform("PyQt is being built without deprecated Qt v4 features")
+-
+     if opts.no_docstrings:
+         sipconfig.inform("PyQt is being built without generated docstrings.")
+     else:
+@@ -1178,7 +1166,7 @@
+         "qt_lib_dir":         qt_libdir
+     }
+ 
+-    sipconfig.create_config_module(module, template, content, macros)
++    cross_sipconfig.create_config_module(module, template, content, macros)
+ 
+ 
+ def run_command(cmd, envvars=None):
+@@ -1288,7 +1276,7 @@
+     run_command(cmd)
+ 
+ 
+-def compile_qt_program(name, mname, extra_include_dirs=None, extra_lib_dirs=None, extra_libs=None):
++def compile_qt_program(name, mname, extra_include_dirs=None, extra_lib_dirs=None, extra_libs=None, library=False):
+     """Compile a simple Qt application.
+ 
+     name is the name of the single source file.
+@@ -1303,19 +1291,23 @@
+     opengl = (mname == "QtOpenGL")
+ 
+     qt = [mname]
+-    if mname in ("QtAssistant", "QtHelp", "QtOpenGL", "QtWebKit"):
++    if mname in ("QtOpenGL", "QtWebKit"):
+         qt.append("QtCore")
+ 
+-    makefile = sipconfig.ProgramMakefile(sipcfg, console=1, qt=qt, warnings=0,
+-            opengl=opengl, debug=opts.debug, arch=sipcfg.arch,
+-            deployment_target=sipcfg.deployment_target)
++    cfg = cross_sipcfg or sipcfg
++    makefile = cross_sipconfig.ProgramMakefile(cfg, console=1, qt=qt, warnings=0,
++            opengl=opengl, debug=opts.debug, arch=cfg.arch,
++            deployment_target=cfg.deployment_target)
+ 
+     add_makefile_extras(makefile, extra_include_dirs, extra_lib_dirs, extra_libs)
++    
++    if library:
++        makefile.extra_lflags.append(sipconfig._default_macros["LFLAGS_SHLIB"])
+ 
+     exe, build = makefile.build_command(name)
+ 
+-    if sipcfg.deployment_target:
+-        envvars = {'MACOSX_DEPLOYMENT_TARGET': '%s' % sipcfg.deployment_target}
++    if cfg.deployment_target:
++        envvars = {'MACOSX_DEPLOYMENT_TARGET': '%s' % cfg.deployment_target}
+     else:
+         envvars = None
+ 
+@@ -1512,7 +1504,8 @@
+ 
+     return compile_qt_program(cfgtest, mname,
+             extra_include_dirs=extra_include_dirs,
+-            extra_lib_dirs=extra_lib_dirs, extra_libs=extra_libs)
++            extra_lib_dirs=extra_lib_dirs, extra_libs=extra_libs,
++            library=True)
+ 
+ 
+ def set_sip_flags(pyqt):
+@@ -1520,32 +1513,31 @@
+ 
+     pyqt is the configuration instance.
+     """
++    cfg = cross_sipcfg or sipcfg
+     # If we don't check for signed interpreters, we exclude the 'VendorID'
+     # feature
+     if not opts.vendorcheck:
+         qt_sip_flags.append("-x")
+         qt_sip_flags.append("VendorID")
+ 
+-    if not opts.with_deprecated:
+-        qt_sip_flags.append("-x")
+-        qt_sip_flags.append("PyQt_Deprecated_5_0")
+-
+     # Handle the platform tag.
+     if sys.platform == 'win32':
+         plattag = "WS_WIN"
+     elif sys.platform == "darwin":
+-        if "__USE_WS_X11__" in sipcfg.build_macros()["DEFINES"]:
++        if "__USE_WS_X11__" in cfg.build_macros()["DEFINES"]:
+             plattag = "WS_X11"
+         else:
+             plattag = "WS_MACX"
++    elif cross_sipcfg:
++        plattag = "WS_QWS"
+     else:
+-        plattag = "WS_X11"
++        plattag = "WS_QWS" #X11"
+ 
+     qt_sip_flags.append("-t")
+     qt_sip_flags.append(plattag)
+ 
+     # Handle the Qt version tag.
+-    verstag = sipconfig.version_to_sip_tag(qt_version, pyqt.qt_version_tags(), "Qt")
++    verstag = cross_sipconfig.version_to_sip_tag(qt_version, pyqt.qt_version_tags(), "Qt")
+ 
+     # Handle any feature flags.
+     for xf in qt_xfeatures:
+@@ -1557,11 +1549,11 @@
+         qt_sip_flags.append(verstag)
+ 
+     # Handle the version specific Python features.
+-    if sipcfg.py_version < 0x020400:
++    if cfg.py_version < 0x020400:
+         qt_sip_flags.append("-x")
+         qt_sip_flags.append("Py_DateTime")
+ 
+-    if sipcfg.py_version < 0x030000:
++    if cfg.py_version < 0x030000:
+         qt_sip_flags.append("-x")
+         qt_sip_flags.append("Py_v3")
+ 
+@@ -1581,11 +1573,12 @@
+     # The dependencies between the different Qt libraries.  The order within
+     # each list is important.  Note that this affects the include directories
+     # as well as the libraries.
++    ### Note that the dependency on QtNetwork is only there on Embedded Linux.
+     LIB_DEPS = {
+         "QtCore": [],
+         "QtDBus": ["QtCore"],
+         "QtDeclarative": ["QtNetwork", "QtGui"],
+-        "QtGui": ["QtCore"],
++        "QtGui": ["QtCore", "QtNetwork"],
+         "QtHelp": ["QtGui"],
+         "QtMultimedia": ["QtGui"],
+         "QtNetwork": ["QtCore"],
+@@ -1752,9 +1745,10 @@
+         installs.append([sipfiles, os.path.join(opts.pyqtsipdir, mname)])
+ 
+     opengl = (mname == "QtOpenGL")
++    cfg = cross_sipcfg or sipcfg
+ 
+-    makefile = sipconfig.SIPModuleMakefile(
+-        configuration=sipcfg,
++    makefile = cross_sipconfig.SIPModuleMakefile(
++        configuration=cfg,
+         build_file=mname + ".sbf",
+         dir=mname,
+         install_dir=pyqt_modroot,
+@@ -1764,18 +1758,14 @@
+         warnings=1,
+         static=opts.static,
+         debug=opts.debug,
+-        universal=sipcfg.universal,
+-        arch=sipcfg.arch,
++        universal=cfg.universal,
++        arch=cfg.arch,
+         prot_is_public=opts.prot_is_public,
+-        deployment_target=sipcfg.deployment_target
++        deployment_target=cfg.deployment_target
+     )
+ 
+     add_makefile_extras(makefile, extra_include_dirs, extra_lib_dirs, extra_libs)
+ 
+-    if qt_version >= 0x050000 and opts.with_deprecated:
+-        # The name of this macro is very confusing.
+-        makefile.extra_defines.append('QT_DISABLE_DEPRECATED_BEFORE=0x040900')
+-
+     makefile.generate()
+ 
+ 
+@@ -1928,7 +1918,8 @@
+         sipconfig.error("Unable to find the qmake configuration file %s. Use the QMAKESPEC environment variable to specify the correct platform." % fname)
+ 
+     # Add the Qt specific macros to the default.
+-    names = list(sipcfg.build_macros().keys())
++    cfg = cross_sipcfg or sipcfg
++    names = list(cfg.build_macros().keys())
+     names.append("INCDIR_QT")
+     names.append("LIBDIR_QT")
+     names.append("MOC")
+@@ -1939,19 +1930,12 @@
+         "QT_INSTALL_LIBS":      qt_libdir
+     }
+ 
+-    macros = sipconfig.parse_build_macros(fname, names, overrides, properties)
++    macros = cross_sipconfig.parse_build_macros(fname, names, overrides, properties)
+ 
+     if macros is None:
+         return None
+ 
+-    # Qt5 doesn't seem to support the specific macros so add them if they are
+-    # missing.
+-    if macros.get("INCDIR_QT", "") == "":
+-        macros["INCDIR_QT"] = qt_incdir
+-
+-    if macros.get("LIBDIR_QT", "") == "":
+-        macros["LIBDIR_QT"] = qt_libdir
+-
++    # Make sure we have an entry for MOC (which Qt v5 doesn't provide).
+     if macros.get("MOC", "") == "":
+         default_moc = os.path.join(qt_bindir, "moc")
+         if sys.platform == 'win32':
+@@ -1989,16 +1973,21 @@
+     # Get the Makefile generator.
+     generator = macros["MAKEFILE_GENERATOR"]
+ 
++    if cross_sipconfig:
++        macros["CXXFLAGS"] += ' -fPIC -fpermissive '
++        macros["LFLAGS_PLUGIN"] += " -Wl,-rpath="+qt_libdir+" "
++
+     # We haven't yet factored out sipconfig's knowledge of how to build Qt
+     # binaries and it is expecting to find these in the configuration when it
+     # generates the Makefiles.
+-    sipcfg.qt_version = qt_version
+-    sipcfg.qt_edition = qt_edition
+-    sipcfg.qt_winconfig = qt_shared
+-    sipcfg.qt_framework = qt_framework
+-    sipcfg.qt_threaded = 1
+-    sipcfg.qt_dir = qt_dir
+-    sipcfg.qt_lib_dir = qt_libdir
++    cfg = cross_sipcfg or sipcfg
++    cfg.qt_version = qt_version
++    cfg.qt_edition = qt_edition
++    cfg.qt_winconfig = qt_shared
++    cfg.qt_framework = qt_framework
++    cfg.qt_threaded = 1
++    cfg.qt_dir = qt_dir
++    cfg.qt_lib_dir = qt_libdir
+ 
+     return ConfigurePyQt4(generator)
+ 
+@@ -2043,8 +2032,9 @@
+     # Generate the qmake project file.
+     f = open(pro_file, "w")
+ 
+-    if sipcfg.arch:
+-        f.write(arch_config())
++    cfg = cross_sipcfg or sipcfg
++    if cfg.arch:
++        f.write(arch_config(cfg))
+ 
+     f.write(
+ """QT = core
+@@ -2060,16 +2050,16 @@
+     # Generate the source code.
+     f = open(cpp_file, "w")
+ 
++    ### This code is never run when we make libraries for QWS, so we don't
++    ### have to keep the list of checks for Qt features up to date.
++
+     f.write(
+ """#include <QCoreApplication>
+ #include <QFile>
+ #include <QLibraryInfo>
+ #include <QTextStream>
+ 
+-// These seem to be missing from the Qt v5 beta.
+-#if !defined(QT_EDITION_DESKTOP)
+-#define QT_EDITION_DESKTOP      8
+-#endif
++// This seems to be missing from the Qt v5 alpha.
+ #if !defined(QT_EDITION_OPENSOURCE)
+ #define QT_EDITION_OPENSOURCE   8
+ #endif
+@@ -2104,6 +2094,10 @@
+ 
+     // Determine which features should be disabled.
+ 
++#if defined(QT_NO_RAW_FONT)
++    out << "PyQt_RawFont\\n";
++#endif
++
+ #if defined(QT_NO_ACCESSIBILITY)
+     out << "PyQt_Accessibility\\n";
+ #endif
+@@ -2128,10 +2122,134 @@
+     out << "PyQt_OpenSSL\\n";
+ #endif
+ 
++#if defined(QT_NO_PICTURE)
++    out << "PyQt_Picture\\n";
++#endif
++
++#if defined(QT_NO_PRINTDIALOG)
++    out << "PyQt_PrintDialog\\n";
++#endif
++
++#if defined(QT_NO_PRINTPREVIEWDIALOG)
++    out << "PyQt_PrintPreviewDialog\\n";
++#endif
++
++#if defined(QT_NO_PRINTPREVIEWWIDGET)
++    out << "PyQt_PrintPreviewWidget\\n";
++#endif
++
++#if defined(QT_NO_PRINTER)
++    out << "PyQt_Printer\\n";
++#endif
++
++#if defined(QT_NO_PROGRESSDIALOG)
++    out << "PyQt_ProgressDialog\\n";
++#endif
++
++#if defined(QT_NO_PROXYMODEL)
++    out << "PyQt_ProxyModel\\n";
++#endif
++
++#if defined(QT_NO_RUBBERBAND)
++    out << "PyQt_RubberBand\\n";
++#endif
++
++#if defined(QT_NO_PROCESS)
++    out << "PyQt_Process\\n";
++#endif
++
++#if defined(QT_NO_QWS_ALPHA_CURSOR)
++    out << "PyQt_QWS_Alpha_Cursor\\n";
++#endif
++
++#if defined(QT_NO_QWS_CURSOR)
++    out << "PyQt_QWS_Cursor\\n";
++#endif
++
++#if defined(QT_NO_QWS_DECORATION_WINDOWS)
++    out << "PyQt_QWS_Decoration_Windows\\n";
++#endif
++
++#if defined(QT_NO_QWS_MOUSE)
++    out << "PyQt_QWS_Mouse\\n";
++#endif
++
++#if defined(QT_NO_QWS_MOUSE_AUTO)
++    out << "PyQt_QWS_Mouse_Auto\\n";
++#endif
++
++#if defined(QT_NO_QWS_MOUSE_MANUAL)
++    out << "PyQt_QWS_Mouse_Manual\\n";
++#endif
++
++#if defined(QT_NO_RUBBERBAND)
++    out << "PyQt_RubberBand\\n";
++#endif
++
++#if defined(QT_NO_SCROLLBAR)
++    out << "PyQt_ScrollBar\\n";
++#endif
++
++#if defined(QT_NO_SESSIONMANAGER)
++    out << "PyQt_SessionManager\\n";
++#endif
++
+ #if defined(QT_NO_SIZEGRIP)
+     out << "PyQt_SizeGrip\\n";
+ #endif
+ 
++#if defined(QT_NO_SOCKS5)
++    out << "PyQt_Socks5\\n";
++#endif
++
++#if defined(QT_NO_SORTFILTERPROXYMODEL)
++    out << "PyQt_SortFilterProxyModel\\n";
++#endif
++
++#if defined(QT_NO_SPLASHSCREEN)
++    out << "PyQt_SplashScreen\\n";
++#endif
++
++#if defined(QT_NO_SPLITTER)
++    out << "PyQt_Splitter\\n";
++#endif
++
++#if defined(QT_NO_STANDARDITEMMODEL)
++    out << "PyQt_StandardItemModel\\n";
++#endif
++
++#if defined(QT_NO_STATUSBAR)
++    out << "PyQt_StatusBar\\n";
++#endif
++
++#if defined(QT_NO_STATUSTIP)
++    out << "PyQt_StatusTip\\n";
++#endif
++
++#if defined(QT_NO_STRINGLISTMODEL)
++    out << "PyQt_StringListModel\\n";
++#endif
++
++#if defined(QT_NO_STYLE_CDE)
++    out << "PyQt_Style_CDE\\n";
++#endif
++
++#if defined(QT_NO_STYLE_MOTIF)
++    out << "PyQt_Style_Motif\\n";
++#endif
++
++#if defined(QT_NO_STYLE_PLASTIQUE)
++    out << "PyQt_Style_Plastique\\n";
++#endif
++
++#if defined(QT_NO_STYLE_WINDOWSXP)
++    out << "PyQt_Style_WindowsXP\\n";
++#endif
++
++#if defined(QT_NO_SYNTAXHIGHLIGHTER)
++    out << "PyQt_SyntaxHighlighter\\n";
++#endif
++
+ #if defined(QT_NO_SYSTEMTRAYICON)
+     out << "PyQt_SystemTrayIcon\\n";
+ #endif
+@@ -2152,10 +2270,6 @@
+     out << "PyQt_PrintPreviewWidget\\n";
+ #endif
+ 
+-#if defined(QT_NO_RAWFONT)
+-    out << "PyQt_RawFont\\n";
+-#endif
+-
+ #if !defined(QT3_SUPPORT) || QT_VERSION >= 0x040200
+     out << "PyQt_NoPrintRangeBug\\n";
+ #endif
+@@ -2164,8 +2278,9 @@
+     out << "PyQt_NoOpenGLES\\n";
+ #endif
+ 
+-    if (sizeof (qreal) != sizeof (double))
++#if defined(QT_NO_FPU) || defined(QT_ARCH_ARM) || defined(QT_ARCH_WINDOWSCE)
+         out << "PyQt_qreal_double\\n";
++#endif
+ 
+     return 0;
+ }
+@@ -2174,35 +2289,35 @@
+     f.close()
+ 
+     # Create the makefile, first making sure it doesn't already exist.
+-    remove_file(make_file)
+-    run_command("%s %s %s" % (opts.qmake, qmake_args, pro_file))
++    #remove_file(make_file)
++    #run_command("%s %s %s" % (opts.qmake, qmake_args, pro_file))
+ 
+-    if not os.access(make_file, os.F_OK):
+-        sipconfig.error("%s failed to create a makefile. %s" % (opts.qmake, MSG_CHECK_QMAKE))
++    #if not os.access(make_file, os.F_OK):
++    #    sipconfig.error("%s failed to create a makefile. %s" % (opts.qmake, MSG_CHECK_QMAKE))
+ 
+     # Try and work out the name of make.
+-    if sipcfg.platform.startswith("win32-msvc"):
+-        make = "nmake"
+-    elif sipcfg.platform == "win32-borland":
+-        make = "bmake"
+-    elif sipcfg.platform == "win32-g++":
+-        make = "mingw32-make"
+-    else:
+-        make = "make"
++    #if sipcfg.platform.startswith("win32-msvc"):
++    #    make = "nmake"
++    #elif sipcfg.platform == "win32-borland":
++    #    make = "bmake"
++    #elif sipcfg.platform == "win32-g++":
++    #    make = "mingw32-make"
++    #else:
++    #    make = "make"
+ 
+     # Create the executable, first making sure it doesn't exist.
+-    remove_file(exe_file)
+-    run_command("%s -f %s%s" % (make, make_file, make_target))
++    #remove_file(exe_file)
++    #run_command("%s -f %s%s" % (make, make_file, make_target))
+ 
+-    if not os.access(exe_file, os.X_OK):
+-        sipconfig.error("Failed to determine the layout of your Qt installation. Try again using the --verbose flag to see more detail about the problem.")
++    #if not os.access(exe_file, os.X_OK):
++    #    sipconfig.error("Failed to determine the layout of your Qt installation. Try again using the --verbose flag to see more detail about the problem.")
+ 
+     # Create the output file, first making sure it doesn't exist.
+-    remove_file(out_file)
+-    run_command(exe_file)
++    #remove_file(out_file)
++    #run_command(exe_file)
+ 
+     if not os.access(out_file, os.F_OK):
+-        sipconfig.error("%s failed to create %s. Make sure your Qt installation is correct." % (exe_file, out_file))
++        sipconfig.error("%s failed to create %s. Make sure your Qt v4 installation is correct." % (exe_file, out_file))
+ 
+     # Read the directories.
+     f = open(out_file, "r")
+@@ -2279,6 +2394,16 @@
+ 
+     global opts
+ 
++    cross_path = os.getenv("CROSS_SIPCONFIG")
++    global cross_sipcfg, cross_sipconfig
++    if cross_path:
++        import imp
++        c_file, c_filename, c_details = imp.find_module("sipconfig", [cross_path])
++        cross_sipconfig = imp.load_module("cross_sipconfig", c_file, c_filename, c_details)
++        cross_sipcfg = cross_sipconfig.Configuration()
++    else:
++        cross_sipcfg = None
++    
+     # Parse the command line.
+     p = create_optparser()
+     opts, args = p.parse_args()
+@@ -2324,7 +2449,11 @@
+         p.print_help()
+         sys.exit(2)
+ 
+-    sipcfg.set_build_macros(macros)
++    cfg = cross_sipcfg or sipcfg
++    if cross_sipcfg:
++        old_macros = cfg.build_macros()
++        macros.update(old_macros)
++    cfg.set_build_macros(macros)
+ 
+     # Check Qt is what we need.
+     pyqt = check_qt_installation(macros)
+@@ -2366,8 +2495,8 @@
+         if opts.mwg_qwt_dir:
+             xtra_modules.append("Qwt5")
+ 
+-    sipconfig.ParentMakefile(
+-        configuration=sipcfg,
++    cross_sipconfig.ParentMakefile(
++        configuration=cfg,
+         subdirs=pyqt.qpy_libs() + pyqt_modules + xtra_modules + pyqt.tools(),
+         installs=installs
+     ).generate()
+@@ -2382,6 +2511,9 @@
+ ###############################################################################
+ 
+ if __name__ == "__main__":
++
++    print sipconfig._pkg_config
++
+     try:
+         main()
+     except SystemExit:
diff --git a/package/sip/Config.in b/package/sip/Config.in
new file mode 100644
index 0000000..862aff1
--- /dev/null
+++ b/package/sip/Config.in
@@ -0,0 +1,5 @@
+config BR2_PACKAGE_SIP
+	bool "sip"
+	depends on BR2_PACKAGE_PYTHON
+	help
+	    SIP for pyQt
\ No newline at end of file
diff --git a/package/sip/configure.py b/package/sip/configure.py
new file mode 100644
index 0000000..d248649
--- /dev/null
+++ b/package/sip/configure.py
@@ -0,0 +1,563 @@
+# This script handles the SIP configuration and generates the Makefiles.
+#
+# Copyright (c) 2013 Riverbank Computing Limited <info@riverbankcomputing.com>
+#
+# This file is part of SIP.
+#
+# This copy of SIP is licensed for use under the terms of the SIP License
+# Agreement.  See the file LICENSE for more details.
+#
+# This copy of SIP may also used under the terms of the GNU General Public
+# License v2 or v3 as published by the Free Software Foundation which can be
+# found in the files LICENSE-GPL2 and LICENSE-GPL3 included in this package.
+#
+# SIP is supplied WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+
+import sys
+import os
+import glob
+import optparse
+from distutils import sysconfig
+
+import siputils
+
+
+# Initialise the globals.
+sip_version = 0x040e05
+sip_version_str = "4.14.5"
+py_version = sys.hexversion >> 8
+plat_py_site_dir = None
+plat_py_inc_dir = None
+plat_py_conf_inc_dir = None
+plat_py_lib_dir = None
+plat_sip_dir = None
+plat_bin_dir = None
+platform_specs = []
+src_dir = os.path.dirname(os.path.abspath(__file__))
+sip_module_base = None
+
+# Constants.
+DEFAULT_MACOSX_ARCH = 'i386 ppc'
+MACOSX_SDK_DIRS = ('/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs', '/Developer/SDKs')
+
+# Command line options.
+default_platform = None
+default_sipbindir = None
+default_sipmoddir = None
+default_sipincdir = None
+default_sipsipdir = None
+
+# The names of build macros extracted from the platform specific configuration
+# files.
+build_macro_names = [
+    "DEFINES", "CONFIG",
+    "CC",
+    "CFLAGS",
+    "CFLAGS_RELEASE", "CFLAGS_DEBUG",
+    "CFLAGS_CONSOLE", "CFLAGS_SHLIB", "CFLAGS_APP", "CFLAGS_THREAD",
+    "CFLAGS_MT", "CFLAGS_MT_DBG", "CFLAGS_MT_DLL", "CFLAGS_MT_DLLDBG",
+    "CFLAGS_EXCEPTIONS_ON", "CFLAGS_EXCEPTIONS_OFF",
+    "CFLAGS_RTTI_ON", "CFLAGS_RTTI_OFF",
+    "CFLAGS_STL_ON", "CFLAGS_STL_OFF",
+    "CFLAGS_WARN_ON", "CFLAGS_WARN_OFF",
+    "CHK_DIR_EXISTS", "COPY",
+    "CXX",
+    "CXXFLAGS",
+    "CXXFLAGS_RELEASE", "CXXFLAGS_DEBUG",
+    "CXXFLAGS_CONSOLE", "CXXFLAGS_SHLIB", "CXXFLAGS_APP", "CXXFLAGS_THREAD",
+    "CXXFLAGS_MT", "CXXFLAGS_MT_DBG", "CXXFLAGS_MT_DLL", "CXXFLAGS_MT_DLLDBG",
+    "CXXFLAGS_EXCEPTIONS_ON", "CXXFLAGS_EXCEPTIONS_OFF",
+    "CXXFLAGS_RTTI_ON", "CXXFLAGS_RTTI_OFF",
+    "CXXFLAGS_STL_ON", "CXXFLAGS_STL_OFF",
+    "CXXFLAGS_WARN_ON", "CXXFLAGS_WARN_OFF",
+    "DEL_FILE",
+    "EXTENSION_SHLIB", "EXTENSION_PLUGIN",
+    "INCDIR", "INCDIR_X11", "INCDIR_OPENGL",
+    "LIBS_CORE", "LIBS_GUI", "LIBS_NETWORK", "LIBS_OPENGL", "LIBS_WEBKIT",
+    "LINK", "LINK_SHLIB", "AIX_SHLIB", "LINK_SHLIB_CMD",
+    "LFLAGS", "LFLAGS_CONSOLE", "LFLAGS_CONSOLE_DLL", "LFLAGS_DEBUG",
+    "LFLAGS_DLL",
+    "LFLAGS_PLUGIN", "LFLAGS_RELEASE", "LFLAGS_SHLIB", "LFLAGS_SONAME",
+    "LFLAGS_THREAD", "LFLAGS_WINDOWS", "LFLAGS_WINDOWS_DLL", "LFLAGS_OPENGL",
+    "LIBDIR", "LIBDIR_X11", "LIBDIR_OPENGL",
+    "LIBS", "LIBS_CONSOLE", "LIBS_RT",
+    "LIBS_RTMT", "LIBS_THREAD", "LIBS_WINDOWS", "LIBS_X11",
+    "MAKEFILE_GENERATOR",
+    "MKDIR",
+    "RPATH", "LFLAGS_RPATH",
+    "AR", "RANLIB", "LIB", "STRIP"
+]
+
+
+def show_platforms():
+    """Display the different platform/compilers.
+    """
+    sys.stdout.write("""
+The following platform/compiler configurations are supported:
+
+""")
+
+    platform_specs.sort()
+    sys.stdout.write(siputils.format(", ".join(platform_specs), leftmargin=2))
+    sys.stdout.write("\n\n")
+
+
+def show_macros():
+    """Display the different build macros.
+    """
+    sys.stdout.write("""
+The following options may be used to adjust the compiler configuration:
+
+""")
+
+    build_macro_names.sort()
+    sys.stdout.write(siputils.format(", ".join(build_macro_names), leftmargin=2))
+    sys.stdout.write("\n\n")
+
+
+def set_defaults():
+    """Set up the defaults for values that can be set on the command line.
+    """
+    global default_platform, default_sipbindir, default_sipmoddir
+    global default_sipincdir, default_sipsipdir
+
+    # Set the platform specific default specification.
+    platdefaults = {
+        "aix":          "aix-xlc",
+        "bsd":          "bsdi-g++",
+        "cygwin":       "cygwin-g++",
+        "darwin":       "macx-g++",
+        "dgux":         "dgux-g++",
+        "freebsd":      "freebsd-g++",
+        "gnu":          "hurd-g++",
+        "hp-ux":        "hpux-acc",
+        "irix":         "irix-cc",
+        "linux":        "linux-g++",
+        "lynxos":       "lynxos-g++",
+        "netbsd":       "netbsd-g++",
+        "openbsd":      "openbsd-g++",
+        "openunix":     "unixware-cc",
+        "osf1":         "tru64-cxx",
+        "qnx":          "qnx-g++",
+        "reliantunix":  "reliant-cds",
+        "sco_sv":       "sco-cc",
+        "sinix":        "reliant-cds",
+        "sunos5":       "solaris-cc",
+        "ultrix":       "ultrix-g++",
+        "unix_sv":      "unixware-g++",
+        "unixware":     "unixware-cc"
+    }
+
+    default_platform = "none"
+
+    if sys.platform == "win32":
+        if py_version >= 0x030300:
+            default_platform = "win32-msvc2010"
+        elif py_version >= 0x020600:
+            default_platform = "win32-msvc2008"
+        elif py_version >= 0x020400:
+            default_platform = "win32-msvc.net"
+        else:
+            default_platform = "win32-msvc"
+    else:
+        for pd in list(platdefaults.keys()):
+            if sys.platform[:len(pd)] == pd:
+                default_platform = platdefaults[pd]
+                break
+
+    default_sipbindir = plat_bin_dir
+    default_sipmoddir = plat_py_site_dir
+    default_sipincdir = plat_py_inc_dir
+    default_sipsipdir = plat_sip_dir
+
+
+def inform_user():
+    """Tell the user the option values that are going to be used.
+    """
+    siputils.inform("The SIP code generator will be installed in %s." % opts.sipbindir)
+    siputils.inform("The %s module will be installed in %s." % (sip_module_base, opts.sipmoddir))
+    siputils.inform("The sip.h header file will be installed in %s." % opts.sipincdir)
+    siputils.inform("The default directory to install .sip files in is %s." % opts.sipsipdir)
+    siputils.inform("The platform/compiler configuration is %s." % opts.platform)
+
+    if opts.arch:
+        siputils.inform("MacOS/X binaries will be created for %s." % (", ".join(opts.arch.split())))
+
+    if opts.universal:
+        siputils.inform("MacOS/X universal binaries will be created using %s." % opts.universal)
+
+    if opts.deployment_target:
+        siputils.inform("MacOS/X deployment target is %s." % opts.deployment_target)
+
+
+def set_platform_directories():
+    """Initialise the global variables relating to platform specific
+    directories.
+    """
+    global plat_py_site_dir, plat_py_inc_dir, plat_py_conf_inc_dir
+    global plat_bin_dir, plat_py_lib_dir, plat_sip_dir
+
+    # We trust distutils for some stuff.
+    plat_py_site_dir = sysconfig.get_python_lib(plat_specific=1)
+    plat_py_inc_dir = sysconfig.get_python_inc()
+    plat_py_conf_inc_dir = os.path.dirname(sysconfig.get_config_h_filename())
+
+    if sys.platform == "win32":
+        plat_py_lib_dir = sys.prefix + "\\libs"
+        plat_bin_dir = sys.exec_prefix
+        plat_sip_dir = sys.prefix + "\\sip"
+    else:
+        lib_dir = sysconfig.get_python_lib(plat_specific=1, standard_lib=1)
+
+        plat_py_lib_dir = lib_dir + "/config"
+        plat_bin_dir = sys.exec_prefix + "/bin"
+        plat_sip_dir = sys.prefix + "/share/sip"
+
+
+def patch_files():
+    """Patch any files that need it."""
+
+    patched = (
+        ("siplib", "sip.h"),
+        ("siplib", "siplib.c"),
+        ("siplib", "siplib.sbf")
+    )
+
+    # The siplib directory may not exist if we are building away from the
+    # source directory.
+    try:
+        os.mkdir("siplib")
+    except OSError:
+        pass
+
+    for f in patched:
+        dst_fn = os.path.join(*f)
+        src_fn = os.path.join(src_dir, dst_fn + ".in")
+
+        siputils.inform("Creating %s..." % dst_fn)
+
+        dst = open(dst_fn, "w")
+        src = open(src_fn)
+
+        for line in src:
+            line = line.replace("@CFG_MODULE_NAME@", opts.sip_module)
+            line = line.replace("@CFG_MODULE_BASENAME@", sip_module_base)
+
+            dst.write(line)
+
+        dst.close()
+        src.close()
+
+
+def create_config(module, template, macros):
+    """Create the SIP configuration module so that it can be imported by build
+    scripts.
+
+    module is the module file name.
+    template is the template file name.
+    macros is the dictionary of build macros.
+    """
+    siputils.inform("Creating %s..." % module)
+
+    content = {
+        "sip_config_args":  sys.argv[1:],
+        "sip_version":      sip_version,
+        "sip_version_str":  sip_version_str,
+        "platform":         opts.platform,
+        "sip_bin":          os.path.join(opts.sipbindir, "sip"),
+        "sip_inc_dir":      opts.sipincdir,
+        "sip_mod_dir":      opts.sipmoddir,
+        "default_bin_dir":  plat_bin_dir,
+        "default_mod_dir":  plat_py_site_dir,
+        "default_sip_dir":  opts.sipsipdir,
+        "py_version":       py_version,
+        "py_inc_dir":       opts.py_inc_dir,
+        "py_conf_inc_dir":  opts.py_conf_inc_dir,
+        "py_lib_dir":       opts.py_lib_dir,
+        "universal":        opts.universal,
+        "arch":             opts.arch,
+        "deployment_target":    opts.deployment_target
+    }
+
+    siputils.create_config_module(module, template, content, macros)
+
+
+def create_makefiles(macros):
+    """Create the Makefiles.
+
+    macros is the dictionary of platform specific build macros.
+    """
+    # Bootstrap.  Make sure we get the right one.
+    sys.path.insert(0, os.path.curdir)
+    import sipconfig
+
+    cfg = sipconfig.Configuration()
+
+    cfg.set_build_macros(macros)
+
+    sipconfig.inform("Creating top level Makefile...")
+
+    sipconfig.ParentMakefile(
+        configuration=cfg,
+        subdirs=["sipgen", "siplib"],
+        installs=(["sipconfig.py", os.path.join(src_dir, "sipdistutils.py")],
+                cfg.sip_mod_dir)
+    ).generate()
+
+    sipconfig.inform("Creating sip code generator Makefile...")
+
+    sipconfig.ProgramMakefile(
+        configuration=cfg,
+        build_file=os.path.join(src_dir, "sipgen", "sipgen.sbf"),
+        dir="sipgen",
+        install_dir=os.path.dirname(cfg.sip_bin),
+        console=1,
+        warnings=0,
+        universal=opts.universal,
+        arch=opts.arch,
+        deployment_target=opts.deployment_target
+    ).generate()
+
+    sipconfig.inform("Creating sip module Makefile...")
+
+    makefile = sipconfig.ModuleMakefile(
+        configuration=cfg,
+        build_file=os.path.join(src_dir, "siplib", "siplib.sbf"),
+        dir="siplib",
+        install_dir=cfg.sip_mod_dir,
+        installs=([os.path.join(src_dir, "siplib", "sip.h")], cfg.sip_inc_dir),
+        console=1,
+        warnings=0,
+        static=opts.static,
+        debug=opts.debug,
+        universal=opts.universal,
+        arch=opts.arch,
+        deployment_target=opts.deployment_target
+    )
+
+    makefile.generate()
+
+
+def create_optparser(sdk_dir):
+    """Create the parser for the command line.
+    """
+    def store_abspath(option, opt_str, value, parser):
+        setattr(parser.values, option.dest, os.path.abspath(value))
+
+    p = optparse.OptionParser(usage="python %prog [opts] [macro=value] "
+            "[macro+=value]", version=sip_version_str)
+
+    # Note: we don't use %default to be compatible with Python 2.3.
+    p.add_option("-k", "--static", action="store_true", default=False,
+            dest="static", help="build the SIP module as a static library")
+    p.add_option("-p", "--platform", action="store",
+            default=default_platform, type="string", metavar="PLATFORM",
+            dest="platform", help="the platform/compiler configuration "
+            "[default: %s]" % default_platform)
+    p.add_option("-u", "--debug", action="store_true", default=False,
+            help="build with debugging symbols")
+    p.add_option("--sip-module", action="store", default="sip", type="string",
+            metavar="NAME", dest="sip_module", help="the package.module name "
+            "of the sip module [default: sip]")
+
+    if sys.platform == 'darwin':
+        # Get the latest SDK to use as the default.
+        sdks = glob.glob(sdk_dir + '/MacOSX*.sdk')
+        if len(sdks) > 0:
+            sdks.sort()
+            _, default_sdk = os.path.split(sdks[-1])
+        else:
+            default_sdk = 'MacOSX10.4u.sdk'
+
+        g = optparse.OptionGroup(p, title="MacOS X Configuration")
+        g.add_option("--arch", action="append", default=[], dest="arch",
+                choices=["i386", "x86_64", "ppc"],
+                help="build for architecture ARCH")
+        g.add_option("--deployment-target", action="store", default='',
+                metavar="VERSION", dest="deployment_target",
+                help="set the value of the MACOSX_DEPLOYMENT_TARGET "
+                        "environment variable in generated Makefiles")
+        g.add_option("-n", "--universal", action="store_true", default=False,
+                dest="universal",
+                help="build the SIP code generator and module as universal "
+                        "binaries")
+        g.add_option("-s", "--sdk", action="store", default=default_sdk,
+                type="string", metavar="SDK", dest="sdk",
+                help="the name of the SDK used when building universal "
+                        "binaries [default: %s]" % default_sdk)
+        p.add_option_group(g)
+
+    # Querying.
+    g = optparse.OptionGroup(p, title="Query")
+    g.add_option("--show-platforms", action="store_true", default=False,
+            dest="show_platforms", help="show the list of supported "
+            "platform/compiler configurations")
+    g.add_option("--show-build-macros", action="store_true", default=False,
+            dest="show_build_macros", help="show the list of supported build "
+            "macros")
+    p.add_option_group(g)
+
+    # Python configuration
+    g = optparse.OptionGroup(p, title="Python include path")
+    g.add_option("-i", "--py_inc_dir", action="callback",
+	    default=plat_py_inc_dir, type="string", metavar="DIR",
+	    dest="py_inc_dir", callback=store_abspath, help="where the Python "
+	    "include directory located [default: %s]" % plat_py_inc_dir)
+    g.add_option("-c", "--py_conf_inc_dir", action="callback",
+	    default=plat_py_conf_inc_dir, type="string", metavar="DIR",
+	    dest="py_conf_inc_dir", callback=store_abspath, help="where the Python "
+	    "Configuration include directory located [default: %s]" % plat_py_conf_inc_dir)
+    g.add_option("-l", "--py_lib_dir", action="callback",
+	    default=plat_py_conf_inc_dir, type="string", metavar="DIR",
+	    dest="py_lib_dir", callback=store_abspath, help="where the Python "
+	    "library located [default: %s]" % plat_py_lib_dir)
+
+
+    # Installation.
+    g = optparse.OptionGroup(p, title="Installation")
+    g.add_option("-b", "--bindir", action="callback",
+            default=default_sipbindir, type="string", metavar="DIR",
+            dest="sipbindir", callback=store_abspath, help="where the SIP "
+            "code generator will be installed [default: %s]" %
+            default_sipbindir)
+    g.add_option("-d", "--destdir", action="callback",
+            default=default_sipmoddir, type="string", metavar="DIR",
+            dest="sipmoddir", callback=store_abspath, help="where the SIP "
+            "module will be installed [default: %s]" % default_sipmoddir)
+    g.add_option("-e", "--incdir", action="callback",
+            default=default_sipincdir, type="string", metavar="DIR",
+            dest="sipincdir", callback=store_abspath, help="where the SIP "
+            "header file will be installed [default: %s]" % default_sipincdir)
+    g.add_option("-v", "--sipdir", action="callback",
+            default=default_sipsipdir, type="string", metavar="DIR",
+            dest="sipsipdir", callback=store_abspath, help="where .sip files "
+            "are normally installed [default: %s]" % default_sipsipdir)
+    p.add_option_group(g)
+
+    return p
+
+
+def main(argv):
+    """Create the configuration module module.
+
+    argv is the list of command line arguments.
+    """
+    siputils.inform("This is SIP %s for Python %s on %s." % (sip_version_str, sys.version.split()[0], sys.platform))
+
+    if py_version < 0x020300:
+        siputils.error("This version of SIP requires Python v2.3 or later.")
+
+    # Basic initialisation.
+    set_platform_directories()
+
+    # Build up the list of valid specs.
+    for s in os.listdir(os.path.join(src_dir, "specs")):
+        platform_specs.append(s)
+
+    # Determine the directory containing the default OS/X SDK.
+    if sys.platform == 'darwin':
+        for sdk_dir in MACOSX_SDK_DIRS:
+            if os.path.isdir(sdk_dir):
+                break
+        else:
+            sdk_dir = MACOSX_SDK_DIRS[0]
+    else:
+        sdk_dir = ''
+
+    # Parse the command line.
+    global opts
+
+    set_defaults()
+    p = create_optparser(sdk_dir)
+    opts, args = p.parse_args()
+
+    # Make sure MacOS specific options get initialised.
+    if sys.platform != 'darwin':
+        opts.universal = ''
+        opts.arch = []
+        opts.sdk = ''
+        opts.deployment_target = ''
+
+    # Handle the query options.
+    if opts.show_platforms or opts.show_build_macros:
+        if opts.show_platforms:
+            show_platforms()
+
+        if opts.show_build_macros:
+            show_macros()
+
+        sys.exit()
+
+    # Convert the list 'arch' option to a string.  Multiple architectures
+    # imply a universal binary.
+    if len(opts.arch) > 1:
+        opts.universal = True
+
+    opts.arch = ' '.join(opts.arch)
+
+    # Convert the boolean 'universal' option to a string.
+    if opts.universal:
+        if '/' in opts.sdk:
+            opts.universal = os.path.abspath(opts.sdk)
+        else:
+            opts.universal = sdk_dir + '/' + opts.sdk
+
+        if not os.path.isdir(opts.universal):
+            siputils.error("Unable to find the SDK directory %s. Use the --sdk flag to specify the name of the SDK or its full path." % opts.universal)
+
+        if opts.arch == '':
+            opts.arch = DEFAULT_MACOSX_ARCH
+    else:
+        opts.universal = ''
+
+    # Get the platform specific macros for building.
+    macros = siputils.parse_build_macros(
+            os.path.join(src_dir, "specs", opts.platform), build_macro_names,
+            args)
+
+    if macros is None:
+        siputils.error("Unsupported macro name specified. Use the --show-build-macros flag to see a list of supported macros.")
+        sys.exit(2)
+
+    # Fix the name of the sip module.
+    global sip_module_base
+
+    module_path = opts.sip_module.split(".")
+    sip_module_base = module_path[-1]
+
+    if len(module_path) > 1:
+        del module_path[-1]
+        module_path.insert(0, opts.sipmoddir)
+        opts.sipmoddir = os.path.join(*module_path)
+
+    # Tell the user what's been found.
+    inform_user()
+
+    # Patch any files that need it.
+    patch_files()
+
+    # Install the configuration module.
+    create_config("sipconfig.py", os.path.join(src_dir, "siputils.py"),
+            macros)
+
+    # Create the Makefiles.
+    create_makefiles(macros)
+
+
+###############################################################################
+# The script starts here.
+###############################################################################
+
+if __name__ == "__main__":
+    try:
+        main(sys.argv)
+    except SystemExit:
+        raise
+    except:
+        sys.stderr.write(
+"""An internal error occured.  Please report all the output from the program,
+including the following traceback, to support@riverbankcomputing.com.
+""")
+        raise
diff --git a/package/sip/sip-4.14.5-configure.py.patch b/package/sip/sip-4.14.5-configure.py.patch
new file mode 100644
index 0000000..06591c0
--- /dev/null
+++ b/package/sip/sip-4.14.5-configure.py.patch
@@ -0,0 +1,38 @@
+--- a/configure.py	2013-04-24 12:41:35.382000017 +0400
++++ b/configure.py	2013-04-24 13:09:30.000000000 +0400
+@@ -273,9 +273,9 @@
+         "default_mod_dir":  plat_py_site_dir,
+         "default_sip_dir":  opts.sipsipdir,
+         "py_version":       py_version,
+-        "py_inc_dir":       plat_py_inc_dir,
+-        "py_conf_inc_dir":  plat_py_conf_inc_dir,
+-        "py_lib_dir":       plat_py_lib_dir,
++        "py_inc_dir":       opts.py_inc_dir,
++        "py_conf_inc_dir":  opts.py_conf_inc_dir,
++        "py_lib_dir":       opts.py_lib_dir,
+         "universal":        opts.universal,
+         "arch":             opts.arch,
+         "deployment_target":    opts.deployment_target
+@@ -399,6 +399,22 @@
+             "macros")
+     p.add_option_group(g)
+ 
++    # Python configuration
++    g = optparse.OptionGroup(p, title="Python include path")
++    g.add_option("-i", "--py_inc_dir", action="callback",
++	    default=plat_py_inc_dir, type="string", metavar="DIR",
++	    dest="py_inc_dir", callback=store_abspath, help="where the Python "
++	    "include directory located [default: %s]" % plat_py_inc_dir)
++    g.add_option("-c", "--py_conf_inc_dir", action="callback",
++	    default=plat_py_conf_inc_dir, type="string", metavar="DIR",
++	    dest="py_conf_inc_dir", callback=store_abspath, help="where the Python "
++	    "Configuration include directory located [default: %s]" % plat_py_conf_inc_dir)
++    g.add_option("-l", "--py_lib_dir", action="callback",
++	    default=plat_py_conf_inc_dir, type="string", metavar="DIR",
++	    dest="py_lib_dir", callback=store_abspath, help="where the Python "
++	    "library located [default: %s]" % plat_py_lib_dir)
++
++
+     # Installation.
+     g = optparse.OptionGroup(p, title="Installation")
+     g.add_option("-b", "--bindir", action="callback",
diff --git a/package/sip/sip.mk b/package/sip/sip.mk
new file mode 100644
index 0000000..3f7e1fd
--- /dev/null
+++ b/package/sip/sip.mk
@@ -0,0 +1,62 @@
+#############################################################
+#
+# sip
+#
+#############################################################
+SIP_VERSION = 4.14.5
+SIP_SOURCE = sip-$(SIP_VERSION).tar.gz
+SIP_SITE = http://sourceforge.net/projects/pyqt/files/sip/sip-$(SIP_VERSION)
+
+sip_target_platform=arm-buildroot-linux-uclibcgnueabi-g++
+
+# missing deps for parsetime.l
+#http://sourceforge.net/projects/pyqt/files/sip/sip-4.14.5/sip-4.14.5.tar.gz
+SIP_MAKE = $(MAKE1)
+HOST_SIP_MAKE = $(MAKE1)
+
+################################################
+# HOST
+
+HOST_SIP_DEPENDENCIES = host-python
+#HOST_PYTHON_CONF_OPT +=
+define HOST_SIP_CONFIGURE_CMDS
+    (cd $(@D); \
+	echo "Host Configuring DIR=$(PWD)"; \
+	LD_LIBRARY_PATH=$(HOST_DIR)/lib $(HOST_DIR)/usr/bin/python configure.py; \
+    )
+#    exit -1
+endef
+
+
+################################################
+# TARGET
+
+SIP_CONF_OPT = \
+
+#SIP_AUTORECONF = YES
+SIP_DEPENDENCIES = host-sip python
+
+define SIP_CONFIGURE_CMDS
+    ( cd $(@D); \
+	echo "Target Configuring DIR=`pwd`"; \
+	cp ../../../package/sip/specs/$(sip_target_platform) ./specs;  \
+	LD_LIBRARY_PATH=$(HOST_DIR)/lib $(HOST_DIR)/usr/bin/python configure.py \
+		-b $(TARGET_DIR)/usr/bin \
+		-d $(TARGET_DIR)/usr/lib/python$(PYTHON_VERSION_MAJOR)/site-packages \
+		-e $(STAGING_DIR)/usr/include/python$(PYTHON_VERSION_MAJOR)  \
+		-v $(TARGET_DIR)/usr/share/sip \
+		-i $(STAGING_DIR)/usr/include/python$(PYTHON_VERSION_MAJOR) \
+		-c $(STAGING_DIR)/usr/lib/python$(PYTHON_VERSION_MAJOR)/config \
+		-p $(sip_target_platform); \
+    )
+    echo "Configuring"
+endef
+
+define SIP_INSTALL_TARGET_CMDS
+# TODO copy only needed files  DESTDIR=
+    PATH="$(PATH):$(HOST_DIR)/usr/bin"  $(SIP_MAKE) install -C $(@D)
+endef
+
+
+$(eval $(autotools-package))
+$(eval $(host-autotools-package))
diff --git a/package/sip/specs/arm-buildroot-linux-uclibcgnueabi-g++ b/package/sip/specs/arm-buildroot-linux-uclibcgnueabi-g++
new file mode 100644
index 0000000..42e2e59
--- /dev/null
+++ b/package/sip/specs/arm-buildroot-linux-uclibcgnueabi-g++
@@ -0,0 +1,90 @@
+#
+# qmake configuration for linux-arm-none-gnueabi-g++
+#
+
+MAKEFILE_GENERATOR	= UNIX
+TEMPLATE		= app
+CONFIG			+= qt warn_on release incremental link_prl
+QT			+= core gui
+QMAKE_INCREMENTAL_STYLE = sublib
+
+QMAKE_CC		= arm-buildroot-linux-uclibcgnueabi-gcc
+QMAKE_LEX		= flex
+QMAKE_LEXFLAGS		=
+QMAKE_YACC		= yacc
+QMAKE_YACCFLAGS		= -d
+QMAKE_YACCFLAGS_MANGLE  = -p $base -b $base
+QMAKE_YACC_HEADER       = $base.tab.h
+QMAKE_YACC_SOURCE       = $base.tab.c
+QMAKE_CFLAGS		= -pipe
+QMAKE_CFLAGS_DEPS	= -M
+QMAKE_CFLAGS_WARN_ON	= -Wall -W
+QMAKE_CFLAGS_WARN_OFF	= -w
+QMAKE_CFLAGS_RELEASE	= -O2
+QMAKE_CFLAGS_DEBUG	= -g
+QMAKE_CFLAGS_SHLIB	= -fPIC
+QMAKE_CFLAGS_YACC	= -Wno-unused -Wno-parentheses
+QMAKE_CFLAGS_THREAD	= -D_REENTRANT
+QMAKE_CFLAGS_HIDESYMS   = -fvisibility=hidden
+
+QMAKE_CXX		= arm-buildroot-linux-uclibcgnueabi-g++
+QMAKE_CXXFLAGS		= $$QMAKE_CFLAGS -fno-exceptions -fno-rtti
+QMAKE_CXXFLAGS_DEPS	= $$QMAKE_CFLAGS_DEPS
+QMAKE_CXXFLAGS_WARN_ON	= $$QMAKE_CFLAGS_WARN_ON
+QMAKE_CXXFLAGS_WARN_OFF	= $$QMAKE_CFLAGS_WARN_OFF
+QMAKE_CXXFLAGS_RELEASE	= $$QMAKE_CFLAGS_RELEASE
+QMAKE_CXXFLAGS_DEBUG	= $$QMAKE_CFLAGS_DEBUG
+QMAKE_CXXFLAGS_SHLIB	= $$QMAKE_CFLAGS_SHLIB
+QMAKE_CXXFLAGS_YACC	= $$QMAKE_CFLAGS_YACC
+QMAKE_CXXFLAGS_THREAD	= $$QMAKE_CFLAGS_THREAD
+QMAKE_CXXFLAGS_HIDESYMS = $$QMAKE_CFLAGS_HIDESYMS -fvisibility-inlines-hidden
+
+QMAKE_INCDIR		=
+QMAKE_LIBDIR		=
+QMAKE_INCDIR_X11	= 
+QMAKE_LIBDIR_X11	= 
+QMAKE_INCDIR_QT		= $$[QT_INSTALL_HEADERS]
+QMAKE_LIBDIR_QT		= $$[QT_INSTALL_LIBS]
+QMAKE_INCDIR_OPENGL	= 
+QMAKE_LIBDIR_OPENGL	= 
+
+QMAKE_LINK		= arm-buildroot-linux-uclibcgnueabi-g++
+QMAKE_LINK_SHLIB	= arm-buildroot-linux-uclibcgnueabi-g++
+QMAKE_LFLAGS		=
+QMAKE_LFLAGS_RELEASE	=
+QMAKE_LFLAGS_DEBUG	=
+QMAKE_LFLAGS_SHLIB	= -shared
+QMAKE_LFLAGS_PLUGIN	= $$QMAKE_LFLAGS_SHLIB
+QMAKE_LFLAGS_SONAME	= -Wl,-soname,
+QMAKE_LFLAGS_THREAD	=
+QMAKE_RPATH		= -Wl,-rpath,
+
+QMAKE_LIBS		=
+QMAKE_LIBS_DYNLOAD	= -ldl
+QMAKE_LIBS_X11		= 
+QMAKE_LIBS_X11SM	= 
+QMAKE_LIBS_NIS		= -lnsl
+QMAKE_LIBS_OPENGL	= 
+QMAKE_LIBS_OPENGL_QT	= 
+QMAKE_LIBS_THREAD	= -lpthread
+
+QMAKE_MOC		= $$[QT_INSTALL_BINS]/moc
+QMAKE_UIC		= $$[QT_INSTALL_BINS]/uic
+
+QMAKE_AR		= arm-buildroot-linux-uclibcgnueabi-ar cqs
+QMAKE_RANLIB		=
+
+QMAKE_TAR		= tar -cf
+QMAKE_GZIP		= gzip -9f
+
+QMAKE_COPY		= cp -f
+QMAKE_COPY_FILE         = $(COPY)
+QMAKE_COPY_DIR          = $(COPY) -r
+QMAKE_MOVE		= mv -f
+QMAKE_DEL_FILE		= rm -f
+QMAKE_DEL_DIR		= rmdir
+QMAKE_STRIP             = arm-buildroot-linux-uclibcgnueabi-strip
+QMAKE_STRIPFLAGS_LIB 	+= --strip-unneeded
+QMAKE_CHK_DIR_EXISTS	= test -d
+QMAKE_MKDIR		= mkdir -p
+load(qt_config)
diff --git a/package/sip/specs/linux-arm-none-gnueabi-g++ b/package/sip/specs/linux-arm-none-gnueabi-g++
new file mode 100644
index 0000000..4a8842a
--- /dev/null
+++ b/package/sip/specs/linux-arm-none-gnueabi-g++
@@ -0,0 +1,90 @@
+#
+# qmake configuration for linux-arm-none-gnueabi-g++
+#
+
+MAKEFILE_GENERATOR	= UNIX
+TEMPLATE		= app
+CONFIG			+= qt warn_on release incremental link_prl
+QT			+= core gui
+QMAKE_INCREMENTAL_STYLE = sublib
+
+QMAKE_CC		= arm-none-linux-gnueabi-gcc
+QMAKE_LEX		= flex
+QMAKE_LEXFLAGS		=
+QMAKE_YACC		= yacc
+QMAKE_YACCFLAGS		= -d
+QMAKE_YACCFLAGS_MANGLE  = -p $base -b $base
+QMAKE_YACC_HEADER       = $base.tab.h
+QMAKE_YACC_SOURCE       = $base.tab.c
+QMAKE_CFLAGS		= -pipe
+QMAKE_CFLAGS_DEPS	= -M
+QMAKE_CFLAGS_WARN_ON	= -Wall -W
+QMAKE_CFLAGS_WARN_OFF	= -w
+QMAKE_CFLAGS_RELEASE	= -O2
+QMAKE_CFLAGS_DEBUG	= -g
+QMAKE_CFLAGS_SHLIB	= -fPIC
+QMAKE_CFLAGS_YACC	= -Wno-unused -Wno-parentheses
+QMAKE_CFLAGS_THREAD	= -D_REENTRANT
+QMAKE_CFLAGS_HIDESYMS   = -fvisibility=hidden
+
+QMAKE_CXX		= arm-none-linux-gnueabi-g++
+QMAKE_CXXFLAGS		= $$QMAKE_CFLAGS -fno-exceptions -fno-rtti
+QMAKE_CXXFLAGS_DEPS	= $$QMAKE_CFLAGS_DEPS
+QMAKE_CXXFLAGS_WARN_ON	= $$QMAKE_CFLAGS_WARN_ON
+QMAKE_CXXFLAGS_WARN_OFF	= $$QMAKE_CFLAGS_WARN_OFF
+QMAKE_CXXFLAGS_RELEASE	= $$QMAKE_CFLAGS_RELEASE
+QMAKE_CXXFLAGS_DEBUG	= $$QMAKE_CFLAGS_DEBUG
+QMAKE_CXXFLAGS_SHLIB	= $$QMAKE_CFLAGS_SHLIB
+QMAKE_CXXFLAGS_YACC	= $$QMAKE_CFLAGS_YACC
+QMAKE_CXXFLAGS_THREAD	= $$QMAKE_CFLAGS_THREAD
+QMAKE_CXXFLAGS_HIDESYMS = $$QMAKE_CFLAGS_HIDESYMS -fvisibility-inlines-hidden
+
+QMAKE_INCDIR		=
+QMAKE_LIBDIR		=
+QMAKE_INCDIR_X11	= 
+QMAKE_LIBDIR_X11	= 
+QMAKE_INCDIR_QT		= $$[QT_INSTALL_HEADERS]
+QMAKE_LIBDIR_QT		= $$[QT_INSTALL_LIBS]
+QMAKE_INCDIR_OPENGL	= 
+QMAKE_LIBDIR_OPENGL	= 
+
+QMAKE_LINK		= arm-none-linux-gnueabi-g++
+QMAKE_LINK_SHLIB	= arm-none-linux-gnueabi-g++
+QMAKE_LFLAGS		=
+QMAKE_LFLAGS_RELEASE	=
+QMAKE_LFLAGS_DEBUG	=
+QMAKE_LFLAGS_SHLIB	= -shared
+QMAKE_LFLAGS_PLUGIN	= $$QMAKE_LFLAGS_SHLIB
+QMAKE_LFLAGS_SONAME	= -Wl,-soname,
+QMAKE_LFLAGS_THREAD	=
+QMAKE_RPATH		= -Wl,-rpath,
+
+QMAKE_LIBS		=
+QMAKE_LIBS_DYNLOAD	= -ldl
+QMAKE_LIBS_X11		= 
+QMAKE_LIBS_X11SM	= 
+QMAKE_LIBS_NIS		= -lnsl
+QMAKE_LIBS_OPENGL	= 
+QMAKE_LIBS_OPENGL_QT	= 
+QMAKE_LIBS_THREAD	= -lpthread
+
+QMAKE_MOC		= $$[QT_INSTALL_BINS]/moc
+QMAKE_UIC		= $$[QT_INSTALL_BINS]/uic
+
+QMAKE_AR		= arm-none-linux-gnueabi-ar cqs
+QMAKE_RANLIB		=
+
+QMAKE_TAR		= tar -cf
+QMAKE_GZIP		= gzip -9f
+
+QMAKE_COPY		= cp -f
+QMAKE_COPY_FILE         = $(COPY)
+QMAKE_COPY_DIR          = $(COPY) -r
+QMAKE_MOVE		= mv -f
+QMAKE_DEL_FILE		= rm -f
+QMAKE_DEL_DIR		= rmdir
+QMAKE_STRIP             = arm-none-linux-gnueabi-strip
+QMAKE_STRIPFLAGS_LIB 	+= --strip-unneeded
+QMAKE_CHK_DIR_EXISTS	= test -d
+QMAKE_MKDIR		= mkdir -p
+load(qt_config)
diff --git a/package/sip/specs/linux-arm-none-uclibcgnueabi-g++ b/package/sip/specs/linux-arm-none-uclibcgnueabi-g++
new file mode 100644
index 0000000..d5b9fdb
--- /dev/null
+++ b/package/sip/specs/linux-arm-none-uclibcgnueabi-g++
@@ -0,0 +1,90 @@
+#
+# qmake configuration for linux-arm-none-gnueabi-g++
+#
+
+MAKEFILE_GENERATOR	= UNIX
+TEMPLATE		= app
+CONFIG			+= qt warn_on release incremental link_prl
+QT			+= core gui
+QMAKE_INCREMENTAL_STYLE = sublib
+
+QMAKE_CC		= arm-none-linux-uclibcgnueabi-gcc
+QMAKE_LEX		= flex
+QMAKE_LEXFLAGS		=
+QMAKE_YACC		= yacc
+QMAKE_YACCFLAGS		= -d
+QMAKE_YACCFLAGS_MANGLE  = -p $base -b $base
+QMAKE_YACC_HEADER       = $base.tab.h
+QMAKE_YACC_SOURCE       = $base.tab.c
+QMAKE_CFLAGS		= -pipe
+QMAKE_CFLAGS_DEPS	= -M
+QMAKE_CFLAGS_WARN_ON	= -Wall -W
+QMAKE_CFLAGS_WARN_OFF	= -w
+QMAKE_CFLAGS_RELEASE	= -O2
+QMAKE_CFLAGS_DEBUG	= -g
+QMAKE_CFLAGS_SHLIB	= -fPIC
+QMAKE_CFLAGS_YACC	= -Wno-unused -Wno-parentheses
+QMAKE_CFLAGS_THREAD	= -D_REENTRANT
+QMAKE_CFLAGS_HIDESYMS   = -fvisibility=hidden
+
+QMAKE_CXX		= arm-none-linux-uclibcgnueabi-g++
+QMAKE_CXXFLAGS		= $$QMAKE_CFLAGS -fno-exceptions -fno-rtti
+QMAKE_CXXFLAGS_DEPS	= $$QMAKE_CFLAGS_DEPS
+QMAKE_CXXFLAGS_WARN_ON	= $$QMAKE_CFLAGS_WARN_ON
+QMAKE_CXXFLAGS_WARN_OFF	= $$QMAKE_CFLAGS_WARN_OFF
+QMAKE_CXXFLAGS_RELEASE	= $$QMAKE_CFLAGS_RELEASE
+QMAKE_CXXFLAGS_DEBUG	= $$QMAKE_CFLAGS_DEBUG
+QMAKE_CXXFLAGS_SHLIB	= $$QMAKE_CFLAGS_SHLIB
+QMAKE_CXXFLAGS_YACC	= $$QMAKE_CFLAGS_YACC
+QMAKE_CXXFLAGS_THREAD	= $$QMAKE_CFLAGS_THREAD
+QMAKE_CXXFLAGS_HIDESYMS = $$QMAKE_CFLAGS_HIDESYMS -fvisibility-inlines-hidden
+
+QMAKE_INCDIR		=
+QMAKE_LIBDIR		=
+QMAKE_INCDIR_X11	= 
+QMAKE_LIBDIR_X11	= 
+QMAKE_INCDIR_QT		= $$[QT_INSTALL_HEADERS]
+QMAKE_LIBDIR_QT		= $$[QT_INSTALL_LIBS]
+QMAKE_INCDIR_OPENGL	= 
+QMAKE_LIBDIR_OPENGL	= 
+
+QMAKE_LINK		= arm-none-linux-uclibcgnueabi-g++
+QMAKE_LINK_SHLIB	= arm-none-linux-uclibcgnueabi-g++
+QMAKE_LFLAGS		=
+QMAKE_LFLAGS_RELEASE	=
+QMAKE_LFLAGS_DEBUG	=
+QMAKE_LFLAGS_SHLIB	= -shared
+QMAKE_LFLAGS_PLUGIN	= $$QMAKE_LFLAGS_SHLIB
+QMAKE_LFLAGS_SONAME	= -Wl,-soname,
+QMAKE_LFLAGS_THREAD	=
+QMAKE_RPATH		= -Wl,-rpath,
+
+QMAKE_LIBS		=
+QMAKE_LIBS_DYNLOAD	= -ldl
+QMAKE_LIBS_X11		= 
+QMAKE_LIBS_X11SM	= 
+QMAKE_LIBS_NIS		= -lnsl
+QMAKE_LIBS_OPENGL	= 
+QMAKE_LIBS_OPENGL_QT	= 
+QMAKE_LIBS_THREAD	= -lpthread
+
+QMAKE_MOC		= $$[QT_INSTALL_BINS]/moc
+QMAKE_UIC		= $$[QT_INSTALL_BINS]/uic
+
+QMAKE_AR		= arm-none-linux-uclibcgnueabi-ar cqs
+QMAKE_RANLIB		=
+
+QMAKE_TAR		= tar -cf
+QMAKE_GZIP		= gzip -9f
+
+QMAKE_COPY		= cp -f
+QMAKE_COPY_FILE         = $(COPY)
+QMAKE_COPY_DIR          = $(COPY) -r
+QMAKE_MOVE		= mv -f
+QMAKE_DEL_FILE		= rm -f
+QMAKE_DEL_DIR		= rmdir
+QMAKE_STRIP             = arm-none-linux-uclibcgnueabi-strip
+QMAKE_STRIPFLAGS_LIB 	+= --strip-unneeded
+QMAKE_CHK_DIR_EXISTS	= test -d
+QMAKE_MKDIR		= mkdir -p
+load(qt_config)
diff --git a/package/sip/specs/linux-arm-unknown-gnueabi-g++ b/package/sip/specs/linux-arm-unknown-gnueabi-g++
new file mode 100644
index 0000000..6fe1963
--- /dev/null
+++ b/package/sip/specs/linux-arm-unknown-gnueabi-g++
@@ -0,0 +1,90 @@
+#
+# qmake configuration for linux-arm-unknown-gnueabi-g++
+#
+
+MAKEFILE_GENERATOR	= UNIX
+TEMPLATE		= app
+CONFIG			+= qt warn_on release incremental link_prl
+QT			+= core gui
+QMAKE_INCREMENTAL_STYLE = sublib
+
+QMAKE_CC		= arm-unknown-linux-gnueabi-gcc
+QMAKE_LEX		= flex
+QMAKE_LEXFLAGS		=
+QMAKE_YACC		= yacc
+QMAKE_YACCFLAGS		= -d
+QMAKE_YACCFLAGS_MANGLE  = -p $base -b $base
+QMAKE_YACC_HEADER       = $base.tab.h
+QMAKE_YACC_SOURCE       = $base.tab.c
+QMAKE_CFLAGS		= -pipe
+QMAKE_CFLAGS_DEPS	= -M
+QMAKE_CFLAGS_WARN_ON	= -Wall -W
+QMAKE_CFLAGS_WARN_OFF	= -w
+QMAKE_CFLAGS_RELEASE	= -O2
+QMAKE_CFLAGS_DEBUG	= -g
+QMAKE_CFLAGS_SHLIB	= -fPIC
+QMAKE_CFLAGS_YACC	= -Wno-unused -Wno-parentheses
+QMAKE_CFLAGS_THREAD	= -D_REENTRANT
+QMAKE_CFLAGS_HIDESYMS   = -fvisibility=hidden
+
+QMAKE_CXX		= arm-unknown-linux-gnueabi-g++
+QMAKE_CXXFLAGS		= $$QMAKE_CFLAGS -fno-exceptions -fno-rtti
+QMAKE_CXXFLAGS_DEPS	= $$QMAKE_CFLAGS_DEPS
+QMAKE_CXXFLAGS_WARN_ON	= $$QMAKE_CFLAGS_WARN_ON
+QMAKE_CXXFLAGS_WARN_OFF	= $$QMAKE_CFLAGS_WARN_OFF
+QMAKE_CXXFLAGS_RELEASE	= $$QMAKE_CFLAGS_RELEASE
+QMAKE_CXXFLAGS_DEBUG	= $$QMAKE_CFLAGS_DEBUG
+QMAKE_CXXFLAGS_SHLIB	= $$QMAKE_CFLAGS_SHLIB
+QMAKE_CXXFLAGS_YACC	= $$QMAKE_CFLAGS_YACC
+QMAKE_CXXFLAGS_THREAD	= $$QMAKE_CFLAGS_THREAD
+QMAKE_CXXFLAGS_HIDESYMS = $$QMAKE_CFLAGS_HIDESYMS -fvisibility-inlines-hidden
+
+QMAKE_INCDIR		=
+QMAKE_LIBDIR		=
+QMAKE_INCDIR_X11	= 
+QMAKE_LIBDIR_X11	= 
+QMAKE_INCDIR_QT		= $$[QT_INSTALL_HEADERS]
+QMAKE_LIBDIR_QT		= $$[QT_INSTALL_LIBS]
+QMAKE_INCDIR_OPENGL	= 
+QMAKE_LIBDIR_OPENGL	= 
+
+QMAKE_LINK		= arm-unknown-linux-gnueabi-g++
+QMAKE_LINK_SHLIB	= arm-unknown-linux-gnueabi-g++
+QMAKE_LFLAGS		=
+QMAKE_LFLAGS_RELEASE	=
+QMAKE_LFLAGS_DEBUG	=
+QMAKE_LFLAGS_SHLIB	= -shared
+QMAKE_LFLAGS_PLUGIN	= $$QMAKE_LFLAGS_SHLIB
+QMAKE_LFLAGS_SONAME	= -Wl,-soname,
+QMAKE_LFLAGS_THREAD	=
+QMAKE_RPATH		= -Wl,-rpath,
+
+QMAKE_LIBS		=
+QMAKE_LIBS_DYNLOAD	= -ldl
+QMAKE_LIBS_X11		= 
+QMAKE_LIBS_X11SM	= 
+QMAKE_LIBS_NIS		= -lnsl
+QMAKE_LIBS_OPENGL	= 
+QMAKE_LIBS_OPENGL_QT	= 
+QMAKE_LIBS_THREAD	= -lpthread
+
+QMAKE_MOC		= $$[QT_INSTALL_BINS]/moc
+QMAKE_UIC		= $$[QT_INSTALL_BINS]/uic
+
+QMAKE_AR		= arm-unknown-linux-gnueabi-ar cqs
+QMAKE_RANLIB		=
+
+QMAKE_TAR		= tar -cf
+QMAKE_GZIP		= gzip -9f
+
+QMAKE_COPY		= cp -f
+QMAKE_COPY_FILE         = $(COPY)
+QMAKE_COPY_DIR          = $(COPY) -r
+QMAKE_MOVE		= mv -f
+QMAKE_DEL_FILE		= rm -f
+QMAKE_DEL_DIR		= rmdir
+QMAKE_STRIP             = arm-unknown-linux-gnueabi-strip
+QMAKE_STRIPFLAGS_LIB 	+= --strip-unneeded
+QMAKE_CHK_DIR_EXISTS	= test -d
+QMAKE_MKDIR		= mkdir -p
+load(qt_config)
diff --git a/package/sip/specs/linux-x86_64-g++ b/package/sip/specs/linux-x86_64-g++
new file mode 100644
index 0000000..28d55f6
--- /dev/null
+++ b/package/sip/specs/linux-x86_64-g++
@@ -0,0 +1,90 @@
+#
+# qmake configuration for linux-x86_64-g++
+#
+
+MAKEFILE_GENERATOR	= UNIX
+TEMPLATE		= app
+CONFIG			+= qt warn_on release incremental link_prl
+QT			+= core gui
+QMAKE_INCREMENTAL_STYLE = sublib
+
+QMAKE_CC		= gcc
+QMAKE_LEX		= flex
+QMAKE_LEXFLAGS		=
+QMAKE_YACC		= yacc
+QMAKE_YACCFLAGS		= -d
+QMAKE_YACCFLAGS_MANGLE  = -p $base -b $base
+QMAKE_YACC_HEADER       = $base.tab.h
+QMAKE_YACC_SOURCE       = $base.tab.c
+QMAKE_CFLAGS		= -pipe
+QMAKE_CFLAGS_DEPS	= -M
+QMAKE_CFLAGS_WARN_ON	= -Wall -W
+QMAKE_CFLAGS_WARN_OFF	= -w
+QMAKE_CFLAGS_RELEASE	= -O2
+QMAKE_CFLAGS_DEBUG	= -g
+QMAKE_CFLAGS_SHLIB	= -fPIC
+QMAKE_CFLAGS_YACC	= -Wno-unused -Wno-parentheses
+QMAKE_CFLAGS_THREAD	= -D_REENTRANT
+QMAKE_CFLAGS_HIDESYMS   = -fvisibility=hidden
+
+QMAKE_CXX		= g++
+QMAKE_CXXFLAGS		= $$QMAKE_CFLAGS
+QMAKE_CXXFLAGS_DEPS	= $$QMAKE_CFLAGS_DEPS
+QMAKE_CXXFLAGS_WARN_ON	= $$QMAKE_CFLAGS_WARN_ON
+QMAKE_CXXFLAGS_WARN_OFF	= $$QMAKE_CFLAGS_WARN_OFF
+QMAKE_CXXFLAGS_RELEASE	= $$QMAKE_CFLAGS_RELEASE
+QMAKE_CXXFLAGS_DEBUG	= $$QMAKE_CFLAGS_DEBUG
+QMAKE_CXXFLAGS_SHLIB	= $$QMAKE_CFLAGS_SHLIB
+QMAKE_CXXFLAGS_YACC	= $$QMAKE_CFLAGS_YACC
+QMAKE_CXXFLAGS_THREAD	= $$QMAKE_CFLAGS_THREAD
+QMAKE_CXXFLAGS_HIDESYMS = $$QMAKE_CFLAGS_HIDESYMS -fvisibility-inlines-hidden
+
+QMAKE_INCDIR		=
+QMAKE_LIBDIR		=
+QMAKE_INCDIR_X11	= 
+QMAKE_LIBDIR_X11	= 
+QMAKE_INCDIR_QT		= $$[QT_INSTALL_HEADERS]
+QMAKE_LIBDIR_QT		= $$[QT_INSTALL_LIBS]
+QMAKE_INCDIR_OPENGL	= 
+QMAKE_LIBDIR_OPENGL	= 
+
+QMAKE_LINK		= g++
+QMAKE_LINK_SHLIB	= g++
+QMAKE_LFLAGS		=
+QMAKE_LFLAGS_RELEASE	=
+QMAKE_LFLAGS_DEBUG	=
+QMAKE_LFLAGS_SHLIB	= -shared
+QMAKE_LFLAGS_PLUGIN	= $$QMAKE_LFLAGS_SHLIB
+QMAKE_LFLAGS_SONAME	= -Wl,-soname,
+QMAKE_LFLAGS_THREAD	=
+QMAKE_RPATH		= -Wl,-rpath,
+
+QMAKE_LIBS		=
+QMAKE_LIBS_DYNLOAD	= -ldl
+QMAKE_LIBS_X11		= 
+QMAKE_LIBS_X11SM	= 
+QMAKE_LIBS_NIS		= -lnsl
+QMAKE_LIBS_OPENGL	= 
+QMAKE_LIBS_OPENGL_QT	= 
+QMAKE_LIBS_THREAD	= -lpthread
+
+QMAKE_MOC		= $$[QT_INSTALL_BINS]/moc
+QMAKE_UIC		= $$[QT_INSTALL_BINS]/uic
+
+QMAKE_AR		= ar cqs
+QMAKE_RANLIB		=
+
+QMAKE_TAR		= tar -cf
+QMAKE_GZIP		= gzip -9f
+
+QMAKE_COPY		= cp -f
+QMAKE_COPY_FILE         = $(COPY)
+QMAKE_COPY_DIR          = $(COPY) -r
+QMAKE_MOVE		= mv -f
+QMAKE_DEL_FILE		= rm -f
+QMAKE_DEL_DIR		= rmdir
+QMAKE_STRIP             = strip
+QMAKE_STRIPFLAGS_LIB 	+= --strip-unneeded
+QMAKE_CHK_DIR_EXISTS	= test -d
+QMAKE_MKDIR		= mkdir -p
+load(qt_config)
